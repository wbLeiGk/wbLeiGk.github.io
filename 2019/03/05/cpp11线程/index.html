<!DOCTYPE html>
<html lang="zh">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    
    <title>cpp11线程 | QK</title>
    
    
        <meta name="keywords" content="cpp11线程">
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="本来不想动~，想多看一点其他书~，但还是强迫自己写下这篇cpp11的线程概述~ 关于cpp的线程详解有一本书讲的蛮不错~，前一阵子再看《cpp concurrency in action》 主讲线程细节  一 、线程上层接口1 asnc() and Futuresaysnc() :提供一个可运行在后台的接口，其功能实现调用通过回调函数future&amp;lt;&amp;gt; : 让你等待一个线程的运行结果，返">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp11线程">
<meta property="og:url" content="http://yoursite.com/2019/03/05/cpp11线程/index.html">
<meta property="og:site_name" content="QK">
<meta property="og:description" content="本来不想动~，想多看一点其他书~，但还是强迫自己写下这篇cpp11的线程概述~ 关于cpp的线程详解有一本书讲的蛮不错~，前一阵子再看《cpp concurrency in action》 主讲线程细节  一 、线程上层接口1 asnc() and Futuresaysnc() :提供一个可运行在后台的接口，其功能实现调用通过回调函数future&amp;lt;&amp;gt; : 让你等待一个线程的运行结果，返">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-03-27T12:59:21.953Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="cpp11线程">
<meta name="twitter:description" content="本来不想动~，想多看一点其他书~，但还是强迫自己写下这篇cpp11的线程概述~ 关于cpp的线程详解有一本书讲的蛮不错~，前一阵子再看《cpp concurrency in action》 主讲线程细节  一 、线程上层接口1 asnc() and Futuresaysnc() :提供一个可运行在后台的接口，其功能实现调用通过回调函数future&amp;lt;&amp;gt; : 让你等待一个线程的运行结果，返">
    

    

    
        <link rel="icon" href="../../../../favicon.ico">
    

    <link rel="stylesheet" href="../../../../libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="../../../../libs/open-sans/styles.css">
    <link rel="stylesheet" href="../../../../libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="../../../../css/style.css">
    <script src="../../../../libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="../../../../libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>
    
    
        <link rel="stylesheet" href="../../../../libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="../../../../libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


    
</head>
</html>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="../../../../index.html" id="logo">
                <i class="logo"></i>
                <span class="site-title">QK</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="../../../../index.html">首页</a>
                
                    <a class="main-nav-link" href="../../../../about">关于</a>
                
            </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索">
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '../../../../content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="../../../../js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="../../../../index.html">首页</a></td>
                
                    <td><a class="main-nav-link" href="../../../../about">关于</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索">
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap" id="categories">
        <h3 class="widget-title">
            <span>分类</span>
            &nbsp;
            <a id="allExpand" href="#">
                <i class="fa fa-angle-double-down fa-2x"></i>
            </a>
        </h3>
        
        
        
         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Leetcode
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="../../../../2018/12/10/task-shchedule-weight/">求二叉树的路径和(path sum)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            个人生活
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="../../../02/25/life-record2/">生活小记2</a></li>  <li class="file"><a href="../../../02/16/life_record1/">生活小记</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            工具
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="../../26/git简单使用/">git简单使用</a></li>  <li class="file"><a href="../../18/工具screen/">screen</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            编程
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            cpp
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            DLL交互
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="../../../../2018/12/05/android-NDK/">android NDK</a></li>  <li class="file"><a href="../../25/c-加载cppdll/">c#加载cppdll</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            STL(类对象)
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="../../27/cppAndGolang-retryTaskCompare/">retry task in cpp &golang</a></li>  <li class="file"><a href="../../04/cpp缓冲与流对象/">cpp缓冲与流对象</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            元编程
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="../../26/cpp特化/">cpp SFINAE</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            多线程
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file active"><a href="">cpp11线程</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            算法
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="../../12/CPPTopologicOrder/">拓扑排序</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            go
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="../../../02/22/GoTree/">数据类型<平衡树></平衡树></a></li>  <li class="file"><a href="../../01/goAndCpp/">数据类型 <数组&切片&结构体></数组&切片&结构体></a></li>  <li class="file"><a href="../../03/goWeb/">GoWeb <1></1></a></li>  <li class="file"><a href="../../01/goDataMap/">数据类型<map></map></a></li>  <li class="file"><a href="../../../02/17/goGoroutine/">概述（2）</a></li>  <li class="file"><a href="../../../02/17/gonovice/">概述（1）</a></li>  <li class="file"><a href="../../18/go接口小得/">接口interface 心得（1）</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            设计模式
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="../../27/单例模式/">单例模式</a></li>  <li class="file"><a href="../../18/设计模式/">设计模式</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            计算机网络
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="../../../../2018/11/15/TCP-transport-institution/">TCP 传输机制</a></li>  <li class="file"><a href="../../../../2018/11/13/TCP-IP-demultipexing-multiplexing/">复路分解与多复路</a></li>  <li class="file"><a href="../../../../2018/12/09/router-data-plane/">路由器数据层</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="../../02/个人博客简介/">个人博客简介</a></li>  </ul> 
    </div>
    <script>
        $(document).ready(function() {
            var iconFolderOpenClass  = 'fa-folder-open';
            var iconFolderCloseClass = 'fa-folder';
            var iconAllExpandClass = 'fa-angle-double-down';
            var iconAllPackClass = 'fa-angle-double-up';
            // Handle directory-tree expansion:
            // 左键单独展开目录
            $(document).on('click', '#categories a[data-role="directory"]', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var subtree = $(this).siblings('ul');
                icon.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if (expanded) {
                    if (typeof subtree != 'undefined') {
                        subtree.slideUp({ duration: 100 });
                    }
                    icon.addClass(iconFolderCloseClass);
                } else {
                    if (typeof subtree != 'undefined') {
                        subtree.slideDown({ duration: 100 });
                    }
                    icon.addClass(iconFolderOpenClass);
                }
            });
            // 右键展开下属所有目录
            $('#categories a[data-role="directory"]').bind("contextmenu", function(event){
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var listNode = $(this).siblings('ul');
                var subtrees = $.merge(listNode.find('li ul'), listNode);
                var icons = $.merge(listNode.find('.fa'), icon);
                icons.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if(expanded) {
                    subtrees.slideUp({ duration: 100 });
                    icons.addClass(iconFolderCloseClass);
                } else {
                    subtrees.slideDown({ duration: 100 });
                    icons.addClass(iconFolderOpenClass);
                }
            })
            // 展开关闭所有目录按钮
            $(document).on('click', '#allExpand', function (event) {
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconAllExpandClass);
                icon.removeClass(iconAllExpandClass).removeClass(iconAllPackClass);
                if(expanded) {
                    $('#sidebar .fa.fa-folder').removeClass('fa-folder').addClass('fa-folder-open')
                    $('#categories li ul').slideDown({ duration: 100 });
                    icon.addClass(iconAllPackClass);
                } else {
                    $('#sidebar .fa.fa-folder-open').removeClass('fa-folder-open').addClass('fa-folder')
                    $('#categories li ul').slideUp({ duration: 100 });
                    icon.addClass(iconAllExpandClass);
                }
            });  
        });
    </script>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
            <section id="main"><article id="post-cpp11线程" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="../../../../categories/编程/">编程</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="../../../../categories/编程/cpp/">cpp</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="../../../../categories/编程/cpp/多线程/">多线程</a>
    </div>

                        
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="">
            <time datetime="2019-03-05T13:45:03.000Z" itemprop="datePublished">2019-03-05</time>
        </a>
    </div>


                        
                        
                    </div>
                
                
    
        <h1 class="article-title" itemprop="name">
            cpp11线程
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <p>本来不想动~，想多看一点其他书~，但还是强迫自己写下这篇cpp11的线程概述~</p>
<p>关于cpp的线程详解有一本书讲的蛮不错~，前一阵子再看《cpp concurrency in action》 主讲线程细节</p>
<hr>
<h1 id="一-、线程"><a href="#一-、线程" class="headerlink" title="一 、线程"></a>一 、线程</h1><h2 id="上层接口"><a href="#上层接口" class="headerlink" title="上层接口"></a>上层接口</h2><h3 id="1-asnc-and-Futures"><a href="#1-asnc-and-Futures" class="headerlink" title="1 asnc() and Futures"></a>1 asnc() and Futures</h3><p><strong>aysnc()</strong> :提供一个可运行在后台的接口，其功能实现调用通过回调函数<br><strong>future&lt;&gt;</strong> : 让你等待一个线程的运行结果，返回值或者异常<br><strong>shared_future&lt;&gt;</strong> : 与future不同的是，future取回的值只能被处理一次，而shared_future 可以被处理多次</p>
<p>example:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">this_thread::sleep_for(chrono::seconds(<span class="number">2</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   main()&#123;</span><br><span class="line">       <span class="keyword">auto</span> result = future&lt;<span class="keyword">int</span>&gt;(async([]() &#123;<span class="keyword">return</span> <span class="number">2</span>; &#125;)).get()+getValue();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"the value is :"</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>async() 函数有三个可选的状态</p>
<ol>
<li>立刻运行 launch::async=0x1</li>
<li>推迟运行，在适当的机会运行 launch::deferred =0x2</li>
<li>默认状态，可能是立刻运行或者推迟运行 launch::async|launch::deferred</li>
</ol>
<p>但是这三种状态都可以使用get()函数从而进行任务变化为运行的状态</p>
<p>而wait() 系列的函数则是被动的东岱，而不是强迫任务开始，get()则不然，是强迫你任务开始，而wait()对应三种状态：</p>
<ol>
<li>future_status::ready</li>
<li>future_status::deferred</li>
<li>future_status::timeout</li>
</ol>
<p>So, let me make clear: If you start to use async(), you should pass all objects necessary to process the passed functionality by value so that async() uses only local copies. If copying is too expensive, ensure that the objects are passed as constant reference and that mutable is not used</p>
<h2 id="底层接口-：thread"><a href="#底层接口-：thread" class="headerlink" title="底层接口 ：thread"></a>底层接口 ：thread</h2><p>thrad 使用方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(function object)</span></span>;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>thread 没有launch 策略，c++标准库尽可能的开始一个传入的函数对象，如果不可行，会抛出一个system_error的错误</li>
<li>没有接口可以处理线程的输出结构和返回值，你只能获取一个独一无二的线程ID</li>
<li>如果一个异常发生，而你没有捕获，那么程序将立刻中断，给线程传递一个外部的异常指针变量exception_ptrs</li>
<li>你必须执行join()或者detach()操作，否则程序将发生中断</li>
<li>如果你让线程在后台运行，一旦main() 函数结束，所有的线程将会立刻中断</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function">thread <span class="title">t</span><span class="params">([]() &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; <span class="built_in">endl</span>; this_thread::sleep_for(chrono::seconds(<span class="number">3</span>)); &#125;)</span></span>;</span><br><span class="line">t.join();</span><br></pre></td></tr></table></figure>
<h3 id="1-detached-threads"><a href="#1-detached-threads" class="headerlink" title="1 detached threads"></a>1 detached threads</h3><p>分离线程如果使用了非局部变量很容易成为一个问题，因为你一旦分离了线程，就意味了你失去了对它的控制，那么至于它运行多久，我们就不知道了。因为有可能在非局部变量生命周期结束的时候，线程有可能还没有结束，那么你的线程很可能会出现问题。因此，强烈将以，你传递给线程从copy-value 的方式，而不是引用的方式。</p>
<h3 id="2-Promises"><a href="#2-Promises" class="headerlink" title="2 Promises"></a>2 Promises</h3><p>为了能够取回线程中的值，像async()一样，我们使用promises函数特性辅助<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start thread using a promise to store the outcome</span></span><br><span class="line"><span class="built_in">std</span>::promise&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; p;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">([](<span class="built_in">string</span> &amp;b)&#123;b=<span class="number">12</span>;&#125;,<span class="built_in">std</span>::ref(p))</span></span>;</span><br><span class="line">t.detach();</span><br><span class="line">...</span><br><span class="line"><span class="comment">// create a future to process the outcome</span></span><br><span class="line"><span class="built_in">std</span>::future&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; f(p.get_future());</span><br><span class="line"><span class="comment">// process the outcome</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"result: "</span> &lt;&lt; f.get() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-packeaged-task-lt-gt"><a href="#3-packeaged-task-lt-gt" class="headerlink" title="3 packeaged_task&lt;&gt;"></a>3 packeaged_task&lt;&gt;</h3><p>aysnc() 让你处理立刻执行还是推迟，然后返回结果，有时候，你可能需要自己决定什么时间怎么执行一个任务，那么packaged_task&lt;&gt;就是这个目的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">compute</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::packaged_task&lt;<span class="keyword">double</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; task(compute); <span class="comment">// create a task</span></span><br><span class="line"><span class="built_in">std</span>::future&lt;<span class="keyword">double</span>&gt; f = task.get_future(); <span class="comment">// get its future</span></span><br><span class="line">...</span><br><span class="line">task(<span class="number">7</span>,<span class="number">5</span>); <span class="comment">// start the task (typically in a separate thread)</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">double</span> res = f.get(); <span class="comment">// wait for its end and process result/exception</span></span><br></pre></td></tr></table></figure></p>
<p>note:</p>
<p>thread.native_handle(): Returns a platform-specific type native_handle_type fornonportable extensions</p>
<p>unsigned int std::thread::hardware_concurrency ()<br>• Returns the number of possible threads.</p>
<p>• This value is just a hint and does not guarantee to be exact.</p>
<p>• Returns 0 if the number is not computable or well defined.</p>
<hr>
<h1 id="二-、同步"><a href="#二-、同步" class="headerlink" title="二 、同步"></a>二 、同步</h1><p>并发处理相同的数据~</p>
<p>相同数据：意味着相同的内存位置，如果不同线程处理不同的变量、对象或者不同的成员，自然也就没有问题啦，自c11，除了位域（bitfield），每个变量都被保证拥有自己的内存地址。并发的处理相同的数据，如果仅仅读是没有问题的，如果当一个超过1个线程修改了数据，那么就会陷入数据不同步的麻烦中，这也是数据竞争，也可以理解为不同线程间的矛盾处理，会产生未定义行为（undefined behave）</p>
<p>数据竞争带来的后果是，代码中是你想做的，但是实际输出结果不是你想要的</p>
<p>产生这种原因来源于编译器或者cpu的指令的优化~，首先我们得理解cpp对于并发的并发给了我们什么承诺（保证），像cpp 这样的编程语言总是抽象的支持在不同的硬件和平台上，根据他们的架构和目的，从而提供了不同的能力和接口，因而cpp规定了相应语句和操作产生的结果，并不是产生相应的汇编代码（assembler code）,cpp标准只要求结果，至于你怎么实现，却没有明确的定义。</p>
<p>因此，你不能期待编程语言给予你太多的承诺，实际上根据as-if rule,只要保证外部行为表现相同，每个编译器都通常选择优化代码，因此编译器产生的代码也是黑盒的。</p>
<p>我们也就知道，任何未定义的都可能是编译器和硬件提供商为了产生尽可能高效的代码导致的，比如：编译器可能会展开循环、打乱执行语句、消除无用代码、预取数据，并且在现代架构中，一个硬件缓冲区可能打乱存储和加载的顺序。</p>
<p>执行语句的乱序对于提高性能很有用，但是他们在并发中也极有可能破坏所期待结构的行为，因此，安全并不是默认保证的</p>
<h3 id="可能会发生的错误"><a href="#可能会发生的错误" class="headerlink" title="可能会发生的错误"></a>可能会发生的错误</h3><p><strong>数据处理不同步</strong>： 当两个线程并行处理读取和写入的操作，可能遇到以下情况</p>
<ul>
<li>半写入数据：当一个线程正在读取数据，另一个线程正在修改数据，当读取数据读到写入的一般的时间，也是读取的状态既不是旧值也不是新值</li>
<li>乱序：对于每一个线程的行为可能是正确的，但是一旦讲所有线程联系起来，可能会产生不可预期的结果</li>
</ul>
<p>但是cpp还是提供了一些先生安全保证</p>
<ul>
<li>处理不同数据： 处理统一容器的不同位置的数据</li>
<li>并发处理流：  并发处理字符流，文件流，流缓冲区可能导致未定义行为，但是对于格式化输入输出标准流被同步于c i/o,是可能的，虽然他可能导致插入字符</li>
</ul>
<h3 id="1-解决方案"><a href="#1-解决方案" class="headerlink" title="1 解决方案"></a>1 解决方案</h3><p>为了保证正确并行数据，我们使用以下方案</p>
<ol>
<li><p>原子操作 ：这意味着对于一个变量读取和写入都是原子的，或者语句的序列发生时排他性的，没有任何的中断，因此任何一个线程可以读取到新值。</p>
</li>
<li><p>保证执行顺序：我们需要保证一组特定的语句严格按照语句顺序执行，而不被编译器和硬件优化乱序执行。</p>
</li>
</ol>
<p>接口从高到底的：future-&gt;promises-&gt;thread-&gt;mutex &amp; lock -&gt;condition variaable -&gt;atomic data type -&gt;fences<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[风险低-&gt;高][性能低-&gt;高]</span><br><span class="line">```  </span><br><span class="line">没有提到<span class="keyword">volatile</span>的原因，在java中这个关键字提供原子性顺序执行，但是在cpp 中没有提供这种保证，仅仅指定处理外部资源~不应该被优化</span><br><span class="line"></span><br><span class="line">#### <span class="number">2</span> mutex <span class="keyword">and</span> lock</span><br><span class="line"></span><br><span class="line">mutex :用于控制并行处理资源的排他性，资源可能是一个对象、多个对象的集合体</span><br><span class="line">lock  ：于mutex 统一使用</span><br><span class="line"></span><br><span class="line">辅助函数：完成初始化即使用的功能</span><br><span class="line">lock_guard&lt;&gt;</span><br><span class="line">unique_guard&lt;&gt;</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="built_in">std</span>::mutex printMutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; l(printMutex)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> elem : s)&#123;</span><br><span class="line">        ....<span class="comment">// handle ?process</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> f1 =<span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,print,<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">auto</span> f2 =<span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,print,<span class="string">"world"</span>);</span><br><span class="line">f1.get();</span><br><span class="line">f2.get();</span><br></pre></td></tr></table></figure></p>
<h4 id="3-递归锁-recursive-mutex"><a href="#3-递归锁-recursive-mutex" class="headerlink" title="3 递归锁 recursive_mutex"></a>3 递归锁 recursive_mutex</h4><p>循环锁定同一个信号量，典型的事例活动对象、监听器，内部包含了信号量和锁，但是其他方法同样包含，而且需要调用已经包含了信号量和锁的函数，则需要使用递归锁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseAccess</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::recursive_mutex dbMutex;</span><br><span class="line">    ... <span class="comment">// state of database access</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertData</span> <span class="params">(...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::recursive_mutex&gt; lg(dbMutex);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertData</span> <span class="params">(...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::recursive_mutex&gt; lg(dbMutex);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createTableAndinsertData</span> <span class="params">(...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::recursive_mutex&gt; lg(dbMutex);</span><br><span class="line">        ...</span><br><span class="line">    createTable(...); <span class="comment">// OK: no deadlock</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="4-try-and-timeout-lock"><a href="#4-try-and-timeout-lock" class="headerlink" title="4 try and timeout lock"></a>4 try and timeout lock</h4><p>有时候，程序想要获取一个锁，但是却不想阻塞，这种情况下，信号量mutex提供了try_lock() 成员函数会尝试获取一个锁，如果成功返回true,反之false<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="comment">// try to acquire a lock and do other stuff while this isn’t possible</span></span><br><span class="line"><span class="keyword">while</span> (m.try_lock() == <span class="literal">false</span>) &#123;</span><br><span class="line">    doSomeOtherStuff();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lg(m,<span class="built_in">std</span>::adopt_lock);</span><br><span class="line"><span class="comment">// Note that try_lock() might fail spuriously. </span></span><br><span class="line"><span class="comment">// That is, it might fail (return false) even if the lock is not taken.</span></span><br><span class="line"><span class="comment">// This behavior is provided for memory-ordering reasons but is not widely known</span></span><br></pre></td></tr></table></figure></p>
<p>如果你想指定一个时间的话，可以使用time_mutex<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::time_mutex m;</span><br><span class="line"><span class="comment">// try to acquire a lock and do other stuff while this isn’t possible</span></span><br><span class="line"><span class="keyword">while</span> (m.try_lock_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>)) == <span class="literal">false</span>) &#123;</span><br><span class="line">    doSomeOtherStuff();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lg(m,<span class="built_in">std</span>::adopt_lock);</span><br></pre></td></tr></table></figure></p>
<p>一般而言，如果你想锁住超过1个以上的信号量，比如 传输一个受保护的资源向另一个受保护的资源</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex m1;</span><br><span class="line"><span class="built_in">std</span>::mutex m2;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock (m1, m2); <span class="comment">// lock both mutexes (or none if not possible)</span></span><br><span class="line">    <span class="comment">//Note that this lock() provides a deadlock-avoidance mechanism</span></span><br><span class="line">    <span class="comment">//which, however, means that the order of locking inside a multiple lock is undefined.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * std::try_lock()</span></span><br><span class="line"><span class="comment">     * try_lock() does not provide a deadlock-avoidance mechanism. Instead, it guarantees</span></span><br><span class="line"><span class="comment">     * that the locks are tried in the order of the passed arguments</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lockM1(m1,<span class="built_in">std</span>::adopt_lock);</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lockM2(m2,<span class="built_in">std</span>::adopt_lock);</span><br><span class="line">...</span><br><span class="line">&#125; <span class="comment">// automatically unlock all mutexes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * only the code snippet</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">lock_guard <span class="title">lg</span><span class="params">(m)</span> <span class="comment">//Creates a lock guard for the mutex m and locks it</span></span></span><br><span class="line"><span class="function">lock_guard <span class="title">lg</span><span class="params">(m,adopt_lock)</span> <span class="comment">//Creates a lock guard for the already locked mutex m</span></span></span><br><span class="line">lg.~lock_guard()</span><br></pre></td></tr></table></figure>
<ul>
<li>unique_lock&lt;&gt;</li>
</ul>
<p>如果说lock_guard&lt;&gt;仅仅提供简单的初始化即使用的功能，其内部仅仅完成了mutex.lock() mutex.unlock()~</p>
<p>那么unique_lock&lt;&gt; 不但提供了lock_guard&lt;&gt;所具备的功能之外，还提供了更复杂的功能，他决定了你可以时间怎么去对一个信号量加锁和释放，因此这个锁的的对象可以在初始化的时候绑定信号量与否</p>
<p>从成员函数上来看，unique_lock&lt;&gt; 更为灵活，几乎和mutex保持着一致的成员函数~ 除吃之外，使用和lock_guard没有什么区别</p>
<ul>
<li>call_once<br>Sometimes multiple threads might not need some functionality that should get processed whenever the first thread needs it. A typical example is lazy initialization: The first time one of the threads needs something that has to get processed, you process it (but not before, because you want to save the time to process it if it is not needed).</li>
</ul>
<h4 id="5-条件变量-condition-variable"><a href="#5-条件变量-condition-variable" class="headerlink" title="5 条件变量 condition_variable"></a>5 条件变量 condition_variable</h4><p>有时候，一些线程需要等待其他线程执行的结果，因此你不得不因为一些其他原因不能够处理共享数据，而执行一些同步性的并行操作</p>
<p>future也可以处理这样的操作，一个线程等待另一个线程，但是只能处理一次，而实际上future的目的仅仅是为了返回值和异常</p>
<p>对于条件变量的实现，我们可以使用以下方式进行实现~</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> readyFlag;</span><br><span class="line"><span class="built_in">std</span>::mutex readyFlagMutex;</span><br><span class="line"><span class="comment">// wait until readyFlag is true:</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; ul(readyFlagMutex);</span><br><span class="line">    <span class="keyword">while</span> (!readyFlag) &#123;</span><br><span class="line">        ul.unlock();</span><br><span class="line">        <span class="built_in">std</span>::this_thread::yield(); <span class="comment">// hint to reschedule to the next thread</span></span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">100</span>));</span><br><span class="line">        ul.lock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// release lock</span></span><br></pre></td></tr></table></figure>
<p>我们完全可以使用以上的方式实现我们的目的，至于为什么不使用，以下给予了解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The waiting thread consumes valuable processing time repeatedly checking the flag</span><br><span class="line">and when it locks the mutex the thread setting the ready flag is blocked. ...</span><br><span class="line">In addition, it’s hard to get the sleep period right: too short a sleep in between checks</span><br><span class="line">and the thread still wastes processing time checking, too long a sleep</span><br><span class="line">and the thread will carry on sleeping even when the task it is waiting for is complete,</span><br><span class="line">introducing a delay</span><br></pre></td></tr></table></figure>
<p>因而c++给我们提供了条件变量使用，condition_variable 和 mutex 一起配合使用,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex queueMutex;</span><br><span class="line"><span class="built_in">std</span>::condition_variable queueCondVar;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">provider</span> <span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// push different values (val til val+5 with timeouts of val milliseconds into the queue</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lg(queueMutex);</span><br><span class="line">            <span class="built_in">queue</span>.push(val+i);</span><br><span class="line">        &#125; <span class="comment">// release lock</span></span><br><span class="line">        queueCondVar.notify_one();</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(val));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span> <span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// pop values if available (num identifies the consumer)</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; ul(queueMutex);</span><br><span class="line">        queueCondVar.wait(ul,[]&#123; <span class="keyword">return</span> !<span class="built_in">queue</span>.empty(); &#125;);</span><br><span class="line">        val = <span class="built_in">queue</span>.front();</span><br><span class="line">        <span class="built_in">queue</span>.pop();</span><br><span class="line">        &#125; <span class="comment">// release lock</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"consumer "</span> &lt;&lt; num &lt;&lt; <span class="string">": "</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// start three providers for values 100+, 300+, and 500+</span></span><br><span class="line">    <span class="keyword">auto</span> p1 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,provider,<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">auto</span> p2 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,provider,<span class="number">300</span>);</span><br><span class="line">    <span class="keyword">auto</span> p3 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,provider,<span class="number">500</span>);</span><br><span class="line">    <span class="comment">// start two consumers printing the values</span></span><br><span class="line">    <span class="keyword">auto</span> c1 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,consumer,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> c2 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,consumer,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-原子操作-atomic"><a href="#6-原子操作-atomic" class="headerlink" title="6 原子操作 atomic"></a>6 原子操作 atomic</h4><p>原子操作：意味着对于一个变量读取和写入都是原子的，与此同时通过atomic的成员函数来看，我们除了这些操作无法提供更为复杂的操作，比如对一个容器、结构体等共享变量做复杂的操作~</p>
<p>因而，原子操作更适用于基本数据类型~ int /bool /point</p>
<hr>
<p>Lock-Free - 无锁技术越来越被开发人员重视，因为锁对于性能的影响实在是太大了，所以如果想开发出一个高性能的程序，你就非常有必要学习 Lock-Free 的编程方式</p>
<p>菜鸟 正在飞翔<del>~</del><del>~</del>~~~</p>
<hr>
<h1 id="三-、异步"><a href="#三-、异步" class="headerlink" title="三 、异步"></a>三 、异步</h1><p>todo</p>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>


    
<nav id="article-nav">
    
        <a href="../../12/CPPTopologicOrder/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">上一篇</strong>
            <div class="article-nav-title">
                
                    拓扑排序
                
            </div>
        </a>
    
    
        <a href="../../04/cpp缓冲与流对象/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">下一篇</strong>
            <div class="article-nav-title">cpp缓冲与流对象</div>
        </a>
    
</nav>





    
    




<!-- baidu url auto push script -->
<script type="text/javascript">
    !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=window.location.href,o=document.referrer;if(!e.test(r)){var n="//api.share.baidu.com/s.gif";o?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var t=new Image;t.src=n}}(window);
</script>     
</section>
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            lwb &copy; 2019 
            <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png"></a>
            <br> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme - <a href="https://github.com/zthxxx/hexo-theme-Wikitten">wikitten</a>
            
        </div>
    </div>
</footer>

        

    
        <script src="../../../../libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="../../../../libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="../../../../libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="../../../../libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="../../../../libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="../../../../libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="../../../../libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="../../../../libs/lightgallery/js/lg-share.min.js"></script>
        <script src="../../../../libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="../../../../libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    
        <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true,
            TeX: {
                equationNumbers: {
                  autoNumber: 'AMS'
                }
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    



<!-- Custom Scripts -->
<script src="../../../../js/main.js"></script>

    </div>
</body>
</html>