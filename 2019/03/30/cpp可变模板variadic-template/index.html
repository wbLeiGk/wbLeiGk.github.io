<!DOCTYPE html>
<html lang="zh">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    
    <title>cpp可变模板variadic_template | QK</title>
    
    
        <meta name="keywords" content="cpp可变模板variadic_template">
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="英文原版：https://eli.thegreenplace.net/2014/variadic-templates-in-c/#id5 在 C++11 之前, 编写任意数量的参数的函数的唯一方法是使用不同的函数 (如 printf)、省略号语法 (…) 和伴随的 va _ 家族。如果你曾经用这种方法编写过代码, 你就知道它有多麻烦了。除了类型不安全 (所有类型解析都必须在运行时使用 va _ a">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp可变模板variadic_template">
<meta property="og:url" content="http://yoursite.com/2019/03/30/cpp可变模板variadic-template/index.html">
<meta property="og:site_name" content="QK">
<meta property="og:description" content="英文原版：https://eli.thegreenplace.net/2014/variadic-templates-in-c/#id5 在 C++11 之前, 编写任意数量的参数的函数的唯一方法是使用不同的函数 (如 printf)、省略号语法 (…) 和伴随的 va _ 家族。如果你曾经用这种方法编写过代码, 你就知道它有多麻烦了。除了类型不安全 (所有类型解析都必须在运行时使用 va _ a">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-03-30T14:50:26.453Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="cpp可变模板variadic_template">
<meta name="twitter:description" content="英文原版：https://eli.thegreenplace.net/2014/variadic-templates-in-c/#id5 在 C++11 之前, 编写任意数量的参数的函数的唯一方法是使用不同的函数 (如 printf)、省略号语法 (…) 和伴随的 va _ 家族。如果你曾经用这种方法编写过代码, 你就知道它有多麻烦了。除了类型不安全 (所有类型解析都必须在运行时使用 va _ a">
    

    

    
        <link rel="icon" href="../../../../favicon.ico">
    

    <link rel="stylesheet" href="../../../../libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="../../../../libs/open-sans/styles.css">
    <link rel="stylesheet" href="../../../../libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="../../../../css/style.css">
    <script src="../../../../libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="../../../../libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>
    
    
        <link rel="stylesheet" href="../../../../libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="../../../../libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


    
</head>
</html>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="../../../../index.html" id="logo">
                <i class="logo"></i>
                <span class="site-title">QK</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="../../../../index.html">首页</a>
                
                    <a class="main-nav-link" href="../../../../about">关于</a>
                
            </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索">
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '../../../../content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="../../../../js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="../../../../index.html">首页</a></td>
                
                    <td><a class="main-nav-link" href="../../../../about">关于</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索">
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap" id="categories">
        <h3 class="widget-title">
            <span>分类</span>
            &nbsp;
            <a id="allExpand" href="#">
                <i class="fa fa-angle-double-down fa-2x"></i>
            </a>
        </h3>
        
        
        
         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            工具
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="../../26/git简单使用/">git简单使用</a></li>  <li class="file"><a href="../../29/vscode-sshFS文件系统/">vscode_sshFS文件系统</a></li>  <li class="file"><a href="../../18/工具screen/">screen</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            生活杂记
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            一个人的独处
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="../../../02/16/一个人的独处1/">在路上</a></li>  <li class="file"><a href="../../../02/25/一个人的独处2/">我成为了那个自己讨厌的人了嘛</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            编程
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            cpp
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            DLL交互
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="../../../../2018/12/05/android-NDK/">android NDK</a></li>  <li class="file"><a href="../../25/c-加载cppdll/">c#加载cppdll</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            STL(类对象)
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="../../04/cpp缓冲与流对象/">cpp缓冲与流对象</a></li>  <li class="file"><a href="../../27/任务重新开始/">retry task in cpp &golang</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            boost库
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="../../../04/04/BOOST-ASIO库/">BOOST.ASIO库</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            元编程
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="../../26/cpp特化/">cpp SFINAE</a></li>  <li class="file active"><a href="">cpp可变模板variadic_template</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            多线程
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="../../05/cpp11线程/">cpp11线程概述</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            go
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            go web
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="../../../04/03/goGetURL简单开始/">goGetURL简单开始</a></li>  <li class="file"><a href="../../03/goWeb/">GoWeb <1></1></a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            基本知识
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="../../18/go接口小得/">接口interface心得（1）</a></li>  <li class="file"><a href="../../01/go数据类型/">数据类型</a></li>  <li class="file"><a href="../../../02/17/go概述/">概述</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            数据结构与算法
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="../../12/CPP拓扑排序/">拓扑排序</a></li>  <li class="file"><a href="../../../02/22/Go平衡树/">平衡树</a></li>  <li class="file"><a href="../../../../2018/12/10/求二叉树的路径和/">求二叉树的路径和(path sum)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            设计模式
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="../../27/单例模式/">单例模式</a></li>  <li class="file"><a href="../../18/设计模式/">设计模式</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            计算机网络
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="../../../../2018/11/15/TCP 传输机制/">TCP 传输机制</a></li>  <li class="file"><a href="../../../../2018/11/13/复路分解与多复路/">复路分解与多复路</a></li>  <li class="file"><a href="../../../../2018/12/09/路由器数据层/">路由器数据层</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            项目构建
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="../../28/Cmake/">Cmake 简单结构</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="../../02/个人博客简介/">个人博客简介</a></li>  </ul> 
    </div>
    <script>
        $(document).ready(function() {
            var iconFolderOpenClass  = 'fa-folder-open';
            var iconFolderCloseClass = 'fa-folder';
            var iconAllExpandClass = 'fa-angle-double-down';
            var iconAllPackClass = 'fa-angle-double-up';
            // Handle directory-tree expansion:
            // 左键单独展开目录
            $(document).on('click', '#categories a[data-role="directory"]', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var subtree = $(this).siblings('ul');
                icon.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if (expanded) {
                    if (typeof subtree != 'undefined') {
                        subtree.slideUp({ duration: 100 });
                    }
                    icon.addClass(iconFolderCloseClass);
                } else {
                    if (typeof subtree != 'undefined') {
                        subtree.slideDown({ duration: 100 });
                    }
                    icon.addClass(iconFolderOpenClass);
                }
            });
            // 右键展开下属所有目录
            $('#categories a[data-role="directory"]').bind("contextmenu", function(event){
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var listNode = $(this).siblings('ul');
                var subtrees = $.merge(listNode.find('li ul'), listNode);
                var icons = $.merge(listNode.find('.fa'), icon);
                icons.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if(expanded) {
                    subtrees.slideUp({ duration: 100 });
                    icons.addClass(iconFolderCloseClass);
                } else {
                    subtrees.slideDown({ duration: 100 });
                    icons.addClass(iconFolderOpenClass);
                }
            })
            // 展开关闭所有目录按钮
            $(document).on('click', '#allExpand', function (event) {
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconAllExpandClass);
                icon.removeClass(iconAllExpandClass).removeClass(iconAllPackClass);
                if(expanded) {
                    $('#sidebar .fa.fa-folder').removeClass('fa-folder').addClass('fa-folder-open')
                    $('#categories li ul').slideDown({ duration: 100 });
                    icon.addClass(iconAllPackClass);
                } else {
                    $('#sidebar .fa.fa-folder-open').removeClass('fa-folder-open').addClass('fa-folder')
                    $('#categories li ul').slideUp({ duration: 100 });
                    icon.addClass(iconAllExpandClass);
                }
            });  
        });
    </script>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
            <section id="main"><article id="post-cpp可变模板variadic-template" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="../../../../categories/编程/">编程</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="../../../../categories/编程/cpp/">cpp</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="../../../../categories/编程/cpp/元编程/">元编程</a>
    </div>

                        
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="">
            <time datetime="2019-03-30T03:51:39.000Z" itemprop="datePublished">2019-03-30</time>
        </a>
    </div>


                        
                        
                    </div>
                
                
    
        <h1 class="article-title" itemprop="name">
            cpp可变模板variadic_template
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <p>英文原版：<a href="https://eli.thegreenplace.net/2014/variadic-templates-in-c/#id5" target="_blank" rel="noopener">https://eli.thegreenplace.net/2014/variadic-templates-in-c/#id5</a></p>
<p>在 C++11 之前, 编写任意数量的参数的函数的唯一方法是使用不同的函数 (如 printf)、省略号语法 (…) 和伴随的 va _ 家族。如果你曾经用这种方法编写过代码, 你就知道它有多麻烦了。除了类型不安全 (所有类型解析都必须在运行时使用 va _ arg 中的强制转换显式完成) 之外, 正确的方法也很棘手。Va _ 宏执行低级内存操作, 我看到了很多代码, 这些代码会对故障进行分段, 因为它没有足够仔细地使用它们。</p>
<p>但是, 这种方法总是让我最困扰的是, 把一些在编译时清楚地知道的东西留给了运行时。是的, 当我们编写一个可变函数时, 我们不知道它将被使用的所有方式。但当编译器将整个程序放在一起时, 它确实知道。它非常清楚地看到了整个程序中函数的所有调用, 以及它所传递的所有可能的参数类型 (毕竟类型是在 C++ 中的编译时解析的)</p>
<h1 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h1><p>cpp11其中一个新特征就是可变参数模板，最终他以一种任意参数的类型安全形式并且在编译器处理所有参数逻辑解析来写函数，可变参数模板不仅仅运用在函数上，其他任意数量参数的模板上也行（类 etc）</p>
<p>#基本例子<br>让我们从实现一个可以加上所有参数的模板函数开始<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">addr</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T ,<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">T <span class="title">addr</span><span class="params">(T first, Args...args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> first + addr(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"int sum is :"</span> &lt;&lt; addr(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">7</span>) &lt;&lt; <span class="built_in">endl</span>;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> s1 = <span class="string">"x"</span>, s2 = <span class="string">"aa"</span>, s3 = <span class="string">"bb"</span>, s4 = <span class="string">"yy"</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"string sum is :"</span> &lt;&lt; addr(s1, s2, s3, s4) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>addr 将接受任意类型和参数数量的参数，只要参数类型能够执行‘+’操作，这种检查在编译期执行，这没什么魔法-仅仅是遵循了c++中的通用模板和重载方案规则</p>
<p>typename..Args 可称为 <strong><em>template parameter pack</em></strong> ，Args…args 是 <strong><em>function parameter pack</em></strong> (Args 也完全可以是任意其他名字) 可变模板的编写方式与编写递归代码的方式相似-你需要基函数（addr(T t) 上面的声明）和一个泛型的“递归” ，它用来递归自身，留意泛型定义的addr,第一个参数，template parameter pack 中的参数被放入参数first 总，因为每一次调用，参数包将变得减少一个参数</p>
<p>为了更加的直观的看到调用过程，我们在泛型函数addr()中插入std::cout&lt;&lt;<strong>PRETTY_FUNCTION</strong> &lt;&lt;std::endl; 语句 [It’s a gcc extension, supported by Clang as well,but msvc do’t work]</p>
<p>我们执行addr(1,2,3,8,7),将看到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T adder(T, Args...) [T = int, Args = &lt;int, int, int, int&gt;]</span><br><span class="line">T adder(T, Args...) [T = int, Args = &lt;int, int, int&gt;]</span><br><span class="line">T adder(T, Args...) [T = int, Args = &lt;int, int&gt;]</span><br><span class="line">T adder(T, Args...) [T = int, Args = &lt;int&gt;]</span><br><span class="line">T adder(T) [T = int]</span><br></pre></td></tr></table></figure></p>
<h1 id="一些简单变量"><a href="#一些简单变量" class="headerlink" title="一些简单变量"></a>一些简单变量</h1><p>当阅读c++模板元编程的时候，一个经常听到的词语是“模式匹配”，那么这部分语言如何构成相当完整的编译时函数语言</p>
<p>上诉的例子已经给我们展示了基本的使用-模板参数通过一个一个脱落展开的直到碰到基函数，下面将展示一个更有趣的模式配置例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> First ,<span class="keyword">typename</span> Second&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LWBcompare</span><span class="params">(First f, Second s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> f == s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Base, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LWBcompare</span><span class="params">(Base first, Base second, Args...args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> first == second &amp;&amp; compare(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LWBcompare<br> 接受任意数量的参数，并且返回bool，类型不是强制性的，一切都可以被比较，比如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LWBcompare(<span class="number">1.5</span>, <span class="number">1.5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure></p>
<p>返回true，但是当我们改变第二个参数的时候为1的时候，则会编译失败，因为doubl和int 不是同一类型</p>
<p>更有趣的是，LWBcompare仅仅执行在偶数参数的时候，因为他们参数解包的时候是成对的，因此奇数个参数的时候会导致编译失败，我们添加1个可变参数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LWBcompare</span><span class="params">(T a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们定义了所有的奇数个参数返回false，因为最终的解包的时候，只剩下一个参数，基函数只能配置这个函数。</p>
<p>需要留意的是，例子中LWBcompare 强制比较参加比较的类型需要是相同的类型，但是只要类型之间是课比较的，就能够调用此函数。</p>
<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>如果你担心依赖可变参数的代码执行性能，这是没有必要，实际上没有发生递归调用，所有的一系列函数都在编译期产生之后调用的，这些函数实际上相当短（一般可变参数不超过5-6个），因此编译器会内联产生的代码，它很可能最终被编译为完全没有函数调用的机器代码。实际上, 你最终得到的并不像循环展开</p>
<p>相比较c-style 可变参数函数，cpp 性能更好，因为c-style 可变参数模板必须在运行时解析，va_ 宏被逐字操作在运行栈，因此，可变参数模板对可变参数函数来说，通常来说是性能优化的</p>
<h1 id="类型安全的可变参数函数"><a href="#类型安全的可变参数函数" class="headerlink" title="类型安全的可变参数函数"></a>类型安全的可变参数函数</h1><p>在文章的开始提到了函数 printf 作为一个可变参数函数，没有使用模板，然而，我们知道printf 并不是一个类型安全的，printf同类型的函数也不是类型安全的，如哦你传递一个数字进入一个%s格式，糟糕的结果可能会发生，因为编译器并不会对你进行警告。</p>
<p>这是很明显的，可变参数模板使我们能够写出类型安全的函数，这printf 这个例子中，当实现到达新的格式指令时, 它实际上可以断言传递的参数的类型，这种断言不会在编译时触发, 但它会触发–并且可以生成一个很好的错误消息, 而不是未定义的行为</p>
<h1 id="可变参数数据结构"><a href="#可变参数数据结构" class="headerlink" title="可变参数数据结构"></a>可变参数数据结构</h1><p>传统数据结构[structs since the times of C and calsses in c++]在编译期定义了字段，它们可以表示在运行时增长的类型 (例如 std:: 向量), 但如果要添加新字段, 这是编译器必须看到的，可变参数模板使这种限制成为了可能，让数据结构可以有任意个字段，每次使用拥有初始化的的字段数量，一个很好的例子是tuple类，因此，下面将演示如何构造这个一个数据结构。</p>
<p>完整代码路径: <a href="https://github.com/eliben/code-for-blog/blob/master/2014/variadic-tuple.cpp" target="_blank" rel="noopener">variadic-tuple</a></p>
<p>首先让我们开始定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Ts</span>&gt; <span class="title">struct</span> <span class="title">tuple</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tuple</span>&lt;T, Ts...&gt; :</span> tuple&lt;Ts...&gt; &#123;</span><br><span class="line">  tuple(T t, Ts... ts) : tuple&lt;Ts...&gt;(ts...), tail(t) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  T tail;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们以基本情况-类模板tuple的定义,他是空的，特化则进行参数包的解包，并且定义了一个成员类型，用于接收这个类型，也用于接收剩下的类型，这个架构的基类是一个空tuple，为了得到了更好的理解，让我们举个具体的例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="keyword">double</span> ,<span class="keyword">uint64_t</span>,<span class="keyword">const</span> <span class="keyword">char</span>*&gt; t1(<span class="number">122</span>,<span class="number">42</span>,<span class="string">"big"</span>);</span><br></pre></td></tr></table></figure>
<p>先忽略构造函数，这有一个tuple的伪代码-过程 构造</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tuple</span>&lt;double, uint64_t, const char*&gt; :</span> tuple&lt;<span class="keyword">uint64_t</span>, <span class="keyword">const</span> <span class="keyword">char</span>*&gt; &#123;</span><br><span class="line">  <span class="keyword">double</span> tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tuple</span>&lt;uint64_t, const char*&gt; :</span> tuple&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; &#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tuple</span>&lt;const char*&gt; :</span> tuple &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tuple</span> &#123;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原始3元素元组中的数据成员的布局将是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">const</span> <span class="keyword">char</span>* tail, <span class="keyword">uint64_t</span> tail, <span class="keyword">double</span> tail]</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是：空基类没有占用任何空间，这取决 <a href="https://en.cppreference.com/w/cpp/language/ebo" target="_blank" rel="noopener">empty base optimization</a>。使用clang的<a href="https://eli.thegreenplace.net/2012/12/17/dumping-a-c-objects-memory-layout-with-clang/" target="_blank" rel="noopener">layout dump feature</a>,我们核验</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*** Dumping AST Record Layout</span><br><span class="line">   <span class="number">0</span> | <span class="class"><span class="keyword">struct</span> <span class="title">tuple</span>&lt;double, unsigned long, const char *&gt;</span></span><br><span class="line"><span class="class">   0 |   <span class="title">struct</span> <span class="title">tuple</span>&lt;unsigned long, const char *&gt; (<span class="title">base</span>)</span></span><br><span class="line"><span class="class">   0 |     <span class="title">struct</span> <span class="title">tuple</span>&lt;const char *&gt; (<span class="title">base</span>)</span></span><br><span class="line"><span class="class">   0 |       <span class="title">struct</span> <span class="title">tuple</span>&lt;&gt; (<span class="title">base</span>) (<span class="title">empty</span>)</span></span><br><span class="line"><span class="class">   0 |       <span class="title">const</span> <span class="title">char</span> * <span class="title">tail</span></span></span><br><span class="line"><span class="class">   8 |     <span class="title">unsigned</span> <span class="title">long</span> <span class="title">tail</span></span></span><br><span class="line"><span class="class">  16 |   <span class="title">double</span> <span class="title">tail</span></span></span><br><span class="line"><span class="class">     | [<span class="title">sizeof</span>=24, <span class="title">dsize</span>=24, <span class="title">align</span>=8</span></span><br><span class="line"><span class="class">     |  <span class="title">nvsize</span>=24, <span class="title">nvalign</span>=8]</span></span><br></pre></td></tr></table></figure>
<p>数据结构的的大小和结构是我们所期待的那样</p>
<p>so , 上面struct 定义让我们可以创建tuple，但是我还不能对此多出其他额外的操作，处理tuple使用get函数模板，让我们看他是怎么工作的，首先，我们定义一个帮助类型然我们处理第k个元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span>, <span class="class"><span class="keyword">class</span>&gt; <span class="title">struct</span> <span class="title">elem_type_holder</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Ts</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">elem_type_holder</span>&lt;0, tuple&lt;T, Ts...&gt;&gt; &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> k, <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Ts</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">elem_type_holder</span>&lt;k, tuple&lt;T, Ts...&gt;&gt; &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> elem_type_holder&lt;k - <span class="number">1</span>, tuple&lt;Ts...&gt;&gt;::type type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>elem_type_holder 也是另一个类模板，他拥有我么所感兴趣的数字K和类型tuple，这是编译期的模板元编程构造常量和类型，并不是运行期对象，举个例子elem_type_holder&lt;2,some_tuple_type&gt;,我们可以得到以下伪代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elem_type_holder</span>&lt;2, tuple&lt;T, Ts...&gt;&gt; &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> elem_type_holder&lt;<span class="number">1</span>, tuple&lt;Ts...&gt;&gt;::type type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elem_type_holder</span>&lt;1, tuple&lt;T, Ts...&gt;&gt; &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> elem_type_holder&lt;<span class="number">0</span>, tuple&lt;Ts...&gt;&gt;::type type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elem_type_holder</span>&lt;0, tuple&lt;T, Ts...&gt;&gt; &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>elem_type_holder&lt;2,some_tuple_type&gt; 剥落两个类型变量从tuple的开头，设置他的变量值到第三个type，这就是我们所需要的，通过与此协同，我们可以实现get</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> k, <span class="class"><span class="keyword">class</span>... <span class="title">Ts</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">std</span>:</span>:enable_if&lt;</span><br><span class="line">    k == <span class="number">0</span>, <span class="keyword">typename</span> elem_type_holder&lt;<span class="number">0</span>, tuple&lt;Ts...&gt;&gt;::type&amp;&gt;::type</span><br><span class="line">get(tuple&lt;Ts...&gt;&amp; t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t.tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> k, <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Ts</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">std</span>:</span>:enable_if&lt;</span><br><span class="line">    k != <span class="number">0</span>, <span class="keyword">typename</span> elem_type_holder&lt;k, tuple&lt;T, Ts...&gt;&gt;::type&amp;&gt;::type</span><br><span class="line">get(tuple&lt;T, Ts...&gt;&amp; t) &#123;</span><br><span class="line">  tuple&lt;Ts...&gt;&amp; base = t;</span><br><span class="line">  <span class="keyword">return</span> get&lt;k - <span class="number">1</span>&gt;(base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，<a href="https://en.cppreference.com/w/cpp/types/enable_if" target="_blank" rel="noopener">enbale_if</a> 被用来在两个模板函数之间进行选择，一个用来k==0,一个是泛型get k！=0 每次调用都剥落一个类型，而不去使用。</p>
<p>因为返回的是一个引用，我们可以利用get去读取和修改这个值<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="keyword">double</span>, <span class="keyword">uint64_t</span>, <span class="keyword">const</span> <span class="keyword">char</span>*&gt; t1(<span class="number">12.2</span>, <span class="number">42</span>, <span class="string">"big"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"0th elem is "</span> &lt;&lt; get&lt;<span class="number">0</span>&gt;(t1) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1th elem is "</span> &lt;&lt; get&lt;<span class="number">1</span>&gt;(t1) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2th elem is "</span> &lt;&lt; get&lt;<span class="number">2</span>&gt;(t1) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">get&lt;<span class="number">1</span>&gt;(t1) = <span class="number">103</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1th elem is "</span> &lt;&lt; get&lt;<span class="number">1</span>&gt;(t1) &lt;&lt; <span class="string">"\n"</span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="适用于catch-all函数的可变模板（又称为：template-template-parameter）"><a href="#适用于catch-all函数的可变模板（又称为：template-template-parameter）" class="headerlink" title="适用于catch-all函数的可变模板（又称为：template template parameter）"></a>适用于catch-all函数的可变模板（又称为：template template parameter）</h1><p>这里有另一个有趣的例子，它不同于我们上诉的例子，因为他并不是真正的使用传统的递归方式实现可变模板，相反他表达了一个“任何模板参数都可以到达这里”的概念。</p>
<p>也就是说，我们想要写一个函数可以显示出标准库容器，我们想要他工作在任何容器，并且我们也想要用户尽可能的写的小，所以我们不打算用迭代器，我仅仅想要print_container(c) 工作在任何容器上，这是第一种途径。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">ContainerType</span>,</span></span><br><span class="line"><span class="class">          <span class="title">typename</span> <span class="title">ValueType</span>,</span></span><br><span class="line"><span class="class">          <span class="title">typename</span> <span class="title">AllocType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print_container</span>(<span class="title">const</span> <span class="title">ContainerType</span>&lt;ValueType, AllocType&gt;&amp; <span class="title">c</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : c) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很多STL容器是可以传入参数value type and allocator type 的模板，举个例子，vector ,list, and so on , 所以我们可以这样写调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vd&#123;<span class="number">3.14</span>, <span class="number">8.1</span>, <span class="number">3.2</span>, <span class="number">1.0</span>&#125;;</span><br><span class="line">print_container(vd);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">print_container(li);</span><br></pre></td></tr></table></figure>
<p>并且这也是我们所期待的，但是当我们传入map的时候，我们将得到一个编译错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; msi&#123;&#123;<span class="string">"foo"</span>, <span class="number">42</span>&#125;, &#123;<span class="string">"bar"</span>, <span class="number">81</span>&#125;, &#123;<span class="string">"bazzo"</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">print_container(msi);</span><br><span class="line">^~~~~~~~~~~~~~~</span><br><span class="line">error: no matching function for call to 'print_container'</span><br><span class="line">note: candidate <span class="keyword">template</span> ignored: substitution failure :</span><br><span class="line">      <span class="keyword">template</span> <span class="keyword">template</span> argument has different <span class="keyword">template</span></span><br><span class="line">      parameters than its corresponding <span class="keyword">template</span> <span class="keyword">template</span> parameter</span><br></pre></td></tr></table></figure>
<p>这是因为map 模板有四个参数，而不是两个，相同的问题将出现在set身上，set 有三个模板参数，这是人很烦恼-当print_container函数的代码一样对于所有的容器？因为这些容器的签名是不一致的，我们可以写出不冗余的代码嘛？可变参数模板可以解决这个问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>...&gt; <span class="class"><span class="keyword">class</span> <span class="title">ContainerType</span>,</span></span><br><span class="line"><span class="class">          <span class="title">typename</span> <span class="title">ValueType</span>, <span class="title">typename</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print_container</span>(<span class="title">const</span> <span class="title">ContainerType</span>&lt;ValueType, Args...&gt;&amp; <span class="title">c</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : c) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们要说的是，ContainerType 是一个template template parameter 且参数类型是任意数量的，我们不关系多少数量，这个交给编译器去决定，这个函数版本将工作的map,set,unordered_map 和其他容器，有一个额外的支持函数需要做</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Implement &lt;&lt; for pairs: this is needed to print out mappings where range</span></span><br><span class="line"><span class="comment">// iteration goes over (key, value) pairs.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> <span class="built_in">std</span>::pair&lt;T, U&gt;&amp; p) &#123;</span><br><span class="line">  out &lt;&lt; <span class="string">"["</span> &lt;&lt; p.first &lt;&lt; <span class="string">", "</span> &lt;&lt; p.second &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="可变函数模板的转发"><a href="#可变函数模板的转发" class="headerlink" title="可变函数模板的转发"></a>可变函数模板的转发</h1><p>一些相关的例子中的模板本身并不会做太多，但是不得不转发他们的参数给一些其他的模板和函数，这个实现很有用因为c++在使用固有的可变参数构造时，从模板参数看构造函数，给一个泛型类型T ，调用T的构造函数，我可能需要传递任意类型的参数，不想函数类型指定他们参数在编译期，仅仅给了一个泛型类型T，我们不知道构造什么类型的参数T，类型T有多少参数需要传入</p>
<p>一个重要的例子就是std::make_unique 函数，可使用自从c++14,我们可以使用它用一下方式<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;FooType&gt; f = <span class="built_in">std</span>::make_unique&lt;FooType&gt;(<span class="number">1</span>, <span class="string">"str"</span>, <span class="number">2.13</span>);</span><br></pre></td></tr></table></figure></p>
<p> FooType 是个任意类型的并且可以被任意方式构造，make_unique 怎么知道他的构造签名呢，一种典型的实现</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;T&gt; make_unique(Args&amp;&amp;... args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- 
## 参考资料
> - []()
> - []() -->

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>


    
<nav id="article-nav">
    
        <a href="../../../04/03/goGetURL简单开始/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">上一篇</strong>
            <div class="article-nav-title">
                
                    goGetURL简单开始
                
            </div>
        </a>
    
    
        <a href="../../29/vscode-sshFS文件系统/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">下一篇</strong>
            <div class="article-nav-title">vscode_sshFS文件系统</div>
        </a>
    
</nav>





    
    




<!-- baidu url auto push script -->
<script type="text/javascript">
    !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=window.location.href,o=document.referrer;if(!e.test(r)){var n="//api.share.baidu.com/s.gif";o?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var t=new Image;t.src=n}}(window);
</script>     
</section>
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            lwb &copy; 2019 
            <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png"></a>
            <br> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme - <a href="https://github.com/zthxxx/hexo-theme-Wikitten">wikitten</a>
            
        </div>
    </div>
</footer>

        

    
        <script src="../../../../libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="../../../../libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="../../../../libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="../../../../libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="../../../../libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="../../../../libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="../../../../libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="../../../../libs/lightgallery/js/lg-share.min.js"></script>
        <script src="../../../../libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="../../../../libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    
        <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true,
            TeX: {
                equationNumbers: {
                  autoNumber: 'AMS'
                }
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    



<!-- Custom Scripts -->
<script src="../../../../js/main.js"></script>

    </div>
</body>
</html>