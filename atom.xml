<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>QK</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-25T14:33:51.386Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>lwb</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>goTree</title>
    <link href="http://yoursite.com/2019/02/22/GoTree/"/>
    <id>http://yoursite.com/2019/02/22/GoTree/</id>
    <published>2019-02-22T01:26:00.000Z</published>
    <updated>2019-02-25T14:33:51.386Z</updated>
    
    <content type="html"><![CDATA[<p>本篇使用go语言实现二叉树</p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>二叉树的创建与c/c++创建并无多大的异处。其关键之处还是在于掌握好一级指针和二级指针的使用，go语言同样支持这两种指针</p><p>本次使用的数据结构一切从简，不适用sentinel模式<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="keyword">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">createTree</span><span class="params">(tree **TreeNode, val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">       Treetmp := &amp;TreeNode&#123;val, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">       <span class="keyword">if</span> <span class="literal">nil</span> == *tree &#123;</span><br><span class="line">           *tree = Treetmp</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> val &gt; (*tree).Val &#123;</span><br><span class="line">           createTree(&amp;(*tree).Right, val)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           createTree(&amp;(*tree).Left, val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里你可能好奇 Treetmp 地址离开了作用域利用消失，此值无效，关于这个答案，我在《The Go Programming Language》</p><ul><li><p>It is perfectly safe for a function to return the address of a local variable</p></li><li><p>…</p></li><li><p>Because the lifetime of a variable is determined only by whether or not it is reachable, a local<br>variable may outlive a single iteration of the enclosing loop. It may continue to exist even after<br>its enclosing function has returned.</p></li></ul><p>因而 ，这也是优化点</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(tree *TreeNode)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">nil</span> != tree &#123;</span><br><span class="line">        fmt.Println(tree.Val)</span><br><span class="line">        <span class="built_in">print</span>(tree.Left)</span><br><span class="line">        <span class="built_in">print</span>(tree.Right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="avl-平衡"><a href="#avl-平衡" class="headerlink" title="avl 平衡"></a>avl 平衡</h1><p>二叉树失衡有四种模式，LL 、LR、RR、RL</p><p>以下实现了两种方式avl:</p><p>基本函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LLTree</span><span class="params">(root **TreeNode)</span></span> &#123;</span><br><span class="line">    newRoot := (*root).Left</span><br><span class="line">    oldRight := newRoot.Right</span><br><span class="line"></span><br><span class="line">    newRoot.Right = *root</span><br><span class="line">    (*root).Left = oldRight</span><br><span class="line">    (*root) = newRoot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RRTree</span><span class="params">(root **TreeNode)</span></span> &#123;</span><br><span class="line">    newRoot := (*root).Right</span><br><span class="line">    oldLeft := newRoot.Left <span class="comment">//old root will get left node</span></span><br><span class="line"></span><br><span class="line">    newRoot.Left = *root</span><br><span class="line">    (*root).Right = oldLeft</span><br><span class="line">    (*root) = newRoot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LRTree</span><span class="params">(root **TreeNode)</span></span> &#123;</span><br><span class="line">    RRTree(&amp;(*root).Left)</span><br><span class="line">    LLTree(root)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RLTree</span><span class="params">(root **TreeNode)</span></span> &#123;</span><br><span class="line">    LLTree(&amp;(*root).Right)</span><br><span class="line">    RRTree(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>获取树的深度：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMaxDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">nil</span> == root &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    leftDepth := getMaxDepth(root.Left) + <span class="number">1</span></span><br><span class="line">    RightDepth := getMaxDepth(root.Right) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> leftDepth &gt; RightDepth &#123;</span><br><span class="line">        <span class="keyword">return</span> leftDepth</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">return</span> RightDepth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>将一颗失衡的数，进行平衡</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B2Tree</span><span class="params">(root **TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">nil</span> == *root &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    leftDepth := B2Tree(&amp;(*root).Left) + <span class="number">1</span></span><br><span class="line">    RightDepth := B2Tree(&amp;(*root).Right) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> leftDepth-RightDepth &gt;= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="comment">//LX</span></span><br><span class="line">        <span class="keyword">if</span> B2Tree(&amp;(*root).Left) &gt; B2Tree(&amp;(*root).Right) &#123;</span><br><span class="line">            <span class="comment">//LL</span></span><br><span class="line">            LLTree(root)</span><br><span class="line">            <span class="keyword">return</span> getMaxDepth(*root)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//LR</span></span><br><span class="line">            LRTree(root)</span><br><span class="line">            <span class="keyword">return</span> getMaxDepth(*root)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> RightDepth-leftDepth &gt;= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="comment">//RX</span></span><br><span class="line">        <span class="keyword">if</span> B2Tree(&amp;(*root).Left) &gt; B2Tree(&amp;(*root).Right) &#123;</span><br><span class="line">            <span class="comment">//RL</span></span><br><span class="line">            RLTree(root)</span><br><span class="line">            <span class="keyword">return</span> getMaxDepth(*root)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//RR</span></span><br><span class="line">            RRTree(root)</span><br><span class="line">            <span class="keyword">return</span> getMaxDepth(*root)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> leftDepth &gt; RightDepth &#123;</span><br><span class="line">            <span class="keyword">return</span> leftDepth</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RightDepth</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>边插入边平衡</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createTreeBT</span><span class="params">(tree **TreeNode, val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    Treetmp := &amp;TreeNode&#123;val, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">nil</span> == *tree &#123;</span><br><span class="line">        *tree = Treetmp</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> val &gt; (*tree).Val &#123;</span><br><span class="line">        createTree(&amp;(*tree).Right, val)</span><br><span class="line">        <span class="keyword">if</span> getMaxDepth((*tree).Right)-getMaxDepth((*tree).Left) &gt;= <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> val &gt; (*tree).Right.Val &#123;</span><br><span class="line">                <span class="comment">//RR</span></span><br><span class="line">                RRTree(tree)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//RL</span></span><br><span class="line">                RLTree(tree)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createTree(&amp;(*tree).Left, val)</span><br><span class="line">        <span class="keyword">if</span> getMaxDepth((*tree).Left)-getMaxDepth((*tree).Right) &gt; <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> val &gt; (*tree).Left.Val &#123;</span><br><span class="line">                <span class="comment">//LR</span></span><br><span class="line">                LRTree(tree)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//LL</span></span><br><span class="line">                LLTree(tree)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇使用go语言实现二叉树&lt;/p&gt;
&lt;h1 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h1&gt;&lt;h2 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="go" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/"/>
    
    
  </entry>
  
  <entry>
    <title>(2) go并发概述 1</title>
    <link href="http://yoursite.com/2019/02/17/goGoroutine/"/>
    <id>http://yoursite.com/2019/02/17/goGoroutine/</id>
    <published>2019-02-17T14:24:47.000Z</published>
    <updated>2019-02-19T11:58:33.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发关键字go"><a href="#并发关键字go" class="headerlink" title="并发关键字go"></a>并发关键字go</h2><p>  GoLang 使用go 关键字进行多并发操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example 1</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//example 2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> hello()</span><br></pre></td></tr></table></figure><h2 id="同步操作-channel"><a href="#同步操作-channel" class="headerlink" title="同步操作: channel"></a>同步操作: channel</h2><p>GoLang 使用Channels 进行多个协程之间进行同步操纵，它更像是一个管道，发送值到管道，再从值取回来</p><h2 id="等待channel-操作-select"><a href="#等待channel-操作-select" class="headerlink" title="等待channel 操作 : select"></a>等待channel 操作 : select</h2><p>go 与 channel 结合select 是一个强大的工作<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">  c1 &lt;- <span class="string">"hello"</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">  c2 &lt;- <span class="string">"world"</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> index := <span class="number">0</span>; index &lt; <span class="number">2</span>; index++ &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> msg1 := &lt;-c1:</span><br><span class="line">    fmt.Println(<span class="string">"the msg1 value is : "</span>, msg1)</span><br><span class="line">  <span class="keyword">case</span> msg2 := &lt;-c2:</span><br><span class="line">    fmt.Println(<span class="string">"the msg2 value is : "</span>, msg2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="timeer"><a href="#timeer" class="headerlink" title="timeer"></a>timeer</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只执行指定时间 一次</span></span><br><span class="line">mytime:=time.NewTimer(time.second)</span><br><span class="line">&lt;-mytime.C</span><br><span class="line">mytime.stop()</span><br></pre></td></tr></table></figure><h3 id="ticker"><a href="#ticker" class="headerlink" title="ticker"></a>ticker</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myticker:=time.NewTicker(time.second)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  &lt;-myticker.C</span><br><span class="line">  fmt.Println(time.now())</span><br><span class="line">&#125;</span><br><span class="line">myticker.stop()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;并发关键字go&quot;&gt;&lt;a href=&quot;#并发关键字go&quot; class=&quot;headerlink&quot; title=&quot;并发关键字go&quot;&gt;&lt;/a&gt;并发关键字go&lt;/h2&gt;&lt;p&gt;  GoLang 使用go 关键字进行多并发操作&lt;/p&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="go" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/"/>
    
    
  </entry>
  
  <entry>
    <title>(1) go初识</title>
    <link href="http://yoursite.com/2019/02/17/gonovice/"/>
    <id>http://yoursite.com/2019/02/17/gonovice/</id>
    <published>2019-02-17T04:03:45.000Z</published>
    <updated>2019-02-17T14:28:28.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h3> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name nametype</span><br><span class="line"><span class="comment">// for example </span></span><br><span class="line"><span class="keyword">var</span> myvar <span class="keyword">int</span> /<span class="keyword">float32</span> /<span class="keyword">string</span> /<span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> myvar = <span class="number">12</span> /<span class="number">12.2</span>/<span class="literal">true</span>/<span class="string">"hello"</span> <span class="comment">//infer the var type</span></span><br><span class="line">myvar := <span class="number">12</span> /<span class="number">12.2</span>/<span class="literal">true</span>/<span class="string">"hello"</span> <span class="comment">//must use : operator characteristic</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//pointer</span></span><br><span class="line"><span class="keyword">var</span> name *nametype</span><br><span class="line"></span><br><span class="line"><span class="comment">//切片和数组类似，不过切片比数组支持更多的操作</span></span><br><span class="line"><span class="comment">//你可以将其理解为数量不等的集合</span></span><br><span class="line"><span class="comment">//申请0个空间是一种位置，随后使用的时候，可以在进行申请空间</span></span><br><span class="line"><span class="comment">//相对而言，slice更加方便一些</span></span><br><span class="line"><span class="comment">//array</span></span><br><span class="line"><span class="keyword">var</span> arrayname [][]<span class="keyword">int</span> /<span class="keyword">float32</span>/<span class="keyword">string</span> /<span class="keyword">bool</span></span><br><span class="line"><span class="comment">//slices</span></span><br><span class="line">silces:=<span class="built_in">make</span>(<span class="keyword">type</span>,length)</span><br><span class="line"><span class="comment">//map dictionary</span></span><br><span class="line">mapName:=<span class="built_in">make</span>(<span class="keyword">map</span>[key-<span class="keyword">type</span>]value-<span class="keyword">type</span>)</span><br></pre></td></tr></table></figure><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><p>控制结构只有三种形式：</p><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> [[initialize][;condition;][caculate]]&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if-条件"><a href="#if-条件" class="headerlink" title="if 条件"></a>if 条件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [initialize ;][condition]&#123;</span><br><span class="line"></span><br><span class="line">&#125;[<span class="keyword">else</span> <span class="keyword">if</span>&#123;&#125;][<span class="keyword">else</span>&#123;&#125;]</span><br></pre></td></tr></table></figure><h3 id="switch-条件"><a href="#switch-条件" class="headerlink" title="switch 条件"></a>switch 条件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> [condition] &#123;</span><br><span class="line">    <span class="keyword">case</span> [result[condition]]:</span><br><span class="line">        [<span class="keyword">break</span>]</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        [<span class="keyword">break</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>通过for 循环语句是使用关键字range 遍历数组/切片/map<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> [key/index[_]] ,value :=<span class="keyword">range</span> mapvar&#123;</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">    <span class="comment">//execute some statement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数声明形式<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> [<span class="title">funName</span>]<span class="params">()</span> <span class="title">return</span>-<span class="title">type</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据函数形式大致为了以下几种：</p><h3 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plus</span><span class="params">(a,b <span class="keyword">int</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可变参数函数"><a href="#可变参数函数" class="headerlink" title="可变参数函数"></a>可变参数函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//example</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums ...<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Print(nums, <span class="string">" "</span>)</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        total += num</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(total)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example </span></span><br><span class="line">fmt.Println(<span class="string">"the return value is : "</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="number">4</span> &#125;())</span><br></pre></td></tr></table></figure><h3 id="闭包函数"><a href="#闭包函数" class="headerlink" title="闭包函数"></a>闭包函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initSqu</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span><span class="title">int</span></span> &#123;</span><br><span class="line">    i:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span><span class="title">int</span></span>&#123;</span><br><span class="line">        i++</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//to use </span></span><br><span class="line">nextInit:=initSqu()</span><br><span class="line">nextInit() <span class="comment">//1</span></span><br><span class="line">nextInit() <span class="comment">//2</span></span><br><span class="line"><span class="comment">//because they hava function address</span></span><br></pre></td></tr></table></figure><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//recusion</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factorial</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span>==n &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n*factorial(n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//to use</span></span><br><span class="line">fmt.<span class="built_in">println</span>(<span class="string">"the factorial value is : "</span>,factorial(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><h2 id="结构体与方法-接口"><a href="#结构体与方法-接口" class="headerlink" title="结构体与方法/接口"></a>结构体与方法/接口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">type</span> geometry <span class="keyword">interface</span> &#123;</span><br><span class="line">    area() <span class="keyword">float64</span></span><br><span class="line">    perimeter() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//example </span></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="keyword">type</span> rect <span class="keyword">struct</span>&#123;</span><br><span class="line">    width,height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> circle stuct&#123;</span><br><span class="line">    radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r.width*r.hight</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">perimeter</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r.width*<span class="number">2</span> + r.hight*<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span> <span class="title">area</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> math.Pi * c.radius * c.radius</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span> <span class="title">perimeter</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * math.Pi * c.radius</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//to use </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">measure</span><span class="params">(g geometry)</span></span>&#123;</span><br><span class="line">    fmt.Println(g.area())</span><br><span class="line">    fmt.Println(g.perimeter())</span><br><span class="line">&#125;</span><br><span class="line">rcValue:=rect&#123;<span class="number">12</span>,<span class="number">2</span>&#125;</span><br><span class="line">measure(rcValue)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h2&gt;&lt;h3 id=&quot;变量-1&quot;&gt;&lt;a href=&quot;#变量-1&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h3&gt; &lt;
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="go" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/"/>
    
    
  </entry>
  
  <entry>
    <title>生活小记</title>
    <link href="http://yoursite.com/2019/02/16/myselfprinciple/"/>
    <id>http://yoursite.com/2019/02/16/myselfprinciple/</id>
    <published>2019-02-16T00:38:45.000Z</published>
    <updated>2019-02-17T03:04:00.894Z</updated>
    
    <content type="html"><![CDATA[<p>2019 / 2 / 16  乌鲁木齐机场</p><p>打开电脑随手写下了这篇文章，就想到哪写到哪了</p><hr><p>[ 02 / 16 上午]</p><p>与昨日，我与母亲倾诉了内心的想法：我到底改往何方</p><p>母亲回了我一句：去年我曾劝过你，留在事业单位，现在你后悔嘛</p><p>我愣了一下</p><hr><p>[ 02 / 15 下午]</p><p>在乌市出发前碰到了我儿时的同学 【张】</p><p>于是开玩笑道：给我5元钱，我帮你承担 [考研] 成绩的压力</p><p>晚上，我们在一起吃了个饭，我问他想去哪</p><p>他话语间流露，想要出去走走，不想呆在新疆了，他说这个地方他呆够了，现在他特别想到处逛逛</p><p>“你准备在成家？”</p><p>他说：“在江苏吧，也许其他地方…”</p><p>晚上的《流浪地球》挺好看的</p><hr><p>晚上，继昨天一样，失眠了</p><p>我已经不记得儿时曾经发过什么誓言，想要成为什么样的人</p><p>我也不知道我是不是成为了自己讨厌的人</p><p>. . .</p><hr><p>今年我26 ，而我的路，我不知道该向哪里</p><p>甚至看书，有时候都在发呆</p><p>我不知道您是否被这么一句话所影响 :  走正确的路</p><p>什么是正确的路啊</p><p>蒙上眼睛，走那个方向都是前方</p><p>. . .</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2019 / 2 / 16  乌鲁木齐机场&lt;/p&gt;
&lt;p&gt;打开电脑随手写下了这篇文章，就想到哪写到哪了&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[ 02 / 16 上午]&lt;/p&gt;
&lt;p&gt;与昨日，我与母亲倾诉了内心的想法：我到底改往何方&lt;/p&gt;
&lt;p&gt;母亲回了我一句：去年我曾劝过你，留在事业
      
    
    </summary>
    
      <category term="个人生活" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>基于权重的任务调度</title>
    <link href="http://yoursite.com/2018/12/10/task-shchedule-weight/"/>
    <id>http://yoursite.com/2018/12/10/task-shchedule-weight/</id>
    <published>2018-12-10T06:36:12.000Z</published>
    <updated>2019-02-17T03:11:31.319Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>路由器数据层</title>
    <link href="http://yoursite.com/2018/12/09/router-data-plane/"/>
    <id>http://yoursite.com/2018/12/09/router-data-plane/</id>
    <published>2018-12-09T09:10:21.000Z</published>
    <updated>2019-02-17T03:11:47.580Z</updated>
    
    <content type="html"><![CDATA[<p>网络层有两个关键的功能</p><ul><li><p><strong>转发</strong></p><p>当一个数据包到达输入端口时，router 移动数据包到合适的输出端口</p></li><li><p><strong>路由</strong></p><p>在整个网络中，局域网/广域网等 数据包从源地址到目的路之间的传输路径，而路径的选择时路由，一般路由可能时路由算法控制，或者手动设置</p></li></ul><p>本篇重点放在路由器转发上面</p><h2 id="router-component"><a href="#router-component" class="headerlink" title="router component"></a>router component</h2><ul><li><p><strong>input   ports</strong></p><p> 执行物理层/链路层功能，同时还会执行检索功能对输入的数据进行检索，然后输出到合适的 output ports</p></li><li><p><strong>output  ports</strong></p><p>存储从switch fabric 处过来的数据包，然后转发这些这些数据包到出口[outgoing link：链接到链路层和物理层]</p></li><li><p><strong>switch  fabric</strong></p><p>  连接 input port 和output port</p></li><li><p>routing processor</p><p>执行control-plane 功能，一般用于路由协议</p></li></ul><h2 id="forward-based-information"><a href="#forward-based-information" class="headerlink" title="forward based information"></a>forward based information</h2><p>一般来说，转发大致基于两种情况</p><ul><li><p><strong>基于目的IP</strong></p><p>  此种方式根据数据包目的IP，然后对照路由表，选择合适的输出端口</p></li><li><p><strong>基于全部信息</strong></p><p>  相对的，此种方式就不仅仅依据目的IP了，与此同时参考的信息还会有：源目的、网络拥塞状态等</p></li></ul><h2 id="switch-fabric"><a href="#switch-fabric" class="headerlink" title="switch fabric"></a>switch fabric</h2><p>switch fabric是路由器的核心，数据包从input port 穿过switch fabric 然后到 output port ，switch fabric 有一下几种实现方式</p><ul><li><p>switching via memory</p><p>  传统的router实现方式，数据包从input port 到达之后，通过中断的方式通知 router processor，然后共享内存复制数据包到合适的output ports buffers</p></li><li><p>switching via bus</p><p>  input port 直接通过bus 传输数据包到output port,由于bus只有一条，因此不能同时传输数据，转发速度受制于bus的转发速度</p></li><li><p>switching via an interconnection network</p><p>  interconnection network 使用cross-bar 的方式，这就意味着N-N的转发方式</p></li></ul><h2 id="queue-delay"><a href="#queue-delay" class="headerlink" title="queue  delay"></a>queue  delay</h2><p>无论是input port 还是output port 都会发生queue delay ,也就是wait的意思</p><ul><li><p>input port queue</p><p> 当switch fabric 处理速度赶不上 input port 速度的时候</p></li><li><p>output port queue</p><p>多个数据包被转发到相同的output ports，当output ports buffer 满了的时候，就会发生packet drop 事件</p></li></ul><h2 id="outgoing-link-packet-schedule"><a href="#outgoing-link-packet-schedule" class="headerlink" title="outgoing link packet schedule"></a>outgoing link packet schedule</h2><ul><li><p>FIFO</p><p>最先进入queue的数据包最新被转发出去</p></li><li><p>priority</p><p>根据优先级/权重对数据包进行分类[class i]，然后循环遍历classes,输出queue 中的数据包</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网络层有两个关键的功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;转发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当一个数据包到达输入端口时，router 移动数据包到合适的输出端口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;路由&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在整个
      
    
    </summary>
    
      <category term="network" scheme="http://yoursite.com/categories/network/"/>
    
    
      <category term="network" scheme="http://yoursite.com/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>android NDK</title>
    <link href="http://yoursite.com/2018/12/05/android-NDK/"/>
    <id>http://yoursite.com/2018/12/05/android-NDK/</id>
    <published>2018-12-05T08:59:50.000Z</published>
    <updated>2019-02-17T03:57:51.857Z</updated>
    
    <content type="html"><![CDATA[<p>最近维护了公司的一个JNI项目，面向java/android平台使用，有幸接触了Java/Android 平台与c/c++ 的交互使用。</p><ul><li>Java 与 c/c++ 交互使用 dll 形式</li><li>Android 与c/C++ 交互使用.so文件格式</li></ul><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p><a href="https://baike.baidu.com/item/JNI/9412164?fr=aladdin" target="_blank">JNI 基础概念</a></p><p><a href="https://www3.ntu.edu.sg/home/ehchua/programming/java/JavaNativeInterface.html" target="_blank">JNI 编程基础</a></p><p><a href="https://developer.android.com/ndk/guides/android_mk?hl=zh-cn" target="_blank">android.mk 编写</a></p><p>假使我认为您已经能够使用c/c++ 编程，基本能够使用android studio的使用，不使用亦可以</p><h2 id="Java-使用dll"><a href="#Java-使用dll" class="headerlink" title="Java 使用dll"></a>Java 使用dll</h2><h3 id="c语言头文件生成"><a href="#c语言头文件生成" class="headerlink" title="c语言头文件生成"></a>c语言头文件生成</h3><ul><li>使用javac javaName.java 生成.class 文件</li><li>使用javah javaName 生成 .h 头文件</li></ul><p><strong>note:</strong> 倘如您的java中有包名，那么退回到包名的根目录，使用以下形式的命令</p><ul><li>javac com\application\javaName.java  生成.class 文件</li><li>avah com.application.javaName 生成 .h 头文件</li></ul><p>如下图<br><img src="java_h.png" alt=""></p><p>本实验的代码：</p><ul><li><p>jni_md.h /jni.h 文件在安装的JDK进行提供</p></li><li><p>MainJava.java</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainJava</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"MainJava"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">printTest</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> MainJava().printTest());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MainJava.h</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"jni.h"</span></span></span><br><span class="line"><span class="comment">/* Header for class MainJava */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_MainJava</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_MainJava</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Class:     MainJava</span></span><br><span class="line"><span class="comment">* Method:    printTest</span></span><br><span class="line"><span class="comment">* Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_MainJava_printTest</span><br><span class="line">(JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li>MainJava.c</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"MainJava.h"</span></span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_MainJava_printTest</span><br><span class="line">  (JNIEnv *env, jobject thisobj)&#123;</span><br><span class="line">      <span class="keyword">return</span> (*env)-&gt;NewStringUTF(env,<span class="string">"this is c level"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>makefile</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">RESULT=MainJava.dll</span><br><span class="line">CFLAG= -Wall -shared</span><br><span class="line">source=*.c</span><br><span class="line"></span><br><span class="line"><span class="variable">$(RESULT)</span>:<span class="variable">$(source)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAG)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    del <span class="variable">$(RESULT)</span></span><br></pre></td></tr></table></figure><h2 id="Android使用-so-文件"><a href="#Android使用-so-文件" class="headerlink" title="Android使用 .so 文件"></a>Android使用 .so 文件</h2><p>生成 .so文件可以使用android studio中的内置的NDK-build ，也可以选择手动生成，我这里使用手动生成。<a href="https://developer.android.google.cn/ndk/downloads/" target="_blank">NDK-build下载</a></p><ul><li>需要将javac/javah 生成的 .h /.c /android.mk application.mk 文件放入jni 文件夹中，然后在此目录中运行ndk-build 命令</li></ul><p>如下图<br><img src="android_h.png" alt=""></p><ul><li>将生成的libs 拷贝到android 项目中的app/libs下面</li><li>在app/build.gradle中加入</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.....</span><br><span class="line">sourceSets&#123;</span><br><span class="line">    main&#123;</span><br><span class="line">        jniLibs.srcDirs=[<span class="string">'libs'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下<br><img src="android_so.png" alt=""></p><h2 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h2><p>对于一些使用底层代码使用c/c++的程序，常常使用这种方式，移植到其他平台上，android/java 作为业务层呈现</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近维护了公司的一个JNI项目，面向java/android平台使用，有幸接触了Java/Android 平台与c/c++ 的交互使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java 与 c/c++ 交互使用 dll 形式&lt;/li&gt;
&lt;li&gt;Android 与c/C++ 交互使用.s
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="android" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/android/"/>
    
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>TCP 传输机制</title>
    <link href="http://yoursite.com/2018/11/15/TCP-transport-institution/"/>
    <id>http://yoursite.com/2018/11/15/TCP-transport-institution/</id>
    <published>2018-11-15T00:40:55.000Z</published>
    <updated>2018-12-09T09:10:41.007Z</updated>
    
    <content type="html"><![CDATA[<p>说起TCP，第一印象是什么，嗯，可靠，面向连接。面向连接是每一个连接都是独立的。而对于可靠性，我的理解逻辑则按照下面的流程</p><p><img src="dataflow.png" alt=""></p><h2 id="TCP-流控制"><a href="#TCP-流控制" class="headerlink" title="TCP 流控制"></a>TCP 流控制</h2><p>流控制涉及到了TCP中windows size fidld,对于TCP而言，在每一个TCP成功建立的连接都会初始化两个缓冲区，发送缓冲区和接收缓冲区，window size 的字段就是为了防止缓冲区数据溢出从而做出了设置，对于接收者，我们假设有两个变量</p><ul><li>LastByteRead：从缓冲区最后读取的位置</li><li>LastByteRcvd：从缓冲区最后接收数据的位置</li><li>RcvBuffer：缓冲区的大小<br><em>LastByteRcvd-LastByteRead&lt;=RcvBuffer</em></li></ul><p>因而，我们要将通常将window size 设置成 cwnd = RcvBuffer-LastByteRcvd-LastByteRead，从而保证接收缓冲区不被溢出。相应的发送缓冲区 LastByteSent−LastByteAcked≤ cwnd</p><p>运用这一规则，在网络攻击中将windows size的值设置为1，就构成了http slow 攻击。</p><h2 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h2><p>首先大部分TCP拥塞控制时端对端的。相对应的有一个<a href="#网络协助方式">网络协助方式</a>（network-assist）</p><p>如果说流控制是控制避免TCP 缓冲区溢出，那么congestion control 就是在网络状态不好时，对TCP 发送流量进行控制，从而避免大量数据包丢失。</p><p>拥塞控制在TCP数据段中没有相应字段表示，但是还有有一个字段与他相关，那是ACK这个字段，拥塞能控制会根据接收到的ACK情况从而调整他的发送速率。</p><p>在TCP 发送数据过程中有三个阶段：<br><img src="congestion.png" alt="">此图来自《computer networking top to down》</p><p>从上图的状态图可以看到：</p><ul><li>在slow start:一旦正确接收到ack,那么cwnd增长时指数级别的，一旦发生数据超时，拥塞控制状态中，此时cwnd数值除以2。或者接收到3此重复的ACK（超时之前），进入快速重传阶段。</li><li>拥塞控制：在这个阶段，cwnd数据增长就比较慢了，由于各个平台实现TCP差异，但是总的原则不会变，他增长速率，同样的在这个状态下，一旦发送超时，或者ACK重复的情况，依旧会Cwnd 数值减半</li><li>快速恢复：这个状态不是必要存在的，进入此状态的条件时ACK 重复，此状态结束之后，一般会进入拥塞控制阶段</li></ul><h2 id="TCP-流量竞争"><a href="#TCP-流量竞争" class="headerlink" title="TCP 流量竞争"></a>TCP 流量竞争</h2><p> 一般来说，理想情况下，TCP连接时会平分网络节点的吞吐量的，但是由于每个TCP通过的路径的可能会有所差异，导致的网络状态的波动之类的情况，导致拥塞控制，可能会造成TCP流量的不平均的情况，因而，每个应用程序中TCP的连接数量的不同也会竞争流量，从而导致应用程序得到节点吞吐量不一样。</p><p> 当然UDP 可能就不会出现这种情况，因为不存在拥塞控制这一机制，收到就接收，收不到就收不到。</p><h2 id="网络协助方式"><a href="#网络协助方式" class="headerlink" title="网络协助方式"></a>网络协助方式</h2><p>此种方式时应用网络数据包丢失之类从而造成的拥塞控制对发送者进行一种反馈情况。</p><p>简单来说，TCP end-to-end 拥塞控制的形式，是根据ACK的情况进行判断网络状态，没有任何网络层参与，但是现在网络协助这种方式，是网络层根据网络状态直接将状态信息发送给接收端或者发送端的一种行为。</p><ul><li>网络层反馈给发送者：将网络状态直接发送给发送端</li><li>网络层发聩给接收者，由接收者发送给发送者： 接收端收到网络状态信息后，将此信息与ACK一起发送给发送端</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，TCP一直在处于发展中，目前而言也有类似其他的协议如DCCP(datagram congestion control Protocol)、DCTCP(data center TCP)、QUIC(quick udp internet connection,google 使用)、TFRC(TCP-friendly rate control,传输速率更平稳)、STTP….无论哪一种使用，哪一种更好，不仅仅取决其技术性，也取决社会行，商业性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;说起TCP，第一印象是什么，嗯，可靠，面向连接。面向连接是每一个连接都是独立的。而对于可靠性，我的理解逻辑则按照下面的流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;dataflow.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;TCP-流控制&quot;&gt;&lt;a href=&quot;#TCP-流
      
    
    </summary>
    
      <category term="network" scheme="http://yoursite.com/categories/network/"/>
    
    
      <category term="network" scheme="http://yoursite.com/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>复路分解与多复路</title>
    <link href="http://yoursite.com/2018/11/13/TCP-IP-demultipexing-multiplexing/"/>
    <id>http://yoursite.com/2018/11/13/TCP-IP-demultipexing-multiplexing/</id>
    <published>2018-11-13T12:37:21.000Z</published>
    <updated>2018-12-09T09:08:16.856Z</updated>
    
    <content type="html"><![CDATA[<p>复路分离与多复路发生在传输层的一种行为。</p><ul><li><p><strong>demultiplexing:</strong></p><p>At the receiving end, the transport layer examines these fields to identify the receiving socket and then directs the segment to that socket. This job of delivering the data in a transport-layer segment to the correct socket is called <strong>demultiplexing</strong></p></li><li><p><strong>multiplexing:</strong></p><p>The job of gathering data chunks at the source host from different sockets, encapsulating each data chunk with header information (that will later be used in demultiplexing) to create segments, and passing the segments to the network layer is called multiplexing</p><p>中文含义</p></li><li><p><strong>复路分离</strong></p><p>在接收端，传输层根据数据段中的头字段特定字段[UDP：源port/目的port、TCP：源IP/port,目的IP/port]对数据帧进行分类，派送到不同的socket通道中，这个过程就是<strong>复路分离</strong></p></li><li><p><strong>多复路</strong></p><p>传输层从上层应用层中不同的应用（socket）接收数据，然后封装成一个数据帧，派送到网络层，这个过程是<strong>多复路</strong></p><p>那么具体流程是什么样的，请见下图</p><p><img src="figure1.1.png" alt=""></p></li></ul><hr><h2 id="怎么看待socket"><a href="#怎么看待socket" class="headerlink" title="怎么看待socket"></a>怎么看待socket</h2><ul><li><strong>socket 是接口</strong></li></ul><p>开发人员如果进行网络编程，使用socket 是不少的，现在比较常见的传输层协议常见TCP,UDP,SCTP,DCCP。socket是传输层与应用层的抽象网络接口，因此网络数据不可能直接通过应用层直接送到网络层，反之亦然，开发人员在应用层对socket拥有一切控制权，但是在传输层只有少量的控制权。</p><ul><li><strong>用socket干什么</strong></li></ul><p>上述所讲，socket 是接口，是建立在应用层和传输层之间的抽象层，因此对于低层的协议/数据，我们丝毫不用关心。举个例子，我们现在使用ftp 协议，我们只需要关系ftp中的对话规则，我怎么知道对话规则，直接找到RFC 文档，找到协议规则。不需要关心这个数据怎么传输到对方的。我们只需要做到知道两件事：<1>我发送了什么 <2> 我接收到了什么。这样看来，使用socket 就像是一个黑匣子，放进去什么东西，出来了什么东西。就是这么简单？ 对，就是这样</2></1></p><hr><h2 id="TCP-和-UDP-建立通信的区别"><a href="#TCP-和-UDP-建立通信的区别" class="headerlink" title="TCP 和 UDP 建立通信的区别"></a>TCP 和 UDP 建立通信的区别</h2><ul><li><p><strong>UDP</strong></p><p>if two UDP segments have different source IP addresses and/or source port numbers, but have the same destination IP address and destination port number, then the two segments will be directed to the same destination process via <strong>the same destination socket</strong>.</p></li><li><p><strong>TCP</strong></p><p>In particular, and in contrast with UDP, two arriving TCP segments with different source IP addresses or source port numbers will (with the exception of a TCP segment carrying the original connectionestablishment request) be <strong>directed to two different sockets</strong></p><p>socket 是跨进程的，是一个系统资源，通过上述两段文字，从字面上看，TCP 是每来一个客户端，便建立一个socket 资源，UDP 则始终是一条socket 接收使用。但是善于利用的人，可针对这些特点，进行恶意的消耗资源</p></li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本文只是针对了TCP/UDP 在网络框架（TCP/IP 5层结构）中一个大概的位置和作用，需要更加进行了解的请移步<a href="https://www.bau.edu.jo/UserPortal/UserProfile/PostsAttach/10617_1870_1.pdf" target="_blank" rel="noopener">computer_network_top_to_down</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;复路分离与多复路发生在传输层的一种行为。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;demultiplexing:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;At the receiving end, the transport layer examines these fie
      
    
    </summary>
    
      <category term="network" scheme="http://yoursite.com/categories/network/"/>
    
    
      <category term="network" scheme="http://yoursite.com/tags/network/"/>
    
  </entry>
  
</feed>
