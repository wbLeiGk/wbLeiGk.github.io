<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>QK</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-18T16:00:39.546Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>lwb</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>接口interface 心得（1）</title>
    <link href="http://yoursite.com/2019/03/18/go%E6%8E%A5%E5%8F%A3%E5%B0%8F%E5%BE%97/"/>
    <id>http://yoursite.com/2019/03/18/go接口小得/</id>
    <published>2019-03-18T14:52:09.000Z</published>
    <updated>2019-03-18T16:00:39.546Z</updated>
    
    <content type="html"><![CDATA[<p>看到go 语言的接口一个与众不同的地方~</p><p>我的印象中，在go中，基本上是以下这种行为</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span>  main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> people <span class="keyword">interface</span> &#123;</span><br><span class="line">getOccupation() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span>  student <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> worker <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu student)</span><span class="title">getOccupation</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"student"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(wk worker)</span><span class="title">getOccupation</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"worker"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printOccupation</span><span class="params">(pe people)</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"the occupation is : "</span>,pe.getOccupation())</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">printOccupation(student&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的代码没什么出奇的地方</p><p>请看下面一段代码<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span>  main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ioreader <span class="keyword">interface</span> &#123;</span><br><span class="line">MyReader()[]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> fileExcute <span class="keyword">interface</span> &#123;</span><br><span class="line">MyReader()[]<span class="keyword">byte</span></span><br><span class="line">MyWrite([]<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFlush2</span><span class="params">(io ioreader)</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"code snippet is executing: MyFlush2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFlush</span><span class="params">(io fileExcute)</span></span>&#123;</span><br><span class="line">MyFlush2(io)</span><br><span class="line">fmt.Println(<span class="string">"code snippet is executing: MyFlush"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Myfile <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file Myfile)</span> <span class="title">MyReader</span><span class="params">()</span> []<span class="title">byte</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fil Myfile)</span> <span class="title">MyWrite</span><span class="params">([]<span class="keyword">byte</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">MyFlush(Myfile&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时候一个结构体实现了两个接口，而且作为参数传递，接口fileExcute中的方法比ioreader接口中的方法要多</p><p>且被当成参数传递给了ioreader，数据类型也兼容，反过来将ioreader 传递给fileExecute 就会出错，因为会出现部分方法没有实现的错误</p><p>可见go语言中的interface 很是灵活</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看到go 语言的接口一个与众不同的地方~&lt;/p&gt;
&lt;p&gt;我的印象中，在go中，基本上是以下这种行为&lt;/p&gt;
&lt;figure class=&quot;highlight golang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li
      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="go" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/go/"/>
    
    
  </entry>
  
  <entry>
    <title>screen</title>
    <link href="http://yoursite.com/2019/03/18/%E5%B7%A5%E5%85%B7screen/"/>
    <id>http://yoursite.com/2019/03/18/工具screen/</id>
    <published>2019-03-18T14:00:40.000Z</published>
    <updated>2019-03-18T14:49:26.555Z</updated>
    
    <content type="html"><![CDATA[<p>玩过Linux的多多少少听过 screen 这个玩意~</p><p>sreen 是为了长时间工作的一种会话管理工具，你不用担心你退出终端而中断你的任务</p><p>比如你在公司远程连接了云服务器，但是任务没有做完，怎么办，没关系，我们只要使用screen</p><p>回到家中登上云服务器attach  screen session 就可以，我们完全可以在不同的物理中断上共享</p><p>相同会话进程组~</p><p>他就像你在本地shell执行程序一样，其实是在绘画断开的时候阻断了信号signup信号</p><p>是我最喜爱的工具之一</p><p><strong>创建会话开始</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen</span><br></pre></td></tr></table></figure></p><p><strong>创建任务</strong><br>为了方便attach session ，一般使用下面的方式进行创建任务<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">screen -S session name [task]</span><br><span class="line">//for example </span><br><span class="line">screen -S  modifycpp vim hello.cpp</span><br></pre></td></tr></table></figure></p><p><strong>暂停任务</strong></p><p>暂停当前工作，返回shell 窗口<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+a d</span><br></pre></td></tr></table></figure></p><p><strong>创建新的shell</strong><br>创建一个新的shell 窗口<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+a c</span><br></pre></td></tr></table></figure></p><p><strong>会话窗口切换</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctrl+a p // 前一个窗口</span><br><span class="line">ctrl+a n //下一个窗口</span><br></pre></td></tr></table></figure></p><p><strong>附加会话</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -x [session id]/[session name]</span><br></pre></td></tr></table></figure></p><p><strong>查看会话</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -ls</span><br></pre></td></tr></table></figure></p><p>以上是我比较常用的几个命令吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;玩过Linux的多多少少听过 screen 这个玩意~&lt;/p&gt;
&lt;p&gt;sreen 是为了长时间工作的一种会话管理工具，你不用担心你退出终端而中断你的任务&lt;/p&gt;
&lt;p&gt;比如你在公司远程连接了云服务器，但是任务没有做完，怎么办，没关系，我们只要使用screen&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://yoursite.com/2019/03/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/03/18/设计模式/</id>
    <published>2019-03-18T12:21:20.000Z</published>
    <updated>2019-03-18T13:15:00.176Z</updated>
    
    <content type="html"><![CDATA[<p>开此分类的原因，是因为有人在吃饭的时候向我问起了设计模式</p><p>关于设计模式的几大原则</p><h3 id="1、单一职责原则"><a href="#1、单一职责原则" class="headerlink" title="1、单一职责原则"></a><strong>1、单一职责原则</strong></h3><p>功能职责边界划分清楚，当一个功能crash/uncorrect ,不会影响另一个功能模块</p><h3 id="2、里氏替换原则"><a href="#2、里氏替换原则" class="headerlink" title="2、里氏替换原则"></a><strong>2、里氏替换原则</strong></h3><p>子类继承父类的时候，尽量不去覆盖和重写父类的方法，这样就算，传入参数发生了变动（父类-&gt;子类），也不会影响原对象的功能（父类）</p><h3 id="3、依赖倒置原则"><a href="#3、依赖倒置原则" class="headerlink" title="3、依赖倒置原则"></a><strong>3、依赖倒置原则</strong></h3><p>与面向接口编程很像，设计功能类时，考虑到可扩展性，一般我们在本类中维持一个接口，这样我们不用修改接口，直接通过实现接口，来完成功能的可扩展性</p><h3 id="4、接口隔离原则"><a href="#4、接口隔离原则" class="headerlink" title="4、接口隔离原则"></a><strong>4、接口隔离原则</strong></h3><p>这个更像是数据库范式中的第三范式，我们应该完全实现接口中的方法，而不是部分实现，从而接口不是最小职责的原则</p><h3 id="5、迪米特法则"><a href="#5、迪米特法则" class="headerlink" title="5、迪米特法则"></a><strong>5、迪米特法则</strong></h3><p>高内聚低耦合，也就是对外提供统一的接口，其他类或者自己不访问其他类的内部数据</p><h3 id="6、开闭原则"><a href="#6、开闭原则" class="headerlink" title="6、开闭原则"></a><strong>6、开闭原则</strong></h3><p>很模糊的一个设计原则，只针对原有代码进行扩展，而不修改，更像是针对接口进行扩展，而不修改原有接口的内容</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开此分类的原因，是因为有人在吃饭的时候向我问起了设计模式&lt;/p&gt;
&lt;p&gt;关于设计模式的几大原则&lt;/p&gt;
&lt;h3 id=&quot;1、单一职责原则&quot;&gt;&lt;a href=&quot;#1、单一职责原则&quot; class=&quot;headerlink&quot; title=&quot;1、单一职责原则&quot;&gt;&lt;/a&gt;&lt;strong
      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="http://yoursite.com/2019/03/12/CPPTopologicOrder/"/>
    <id>http://yoursite.com/2019/03/12/CPPTopologicOrder/</id>
    <published>2019-03-12T15:47:01.000Z</published>
    <updated>2019-03-18T12:19:39.918Z</updated>
    
    <content type="html"><![CDATA[<p>todo</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;todo&lt;/p&gt;

      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="cpp" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>cpp11线程</title>
    <link href="http://yoursite.com/2019/03/05/cpp11%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/03/05/cpp11线程/</id>
    <published>2019-03-05T13:45:03.000Z</published>
    <updated>2019-03-18T12:19:56.066Z</updated>
    
    <content type="html"><![CDATA[<p>本来不想动~，想多看一点其他书~，但还是强迫自己写下这篇cpp11的线程概述~</p><p>关于cpp的线程详解有一本书讲的蛮不错~，前一阵子再看《cpp concurrency in action》 主讲线程细节</p><hr><h1 id="一-、线程"><a href="#一-、线程" class="headerlink" title="一 、线程"></a>一 、线程</h1><h2 id="上层接口"><a href="#上层接口" class="headerlink" title="上层接口"></a>上层接口</h2><h3 id="1-asnc-and-Futures"><a href="#1-asnc-and-Futures" class="headerlink" title="1 asnc() and Futures"></a>1 asnc() and Futures</h3><p><strong>aysnc()</strong> :提供一个可运行在后台的接口，其功能实现调用通过回调函数<br><strong>future&lt;&gt;</strong> : 让你等待一个线程的运行结果，返回值或者异常<br><strong>shared_future&lt;&gt;</strong> : 与future不同的是，future取回的值只能被处理一次，而shared_future 可以被处理多次</p><p>example:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">this_thread::sleep_for(chrono::seconds(<span class="number">2</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   main()&#123;</span><br><span class="line">       <span class="keyword">auto</span> result = future&lt;<span class="keyword">int</span>&gt;(async([]() &#123;<span class="keyword">return</span> <span class="number">2</span>; &#125;)).get()+getValue();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"the value is :"</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>async() 函数有三个可选的状态</p><ol><li>立刻运行 launch::async=0x1</li><li>推迟运行，在适当的机会运行 launch::deferred =0x2</li><li>默认状态，可能是立刻运行或者推迟运行 launch::async|launch::deferred</li></ol><p>但是这三种状态都可以使用get()函数从而进行任务变化为运行的状态</p><p>而wait() 系列的函数则是被动的东岱，而不是强迫任务开始，get()则不然，是强迫你任务开始，而wait()对应三种状态：</p><ol><li>future_status::ready</li><li>future_status::deferred</li><li>future_status::timeout</li></ol><p>So, let me make clear: If you start to use async(), you should pass all objects necessary to process the passed functionality by value so that async() uses only local copies. If copying is too expensive, ensure that the objects are passed as constant reference and that mutable is not used</p><h2 id="底层接口-：thread"><a href="#底层接口-：thread" class="headerlink" title="底层接口 ：thread"></a>底层接口 ：thread</h2><p>thrad 使用方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(function object)</span></span>;</span><br></pre></td></tr></table></figure></p><ol><li>thread 没有launch 策略，c++标准库尽可能的开始一个传入的函数对象，如果不可行，会抛出一个system_error的错误</li><li>没有接口可以处理线程的输出结构和返回值，你只能获取一个独一无二的线程ID</li><li>如果一个异常发生，而你没有捕获，那么程序将立刻中断，给线程传递一个外部的异常指针变量exception_ptrs</li><li>你必须执行join()或者detach()操作，否则程序将发生中断</li><li>如果你让线程在后台运行，一旦main() 函数结束，所有的线程将会立刻中断</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function">thread <span class="title">t</span><span class="params">([]() &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; <span class="built_in">endl</span>; this_thread::sleep_for(chrono::seconds(<span class="number">3</span>)); &#125;)</span></span>;</span><br><span class="line">t.join();</span><br></pre></td></tr></table></figure><h3 id="1-detached-threads"><a href="#1-detached-threads" class="headerlink" title="1 detached threads"></a>1 detached threads</h3><p>分离线程如果使用了非局部变量很容易成为一个问题，因为你一旦分离了线程，就意味了你失去了对它的控制，那么至于它运行多久，我们就不知道了。因为有可能在非局部变量生命周期结束的时候，线程有可能还没有结束，那么你的线程很可能会出现问题。因此，强烈将以，你传递给线程从copy-value 的方式，而不是引用的方式。</p><h3 id="2-Promises"><a href="#2-Promises" class="headerlink" title="2 Promises"></a>2 Promises</h3><p>为了能够取回线程中的值，像async()一样，我们使用promises函数特性辅助<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start thread using a promise to store the outcome</span></span><br><span class="line"><span class="built_in">std</span>::promise&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; p;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">([](<span class="built_in">string</span> &amp;b)&#123;b=<span class="number">12</span>;&#125;,<span class="built_in">std</span>::ref(p))</span></span>;</span><br><span class="line">t.detach();</span><br><span class="line">...</span><br><span class="line"><span class="comment">// create a future to process the outcome</span></span><br><span class="line"><span class="built_in">std</span>::future&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; f(p.get_future());</span><br><span class="line"><span class="comment">// process the outcome</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"result: "</span> &lt;&lt; f.get() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><h3 id="3-packeaged-task-lt-gt"><a href="#3-packeaged-task-lt-gt" class="headerlink" title="3 packeaged_task&lt;&gt;"></a>3 packeaged_task&lt;&gt;</h3><p>aysnc() 让你处理立刻执行还是推迟，然后返回结果，有时候，你可能需要自己决定什么时间怎么执行一个任务，那么packaged_task&lt;&gt;就是这个目的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">compute</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::packaged_task&lt;<span class="keyword">double</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; task(compute); <span class="comment">// create a task</span></span><br><span class="line"><span class="built_in">std</span>::future&lt;<span class="keyword">double</span>&gt; f = task.get_future(); <span class="comment">// get its future</span></span><br><span class="line">...</span><br><span class="line">task(<span class="number">7</span>,<span class="number">5</span>); <span class="comment">// start the task (typically in a separate thread)</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">double</span> res = f.get(); <span class="comment">// wait for its end and process result/exception</span></span><br></pre></td></tr></table></figure></p><p>note:</p><p>thread.native_handle(): Returns a platform-specific type native_handle_type fornonportable extensions</p><p>unsigned int std::thread::hardware_concurrency ()<br>• Returns the number of possible threads.</p><p>• This value is just a hint and does not guarantee to be exact.</p><p>• Returns 0 if the number is not computable or well defined.</p><hr><h1 id="二-、同步"><a href="#二-、同步" class="headerlink" title="二 、同步"></a>二 、同步</h1><p>并发处理相同的数据~</p><p>相同数据：意味着相同的内存位置，如果不同线程处理不同的变量、对象或者不同的成员，自然也就没有问题啦，自c11，除了位域（bitfield），每个变量都被保证拥有自己的内存地址。并发的处理相同的数据，如果仅仅读是没有问题的，如果当一个超过1个线程修改了数据，那么就会陷入数据不同步的麻烦中，这也是数据竞争，也可以理解为不同线程间的矛盾处理，会产生未定义行为（undefined behave）</p><p>数据竞争带来的后果是，代码中是你想做的，但是实际输出结果不是你想要的</p><p>产生这种原因来源于编译器或者cpu的指令的优化~，首先我们得理解cpp对于并发的并发给了我们什么承诺（保证），像cpp 这样的编程语言总是抽象的支持在不同的硬件和平台上，根据他们的架构和目的，从而提供了不同的能力和接口，因而cpp规定了相应语句和操作产生的结果，并不是产生相应的汇编代码（assembler code）,cpp标准只要求结果，至于你怎么实现，却没有明确的定义。</p><p>因此，你不能期待编程语言给予你太多的承诺，实际上根据as-if rule,只要保证外部行为表现相同，每个编译器都通常选择优化代码，因此编译器产生的代码也是黑盒的。</p><p>我们也就知道，任何未定义的都可能是编译器和硬件提供商为了产生尽可能高效的代码导致的，比如：编译器可能会展开循环、打乱执行语句、消除无用代码、预取数据，并且在现代架构中，一个硬件缓冲区可能打乱存储和加载的顺序。</p><p>执行语句的乱序对于提高性能很有用，但是他们在并发中也极有可能破坏所期待结构的行为，因此，安全并不是默认保证的</p><h3 id="可能会发生的错误"><a href="#可能会发生的错误" class="headerlink" title="可能会发生的错误"></a>可能会发生的错误</h3><p><strong>数据处理不同步</strong>： 当两个线程并行处理读取和写入的操作，可能遇到以下情况</p><ul><li>半写入数据：当一个线程正在读取数据，另一个线程正在修改数据，当读取数据读到写入的一般的时间，也是读取的状态既不是旧值也不是新值</li><li>乱序：对于每一个线程的行为可能是正确的，但是一旦讲所有线程联系起来，可能会产生不可预期的结果</li></ul><p>但是cpp还是提供了一些先生安全保证</p><ul><li>处理不同数据： 处理统一容器的不同位置的数据</li><li>并发处理流：  并发处理字符流，文件流，流缓冲区可能导致未定义行为，但是对于格式化输入输出标准流被同步于c i/o,是可能的，虽然他可能导致插入字符</li></ul><h3 id="1-解决方案"><a href="#1-解决方案" class="headerlink" title="1 解决方案"></a>1 解决方案</h3><p>为了保证正确并行数据，我们使用以下方案</p><ol><li><p>原子操作 ：这意味着对于一个变量读取和写入都是原子的，或者语句的序列发生时排他性的，没有任何的中断，因此任何一个线程可以读取到新值。</p></li><li><p>保证执行顺序：我们需要保证一组特定的语句严格按照语句顺序执行，而不被编译器和硬件优化乱序执行。</p></li></ol><p>接口从高到底的：future-&gt;promises-&gt;thread-&gt;mutex &amp; lock -&gt;condition variaable -&gt;atomic data type -&gt;fences<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[风险低-&gt;高][性能低-&gt;高]</span><br><span class="line">```  </span><br><span class="line">没有提到<span class="keyword">volatile</span>的原因，在java中这个关键字提供原子性顺序执行，但是在cpp 中没有提供这种保证，仅仅指定处理外部资源~不应该被优化</span><br><span class="line"></span><br><span class="line">#### <span class="number">2</span> mutex <span class="keyword">and</span> lock</span><br><span class="line"></span><br><span class="line">mutex :用于控制并行处理资源的排他性，资源可能是一个对象、多个对象的集合体</span><br><span class="line">lock  ：于mutex 统一使用</span><br><span class="line"></span><br><span class="line">辅助函数：完成初始化即使用的功能</span><br><span class="line">lock_guard&lt;&gt;</span><br><span class="line">unique_guard&lt;&gt;</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="built_in">std</span>::mutex printMutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; l(printMutex)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> elem : s)&#123;</span><br><span class="line">        ....<span class="comment">// handle ?process</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> f1 =<span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,print,<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">auto</span> f2 =<span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,print,<span class="string">"world"</span>);</span><br><span class="line">f1.get();</span><br><span class="line">f2.get();</span><br></pre></td></tr></table></figure></p><h4 id="3-递归锁-recursive-mutex"><a href="#3-递归锁-recursive-mutex" class="headerlink" title="3 递归锁 recursive_mutex"></a>3 递归锁 recursive_mutex</h4><p>循环锁定同一个信号量，典型的事例活动对象、监听器，内部包含了信号量和锁，但是其他方法同样包含，而且需要调用已经包含了信号量和锁的函数，则需要使用递归锁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseAccess</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::recursive_mutex dbMutex;</span><br><span class="line">    ... <span class="comment">// state of database access</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertData</span> <span class="params">(...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::recursive_mutex&gt; lg(dbMutex);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertData</span> <span class="params">(...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::recursive_mutex&gt; lg(dbMutex);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createTableAndinsertData</span> <span class="params">(...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::recursive_mutex&gt; lg(dbMutex);</span><br><span class="line">        ...</span><br><span class="line">    createTable(...); <span class="comment">// OK: no deadlock</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-try-and-timeout-lock"><a href="#4-try-and-timeout-lock" class="headerlink" title="4 try and timeout lock"></a>4 try and timeout lock</h4><p>有时候，程序想要获取一个锁，但是却不想阻塞，这种情况下，信号量mutex提供了try_lock() 成员函数会尝试获取一个锁，如果成功返回true,反之false<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="comment">// try to acquire a lock and do other stuff while this isn’t possible</span></span><br><span class="line"><span class="keyword">while</span> (m.try_lock() == <span class="literal">false</span>) &#123;</span><br><span class="line">    doSomeOtherStuff();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lg(m,<span class="built_in">std</span>::adopt_lock);</span><br><span class="line"><span class="comment">// Note that try_lock() might fail spuriously. </span></span><br><span class="line"><span class="comment">// That is, it might fail (return false) even if the lock is not taken.</span></span><br><span class="line"><span class="comment">// This behavior is provided for memory-ordering reasons but is not widely known</span></span><br></pre></td></tr></table></figure></p><p>如果你想指定一个时间的话，可以使用time_mutex<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::time_mutex m;</span><br><span class="line"><span class="comment">// try to acquire a lock and do other stuff while this isn’t possible</span></span><br><span class="line"><span class="keyword">while</span> (m.try_lock_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>)) == <span class="literal">false</span>) &#123;</span><br><span class="line">    doSomeOtherStuff();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lg(m,<span class="built_in">std</span>::adopt_lock);</span><br></pre></td></tr></table></figure></p><p>一般而言，如果你想锁住超过1个以上的信号量，比如 传输一个受保护的资源向另一个受保护的资源</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex m1;</span><br><span class="line"><span class="built_in">std</span>::mutex m2;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock (m1, m2); <span class="comment">// lock both mutexes (or none if not possible)</span></span><br><span class="line">    <span class="comment">//Note that this lock() provides a deadlock-avoidance mechanism</span></span><br><span class="line">    <span class="comment">//which, however, means that the order of locking inside a multiple lock is undefined.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * std::try_lock()</span></span><br><span class="line"><span class="comment">     * try_lock() does not provide a deadlock-avoidance mechanism. Instead, it guarantees</span></span><br><span class="line"><span class="comment">     * that the locks are tried in the order of the passed arguments</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lockM1(m1,<span class="built_in">std</span>::adopt_lock);</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lockM2(m2,<span class="built_in">std</span>::adopt_lock);</span><br><span class="line">...</span><br><span class="line">&#125; <span class="comment">// automatically unlock all mutexes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * only the code snippet</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">lock_guard <span class="title">lg</span><span class="params">(m)</span> <span class="comment">//Creates a lock guard for the mutex m and locks it</span></span></span><br><span class="line"><span class="function">lock_guard <span class="title">lg</span><span class="params">(m,adopt_lock)</span> <span class="comment">//Creates a lock guard for the already locked mutex m</span></span></span><br><span class="line">lg.~lock_guard()</span><br></pre></td></tr></table></figure><ul><li>unique_lock&lt;&gt;</li></ul><p>如果说lock_guard&lt;&gt;仅仅提供简单的初始化即使用的功能，其内部仅仅完成了mutex.lock() mutex.unlock()~</p><p>那么unique_lock&lt;&gt; 不但提供了lock_guard&lt;&gt;所具备的功能之外，还提供了更复杂的功能，他决定了你可以时间怎么去对一个信号量加锁和释放，因此这个锁的的对象可以在初始化的时候绑定信号量与否</p><p>从成员函数上来看，unique_lock&lt;&gt; 更为灵活，几乎和mutex保持着一致的成员函数~ 除吃之外，使用和lock_guard没有什么区别</p><ul><li>call_once<br>Sometimes multiple threads might not need some functionality that should get processed whenever the first thread needs it. A typical example is lazy initialization: The first time one of the threads needs something that has to get processed, you process it (but not before, because you want to save the time to process it if it is not needed).</li></ul><h4 id="5-条件变量-condition-variable"><a href="#5-条件变量-condition-variable" class="headerlink" title="5 条件变量 condition_variable"></a>5 条件变量 condition_variable</h4><p>有时候，一些线程需要等待其他线程执行的结果，因此你不得不因为一些其他原因不能够处理共享数据，而执行一些同步性的并行操作</p><p>future也可以处理这样的操作，一个线程等待另一个线程，但是只能处理一次，而实际上future的目的仅仅是为了返回值和异常</p><p>对于条件变量的实现，我们可以使用以下方式进行实现~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> readyFlag;</span><br><span class="line"><span class="built_in">std</span>::mutex readyFlagMutex;</span><br><span class="line"><span class="comment">// wait until readyFlag is true:</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; ul(readyFlagMutex);</span><br><span class="line">    <span class="keyword">while</span> (!readyFlag) &#123;</span><br><span class="line">        ul.unlock();</span><br><span class="line">        <span class="built_in">std</span>::this_thread::yield(); <span class="comment">// hint to reschedule to the next thread</span></span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">100</span>));</span><br><span class="line">        ul.lock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// release lock</span></span><br></pre></td></tr></table></figure><p>我们完全可以使用以上的方式实现我们的目的，至于为什么不使用，以下给予了解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The waiting thread consumes valuable processing time repeatedly checking the flag</span><br><span class="line">and when it locks the mutex the thread setting the ready flag is blocked. ...</span><br><span class="line">In addition, it’s hard to get the sleep period right: too short a sleep in between checks</span><br><span class="line">and the thread still wastes processing time checking, too long a sleep</span><br><span class="line">and the thread will carry on sleeping even when the task it is waiting for is complete,</span><br><span class="line">introducing a delay</span><br></pre></td></tr></table></figure><p>因而c++给我们提供了条件变量使用，condition_variable 和 mutex 一起配合使用,</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex queueMutex;</span><br><span class="line"><span class="built_in">std</span>::condition_variable queueCondVar;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">provider</span> <span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// push different values (val til val+5 with timeouts of val milliseconds into the queue</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lg(queueMutex);</span><br><span class="line">            <span class="built_in">queue</span>.push(val+i);</span><br><span class="line">        &#125; <span class="comment">// release lock</span></span><br><span class="line">        queueCondVar.notify_one();</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(val));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span> <span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// pop values if available (num identifies the consumer)</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; ul(queueMutex);</span><br><span class="line">        queueCondVar.wait(ul,[]&#123; <span class="keyword">return</span> !<span class="built_in">queue</span>.empty(); &#125;);</span><br><span class="line">        val = <span class="built_in">queue</span>.front();</span><br><span class="line">        <span class="built_in">queue</span>.pop();</span><br><span class="line">        &#125; <span class="comment">// release lock</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"consumer "</span> &lt;&lt; num &lt;&lt; <span class="string">": "</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// start three providers for values 100+, 300+, and 500+</span></span><br><span class="line">    <span class="keyword">auto</span> p1 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,provider,<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">auto</span> p2 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,provider,<span class="number">300</span>);</span><br><span class="line">    <span class="keyword">auto</span> p3 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,provider,<span class="number">500</span>);</span><br><span class="line">    <span class="comment">// start two consumers printing the values</span></span><br><span class="line">    <span class="keyword">auto</span> c1 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,consumer,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> c2 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,consumer,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-原子操作-atomic"><a href="#6-原子操作-atomic" class="headerlink" title="6 原子操作 atomic"></a>6 原子操作 atomic</h4><p>原子操作：意味着对于一个变量读取和写入都是原子的，与此同时通过atomic的成员函数来看，我们除了这些操作无法提供更为复杂的操作，比如对一个容器、结构体等共享变量做复杂的操作~</p><p>因而，原子操作更适用于基本数据类型~ int /bool /point</p><hr><p>Lock-Free - 无锁技术越来越被开发人员重视，因为锁对于性能的影响实在是太大了，所以如果想开发出一个高性能的程序，你就非常有必要学习 Lock-Free 的编程方式</p><p>菜鸟 正在飞翔<del>~</del><del>~</del>~~~</p><hr><h1 id="三-、异步"><a href="#三-、异步" class="headerlink" title="三 、异步"></a>三 、异步</h1><p>todo</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本来不想动~，想多看一点其他书~，但还是强迫自己写下这篇cpp11的线程概述~&lt;/p&gt;
&lt;p&gt;关于cpp的线程详解有一本书讲的蛮不错~，前一阵子再看《cpp concurrency in action》 主讲线程细节&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;一-、线程&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="cpp" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>cpp缓冲与流对象</title>
    <link href="http://yoursite.com/2019/03/04/cpp%E7%BC%93%E5%86%B2%E4%B8%8E%E6%B5%81%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2019/03/04/cpp缓冲与流对象/</id>
    <published>2019-03-04T13:50:56.000Z</published>
    <updated>2019-03-18T12:19:46.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a><img src="iosArchitect.png" alt="流类图"></h2><p>如上图就是cpp 流的结构~</p><p><strong>ios_base</strong> : 定义了所有流独立于字符类型和字符特征的共有的属性，这个类由流状态函数/流格式标记函数组成</p><p><strong>basic_ios&lt;&gt;</strong> :定了所有流共有的属性但是依赖于字符类型和字符特征，这个属性包含了使用了派生自basic_streambuf&lt;&gt;的流缓冲区，这个缓冲区执行确切的读写能力。</p><p><strong>basic_istream&lt;&gt; &amp;&amp; bacsic_ostream&lt;&gt;</strong>  : 虚继承了basic_ios&lt;&gt; ，分别用来读写</p><p><strong>basic_iostream&lt;&gt;</strong> : 派生自basic_istream&lt;&gt; &amp;&amp; bacsic_ostream&lt;&gt; 可以用来读和写</p><p><strong>basic_streambuf&lt;&gt;</strong> : 是iostream 库的核心，定了接口用来写向流和从流中读取字符，这些接口可以被其他流使用执行读写能力</p><h2 id="1-责任划分"><a href="#1-责任划分" class="headerlink" title="1. 责任划分"></a>1. 责任划分</h2><p>  派生自basic_ios只用来处理数据的格式、流的状态，而字符的读写被basic_streambuf&lt;&gt;执行，流缓冲区提供给其他流接口用来处理字符读写{socket、graphic、user interface component}</p><h2 id="2-流对象类别"><a href="#2-流对象类别" class="headerlink" title="2. 流对象类别"></a>2. 流对象类别</h2><ol><li>标准输入输出 :iostream 、istream 、ostream</li><li>文件流 : fstream</li><li>字符流 : stringstream</li></ol><h2 id="3-流的状态"><a href="#3-流的状态" class="headerlink" title="3. 流的状态"></a>3. 流的状态</h2><ol><li>goodbit: 一切都是正常的，没有任何bit位被设置</li><li>eofbit : 到达文件结尾</li><li>failbit: 发生错误，i/o操作不成功</li><li>badbit : 致命的错误，产生未定义状态</li></ol><p>对应的函数：good()、eof()、fail()、bad()、rdstate()、clear()、setstate()</p><h2 id="4-标准输入输出函数"><a href="#4-标准输入输出函数" class="headerlink" title="4. 标准输入输出函数"></a>4. 标准输入输出函数</h2><p>&lt;&lt; &amp;&amp; &gt;&gt;两个操作符是带有格式格式的输入输出方式，如果用户想用原生态数据（没有格式化），可以使用流的成员函数</p><h3 id="4-1-输入成员函数"><a href="#4-1-输入成员函数" class="headerlink" title="4.1 输入成员函数"></a>4.1 输入成员函数</h3><ol><li>get()</li><li>getline()</li><li>read()</li><li>readsome()</li></ol><h3 id="4-2-输出成员函数"><a href="#4-2-输出成员函数" class="headerlink" title="4.2 输出成员函数"></a>4.2 输出成员函数</h3><ol><li>put()</li><li>write()</li><li>flush()</li></ol><h3 id="4-3-流的辅助类-sentry"><a href="#4-3-流的辅助类-sentry" class="headerlink" title="4.3 流的辅助类 sentry"></a>4.3 流的辅助类 sentry</h3><p>辅助类形式<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sentry <span class="title">se</span><span class="params">(strm)</span></span>; <span class="comment">// indirect pre- and postprocessing</span></span><br><span class="line"><span class="keyword">if</span> (se) &#123;</span><br><span class="line">... <span class="comment">// the actual processing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>哨兵类用来做流对象的预处理和后处理的工作~</p><p>这些操作包括：同步几个流，检查流是否正常，是否跳过空格，实现特定任务{多线程环境下，完成相应的锁定}</p><h3 id="4-4-流格式操作"><a href="#4-4-流格式操作" class="headerlink" title="4.4 流格式操作"></a>4.4 流格式操作</h3><p>头文件<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>而对应的format 在std::ios::XXX</p><h4 id="4-4-1-成员函数"><a href="#4-4-1-成员函数" class="headerlink" title="4.4.1 成员函数"></a>4.4.1 成员函数</h4><p>流对象中</p><ol><li>setf</li><li>unsetf</li><li>flag </li><li>copyfmt</li><li>imbue  //set local object [internationalization]</li><li>getloc  //get the local object [internationalization]</li></ol><h4 id="4-4-2全局函数"><a href="#4-4-2全局函数" class="headerlink" title="4.4.2全局函数"></a>4.4.2全局函数</h4><p>这些函数在iomanip头文件中</p><ol><li>setiosflags</li><li>resetiosflags</li><li>… </li></ol><h2 id="5-文件流"><a href="#5-文件流" class="headerlink" title="5. 文件流"></a>5. 文件流</h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="fileArchi.png" alt="文件流类图"></h2><p>文件流派生自标准输入输出流，主要用于文件的读写</p><h3 id="5-1-文件打开标记"><a href="#5-1-文件打开标记" class="headerlink" title="5.1 文件打开标记"></a>5.1 文件打开标记</h3><ol><li>in</li><li>out</li><li>app<br>而这三者可以任意组合</li></ol><h3 id="5-2-文件随机处理指针"><a href="#5-2-文件随机处理指针" class="headerlink" title="5.2 文件随机处理指针"></a>5.2 文件随机处理指针</h3><p>输入流：</p><ol><li>tellg</li><li>seekg</li></ol><p>输出流：</p><ol><li>tellp</li><li>seekp</li></ol><h2 id="6-字符串流"><a href="#6-字符串流" class="headerlink" title="6. 字符串流"></a>6. 字符串流</h2><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="stringArchi.png" alt="字符串流类图"></h2><h3 id="6-1-成员函数"><a href="#6-1-成员函数" class="headerlink" title="6.1 成员函数"></a>6.1 成员函数</h3><p>输出流</p><ol><li>str() : 返回一个字符串</li><li>str(string) : 把string 设置成</li></ol><p>输入流：<br>“&gt;&gt;” 操作符，用来将缓冲区的数据输入到特定的类型</p><h2 id="7-输入流和输出流的连接"><a href="#7-输入流和输出流的连接" class="headerlink" title="7. 输入流和输出流的连接"></a>7. 输入流和输出流的连接</h2><p>通常而言，你需要连接两个流，比如可能需要确保在读取输入之前在屏幕上写入要求输入的文本，读写使用同一个流，操作相同的流使用不同的数据格式</p><h3 id="7-1-成员函数"><a href="#7-1-成员函数" class="headerlink" title="7.1 成员函数"></a>7.1 成员函数</h3><ol><li>tie() :返回一个已经绑定到流上的输出流指针</li><li>tie(ostream *strm) : 设置输出流对象，返回之前的流指针</li></ol><h3 id="7-2流缓冲区的绑定-释放"><a href="#7-2流缓冲区的绑定-释放" class="headerlink" title="7.2流缓冲区的绑定/释放"></a>7.2流缓冲区的绑定/释放</h3><ol><li>rdbuf() :返回流缓冲区的指针</li><li>rdbuf(streambuf* ) :设置流缓冲区，返回之前的缓冲区对象指针。</li></ol><p>利用流缓冲区的绑定和释放，我们可以实现重定向的作用<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redirect</span><span class="params">(ostream&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"the first row"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  redirect(<span class="built_in">cout</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"the last row"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redirect</span> <span class="params">(ostream&amp; strm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// save output buffer of the stream</span></span><br><span class="line"><span class="comment">// - use unique pointer with deleter that ensures to restore</span></span><br><span class="line"><span class="comment">// the original output buffer at the end of the function</span></span><br><span class="line">  <span class="keyword">auto</span> del = [&amp;](streambuf* p) &#123;</span><br><span class="line">  strm.rdbuf(p);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;streambuf,<span class="keyword">decltype</span>(del)&gt; origBuffer(strm.rdbuf(),del);</span><br><span class="line">  <span class="comment">// redirect ouput into the file redirect.txt</span></span><br><span class="line">  <span class="function">ofstream <span class="title">file</span><span class="params">(<span class="string">"redirect.txt"</span>)</span></span>;</span><br><span class="line">  strm.rdbuf (file.rdbuf());</span><br><span class="line">  file &lt;&lt; <span class="string">"one row for the file"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  strm &lt;&lt; <span class="string">"one row for the stream"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="comment">// closes file AND its buffer automatically</span></span><br></pre></td></tr></table></figure></p><p>基本上基础关于流的基础知识也就是这么多~</p><p>对于流缓冲区的使用，用户自定义模式~，这一步，将单独写一篇博客用来描述</p><p>sleeping~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;img src=&quot;iosArchitect.png&quot; alt=&quot;流类图&quot;&gt;&lt;/h2&gt;&lt;p&gt;如上图就是cpp 流的结构~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ios_base&lt;/
      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="cpp" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>GoWeb &lt;1&gt;</title>
    <link href="http://yoursite.com/2019/03/03/goWeb/"/>
    <id>http://yoursite.com/2019/03/03/goWeb/</id>
    <published>2019-03-03T15:38:19.000Z</published>
    <updated>2019-03-18T12:20:15.026Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="go" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/go/"/>
    
    
  </entry>
  
  <entry>
    <title>个人博客简介</title>
    <link href="http://yoursite.com/2019/03/02/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2019/03/02/个人博客简介/</id>
    <published>2019-03-02T09:37:11.000Z</published>
    <updated>2019-03-12T14:45:09.518Z</updated>
    
    <content type="html"><![CDATA[<p>毕业已有2年左右的时间~</p><p>工作以后，一次和同学电话中通话中谈及了博客~</p><p>博客，也许是锻炼你整理、表达思路的一种很好的方式~，将你所知道的所学的整理记录</p><p>于是我的博客开始诞生~</p><p>此博客是在18年12月来开始建起来的~ ，恰好这段时间利用下班和周末的时间学习golang语言，于是博客内容大多呈现了golang</p><hr><p>工作使用语言为c/cpp，之后，我也会陆续的写cpp的文章~</p><p>关于cpp可能重点放在模板、并发、容器这一块~</p><p>之后可能会在编译原理、数据库、网络协议 以及计算机系统原理上</p><hr><p>身为一个IT人士，我热爱这个职业，或者说性格使然~</p><p>从小不是很擅长与人打交道，喜爱独自一个人~</p><p>独自一人~，看书是一个不错的消遣方式~ </p><p>哈~，工作以后~主要都是技术书~，想着未来要吃着一碗饭，于是乎到时看了不少~ ，内容有懂的，有不懂的~ </p><p>随后~ 再看到其他书的时候，很多问题也在看看慢慢理解~</p><hr><p>加油~！ 奋斗的小子~~</p><p>最后给自己送上一首来自Max Ehrmann 的《Desiderata 》</p><p>Go placidly amid the noise and haste,<br>and remember what peace there may be in silence.<br>As far as possible without surrender<br>be on good terms with all persons.<br>Speak your truth quietly and clearly;<br>and listen to others,<br>even the dull and the ignorant;<br>they too have their story.</p><p>Avoid loud and aggressive persons,<br>they are vexations to the spirit.<br>If you compare yourself with others,<br>you may become vain and bitter;<br>for always there will be greater and lesser persons than yourself.<br>Enjoy your achievements as well as your plans.</p><p>Keep interested in your own career, however humble;<br>it is a real possession in the changing fortunes of time.<br>Exercise caution in your business affairs;<br>for the world is full of trickery.<br>But let this not blind you to what virtue there is;<br>many persons strive for high ideals;<br>and everywhere life is full of heroism.</p><p>Be yourself.<br>Especially, do not feign affection.<br>Neither be cynical about love;<br>for in the face of all aridity and disenchantment<br>it is as perennial as the grass.</p><p>Take kindly the counsel of the years,<br>gracefully surrendering the things of youth.<br>Nurture strength of spirit to shield you in sudden misfortune.<br>But do not distress yourself with dark imaginings.<br>Many fears are born of fatigue and loneliness.<br>Beyond a wholesome discipline,<br>be gentle with yourself.</p><p>You are a child of the universe,<br>no less than the trees and the stars;<br>you have a right to be here.<br>And whether or not it is clear to you,<br>no doubt the universe is unfolding as it should.</p><p>Therefore be at peace with God,<br>whatever you conceive Him to be,<br>and whatever your labors and aspirations,<br>in the noisy confusion of life keep peace with your soul.</p><p>With all its sham, drudgery, and broken dreams,<br>it is still a beautiful world.<br>Be cheerful.<br>Strive to be happy.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;毕业已有2年左右的时间~&lt;/p&gt;
&lt;p&gt;工作以后，一次和同学电话中通话中谈及了博客~&lt;/p&gt;
&lt;p&gt;博客，也许是锻炼你整理、表达思路的一种很好的方式~，将你所知道的所学的整理记录&lt;/p&gt;
&lt;p&gt;于是我的博客开始诞生~&lt;/p&gt;
&lt;p&gt;此博客是在18年12月来开始建起来的~ ，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据类型&lt;map&gt;</title>
    <link href="http://yoursite.com/2019/03/01/goDataMap/"/>
    <id>http://yoursite.com/2019/03/01/goDataMap/</id>
    <published>2019-03-01T13:35:48.000Z</published>
    <updated>2019-03-18T12:24:27.189Z</updated>
    
    <content type="html"><![CDATA[<p>今天周五 ~</p><p>同事离职里，是一个很不错的人~</p><p>下班后一起开心的吃了一个饭~</p><hr><p>map 该怎么说这个数据结构呢,map 有键值对的组成的，内置hash算法对值时刻进行放置</p><p>cpp 中关于map的容器都有<strong>map/unorder_map /mutilmap /unorder_map</strong> 四种类型，其中<strong>mutil 前缀表示key可以重复</strong> ,unorder前缀用来表示插入值的时候不需要排序，一般没有什么特殊的要求~,我们在cpp 中都是使用unordered_map这种容易。</p><p>在golang中的map 其实和unordered_map这种容器很相似，具体体现：1&gt;key是唯一的 2&gt;内部没有排序</p><ul><li>golang map声明<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mymap <span class="keyword">map</span>[<span class="keyword">type</span>]<span class="keyword">type</span> <span class="comment">//nil</span></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">mymap:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">type</span>]<span class="keyword">type</span>) <span class="comment">//len==0,but mymap!=nil</span></span><br><span class="line"></span><br><span class="line">mymap[<span class="string">"string"</span>]=<span class="keyword">int</span>(<span class="number">2</span>)<span class="comment">// 例子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//嵌套map</span></span><br><span class="line"><span class="keyword">var</span> mymap <span class="keyword">map</span>[<span class="keyword">type</span>]<span class="keyword">map</span>[<span class="keyword">type</span>]<span class="keyword">int</span></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">mymap:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">type</span>]<span class="keyword">map</span>[<span class="keyword">type</span>]<span class="keyword">int</span>)</span><br><span class="line">myint:=mymap[<span class="keyword">type</span>][<span class="keyword">type</span>]</span><br></pre></td></tr></table></figure></li></ul><p>看起来的好像map使用挺方便的，实际上，在我们插入的时候，进行了key的<strong>比较</strong>~，这里的比较不是排序的比较，而是操作符“==”的比较，那么至少就要求我们要对map变量key必须key可以比较。</p><p>那我们知道在golang 中slice /float 很难进行比较多的，但是我们又想让他们成为我们的key，这时候我们就要将这些 key 做一些处理，将其转化为我们可以比较的类型/方式</p><hr><p><strong>map 的排序输出</strong></p><p>我们知道map输出的元素是不一定的，但是有时候，我们需要将其排序输出那么该怎么办~</p><p>实际上，我们可以采用一种折中的方式进行处理，首先我们使用range 函数将 key set进行排序，之后通过索引map的key进行输出，从而达到，排序输出的目的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天周五 ~&lt;/p&gt;
&lt;p&gt;同事离职里，是一个很不错的人~&lt;/p&gt;
&lt;p&gt;下班后一起开心的吃了一个饭~&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;map 该怎么说这个数据结构呢,map 有键值对的组成的，内置hash算法对值时刻进行放置&lt;/p&gt;
&lt;p&gt;cpp 中关于map的容器都有&lt;stro
      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="go" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/go/"/>
    
    
  </entry>
  
  <entry>
    <title>数据类型 &lt;数组&amp;切片&amp;结构体&gt;</title>
    <link href="http://yoursite.com/2019/03/01/goAndCpp/"/>
    <id>http://yoursite.com/2019/03/01/goAndCpp/</id>
    <published>2019-02-28T16:04:57.000Z</published>
    <updated>2019-03-18T12:19:50.245Z</updated>
    
    <content type="html"><![CDATA[<p>今天晚上我想说的是 go 中的数组和切片</p><p>自然而言的也想起了cpp中的一些玩意</p><p>数组:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array:=[<span class="number">2</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">array:=[...]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">//or</span></span><br></pre></td></tr></table></figure></p><p>切片：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">slice:=[]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">slice:=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span></span><br></pre></td></tr></table></figure></p><p>好像也没太大的区别嘛</p><p>从声明上看，唯一的差别就是数组固定了长度，切片没有固定的长度</p><p>嗯 ~ ，其他差别呢~</p><p><strong>数组比较</strong></p><p>如果在cpp 中呢<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> b[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"the value is equality ? :"</span> &lt;&lt;boolalpha &lt;&lt;(a == b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//output is : false</span></span><br></pre></td></tr></table></figure></p><p>想想也是呢， 好歹人家也是数组也是可以当指针用来着，在不同的内存空间来着，地址不同，自然也就不同</p><p>但是在go中<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array1:=[<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">array2:=[...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">array1==array</span><br><span class="line"><span class="comment">//output: true</span></span><br></pre></td></tr></table></figure></p><p>相等的~！ 嗯~  在go中，好像把数组当成了一 基本类型再用</p><p>那你想啊，这不是还有切片啊</p><p>不过这个切片的确是不能比较的，他们只能和nil 进行比较</p><p>这个切片是scale型，又区别cpp的数组，行为倒是和vector容器有些相似~</p><p>因为内部同样有两个变量可控制，你可以理解为下面的形式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span>&#123;</span><br><span class="line">    ptr * <span class="keyword">int</span><span class="comment">//or other type //uint float32...</span></span><br><span class="line">    <span class="built_in">len</span> ,<span class="built_in">cap</span> <span class="keyword">uint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦超过容量cap ,人家也是要扩展的，这时候可能返回的指针会发生~~~~</p><p>切片人家还是安全性的</p><p>你要判断一个切片是否为空，最好使用len()函数</p><p>而不是使用 slice==nil的形式 ，因为</p><p><strong>slice:=[]int{}</strong> 这种情况下 切片不为空</p><p>好像说了半天，也不知道切片是干嘛的</p><p>嗯~</p><p>其实切片就是一个可以<strong>添加/修改/返回元素子序列</strong>的操作</p><p><strong>append()</strong>:用来添加一个/多个元素 ，或者自身 /其他切片</p><p><strong>slice[:]</strong>：用来返回子序列的 ，也返回了一个<strong>新的切片</strong>和原来的没关系</p><p>由于这种特性~</p><p>使得切片也变得相当灵活~</p><p>比如你可以完全用它实现一个stack/queue 数据结构 </p><p>用它拼接字符串</p><p>自由的插入字符</p><hr><p><strong>结构体</strong></p><p>结构体是基本类型的集合，在golang 中结构体支持anonymous struct，从而避免重复定义。</p><p>. .  .</p><p>sleeping </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天晚上我想说的是 go 中的数组和切片&lt;/p&gt;
&lt;p&gt;自然而言的也想起了cpp中的一些玩意&lt;/p&gt;
&lt;p&gt;数组:&lt;br&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=
      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="go" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/go/"/>
    
    
  </entry>
  
  <entry>
    <title>生活小记2</title>
    <link href="http://yoursite.com/2019/02/25/life-record2/"/>
    <id>http://yoursite.com/2019/02/25/life-record2/</id>
    <published>2019-02-25T14:46:48.000Z</published>
    <updated>2019-02-25T15:12:22.978Z</updated>
    
    <content type="html"><![CDATA[<p>2019 / 2 / 25  </p><p>能够阻挡得似乎是你</p><p>能够说服你的还是你</p><p>能够原谅你的还是你</p><p>.  .   .</p><hr><p>我曾羡慕过很多人</p><p>现在依旧，未来还是</p><p>但是似乎我并讨厌自己现在的处境</p><p>我喜欢努力的自己</p><p>不够用心的努力的你，让我不甚喜欢</p><hr><p>很多世俗的道理，你看过，你听过，你经历过</p><p>但是并不意味，你一定去选择接受与否</p><p>喜欢你用心的感受这个世界</p><p>学会感受</p><hr><p>不论是否喜欢，有时候选择去经历一下，好像也并没有那么糟</p><hr><p>对于这个大千世界，你是一个孩子</p><p>不要放弃任何学习的机会，很多时候并不是能力限制了你</p><p>而是你自己成为了你的阻碍</p><p>请多请教，多思考</p><hr><p>今日起的你，应该面带笑容</p><p>是发自内心的笑容</p><p>是自我承认的笑容</p><p>是勇敢面对的笑容</p><p>是欣赏他人的笑容</p><p>是尊重他人的笑容</p><hr><p>你看，你还真不够成熟</p><p>u just a kid </p><p>just run </p><p>chasing the sunset</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2019 / 2 / 25  &lt;/p&gt;
&lt;p&gt;能够阻挡得似乎是你&lt;/p&gt;
&lt;p&gt;能够说服你的还是你&lt;/p&gt;
&lt;p&gt;能够原谅你的还是你&lt;/p&gt;
&lt;p&gt;.  .   .&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我曾羡慕过很多人&lt;/p&gt;
&lt;p&gt;现在依旧，未来还是&lt;/p&gt;
&lt;p&gt;但是似乎我并讨厌自
      
    
    </summary>
    
      <category term="个人生活" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>数据类型&lt;平衡树&gt;</title>
    <link href="http://yoursite.com/2019/02/22/GoTree/"/>
    <id>http://yoursite.com/2019/02/22/GoTree/</id>
    <published>2019-02-22T01:26:00.000Z</published>
    <updated>2019-03-18T12:20:04.987Z</updated>
    
    <content type="html"><![CDATA[<p>本篇使用go语言实现二叉树</p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>二叉树的创建与c/c++创建并无多大的异处。其关键之处还是在于掌握好一级指针和二级指针的使用，go语言同样支持这两种指针</p><p>本次使用的数据结构一切从简，不适用sentinel模式<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="keyword">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">createTree</span><span class="params">(tree **TreeNode, val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">       Treetmp := &amp;TreeNode&#123;val, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">       <span class="keyword">if</span> <span class="literal">nil</span> == *tree &#123;</span><br><span class="line">           *tree = Treetmp</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> val &gt; (*tree).Val &#123;</span><br><span class="line">           createTree(&amp;(*tree).Right, val)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           createTree(&amp;(*tree).Left, val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里你可能好奇 Treetmp 地址离开了作用域利用消失，此值无效，关于这个答案，我在《The Go Programming Language》</p><ul><li><p>It is perfectly safe for a function to return the address of a local variable</p></li><li><p>…</p></li><li><p>Because the lifetime of a variable is determined only by whether or not it is reachable, a local<br>variable may outlive a single iteration of the enclosing loop. It may continue to exist even after<br>its enclosing function has returned.</p></li></ul><p>因而 ，这也是优化点</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(tree *TreeNode)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">nil</span> != tree &#123;</span><br><span class="line">        fmt.Println(tree.Val)</span><br><span class="line">        <span class="built_in">print</span>(tree.Left)</span><br><span class="line">        <span class="built_in">print</span>(tree.Right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="avl-平衡"><a href="#avl-平衡" class="headerlink" title="avl 平衡"></a>avl 平衡</h1><p>二叉树失衡有四种模式，LL 、LR、RR、RL</p><p>以下实现了两种方式avl:</p><p>基本函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LLTree</span><span class="params">(root **TreeNode)</span></span> &#123;</span><br><span class="line">    newRoot := (*root).Left</span><br><span class="line">    oldRight := newRoot.Right</span><br><span class="line"></span><br><span class="line">    newRoot.Right = *root</span><br><span class="line">    (*root).Left = oldRight</span><br><span class="line">    (*root) = newRoot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RRTree</span><span class="params">(root **TreeNode)</span></span> &#123;</span><br><span class="line">    newRoot := (*root).Right</span><br><span class="line">    oldLeft := newRoot.Left <span class="comment">//old root will get left node</span></span><br><span class="line"></span><br><span class="line">    newRoot.Left = *root</span><br><span class="line">    (*root).Right = oldLeft</span><br><span class="line">    (*root) = newRoot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LRTree</span><span class="params">(root **TreeNode)</span></span> &#123;</span><br><span class="line">    RRTree(&amp;(*root).Left)</span><br><span class="line">    LLTree(root)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RLTree</span><span class="params">(root **TreeNode)</span></span> &#123;</span><br><span class="line">    LLTree(&amp;(*root).Right)</span><br><span class="line">    RRTree(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>获取树的深度：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMaxDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">nil</span> == root &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    leftDepth := getMaxDepth(root.Left) + <span class="number">1</span></span><br><span class="line">    RightDepth := getMaxDepth(root.Right) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> leftDepth &gt; RightDepth &#123;</span><br><span class="line">        <span class="keyword">return</span> leftDepth</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">return</span> RightDepth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>将一颗失衡的数，进行平衡</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B2Tree</span><span class="params">(root **TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">nil</span> == *root &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    leftDepth := B2Tree(&amp;(*root).Left) + <span class="number">1</span></span><br><span class="line">    RightDepth := B2Tree(&amp;(*root).Right) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> leftDepth-RightDepth &gt;= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="comment">//LX</span></span><br><span class="line">        <span class="keyword">if</span> B2Tree(&amp;(*root).Left) &gt; B2Tree(&amp;(*root).Right) &#123;</span><br><span class="line">            <span class="comment">//LL</span></span><br><span class="line">            LLTree(root)</span><br><span class="line">            <span class="keyword">return</span> getMaxDepth(*root)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//LR</span></span><br><span class="line">            LRTree(root)</span><br><span class="line">            <span class="keyword">return</span> getMaxDepth(*root)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> RightDepth-leftDepth &gt;= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="comment">//RX</span></span><br><span class="line">        <span class="keyword">if</span> B2Tree(&amp;(*root).Left) &gt; B2Tree(&amp;(*root).Right) &#123;</span><br><span class="line">            <span class="comment">//RL</span></span><br><span class="line">            RLTree(root)</span><br><span class="line">            <span class="keyword">return</span> getMaxDepth(*root)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//RR</span></span><br><span class="line">            RRTree(root)</span><br><span class="line">            <span class="keyword">return</span> getMaxDepth(*root)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> leftDepth &gt; RightDepth &#123;</span><br><span class="line">            <span class="keyword">return</span> leftDepth</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RightDepth</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>边插入边平衡</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createTreeBT</span><span class="params">(tree **TreeNode, val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    Treetmp := &amp;TreeNode&#123;val, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">nil</span> == *tree &#123;</span><br><span class="line">        *tree = Treetmp</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> val &gt; (*tree).Val &#123;</span><br><span class="line">        createTree(&amp;(*tree).Right, val)</span><br><span class="line">        <span class="keyword">if</span> getMaxDepth((*tree).Right)-getMaxDepth((*tree).Left) &gt;= <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> val &gt; (*tree).Right.Val &#123;</span><br><span class="line">                <span class="comment">//RR</span></span><br><span class="line">                RRTree(tree)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//RL</span></span><br><span class="line">                RLTree(tree)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createTree(&amp;(*tree).Left, val)</span><br><span class="line">        <span class="keyword">if</span> getMaxDepth((*tree).Left)-getMaxDepth((*tree).Right) &gt; <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> val &gt; (*tree).Left.Val &#123;</span><br><span class="line">                <span class="comment">//LR</span></span><br><span class="line">                LRTree(tree)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//LL</span></span><br><span class="line">                LLTree(tree)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇使用go语言实现二叉树&lt;/p&gt;
&lt;h1 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h1&gt;&lt;h2 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="go" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/go/"/>
    
    
  </entry>
  
  <entry>
    <title>概述（2）</title>
    <link href="http://yoursite.com/2019/02/17/goGoroutine/"/>
    <id>http://yoursite.com/2019/02/17/goGoroutine/</id>
    <published>2019-02-17T14:24:47.000Z</published>
    <updated>2019-03-18T12:24:22.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发关键字go"><a href="#并发关键字go" class="headerlink" title="并发关键字go"></a>并发关键字go</h2><p>  GoLang 使用go 关键字进行多并发操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example 1</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//example 2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> hello()</span><br></pre></td></tr></table></figure><h2 id="同步操作-channel"><a href="#同步操作-channel" class="headerlink" title="同步操作: channel"></a>同步操作: channel</h2><p>GoLang 使用Channels 进行多个协程之间进行同步操纵，它更像是一个管道，发送值到管道，再从值取回来</p><h2 id="等待channel-操作-select"><a href="#等待channel-操作-select" class="headerlink" title="等待channel 操作 : select"></a>等待channel 操作 : select</h2><p>go 与 channel 结合select 是一个强大的工作<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">  c1 &lt;- <span class="string">"hello"</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">  c2 &lt;- <span class="string">"world"</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> index := <span class="number">0</span>; index &lt; <span class="number">2</span>; index++ &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> msg1 := &lt;-c1:</span><br><span class="line">    fmt.Println(<span class="string">"the msg1 value is : "</span>, msg1)</span><br><span class="line">  <span class="keyword">case</span> msg2 := &lt;-c2:</span><br><span class="line">    fmt.Println(<span class="string">"the msg2 value is : "</span>, msg2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="timeer"><a href="#timeer" class="headerlink" title="timeer"></a>timeer</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只执行指定时间 一次</span></span><br><span class="line">mytime:=time.NewTimer(time.second)</span><br><span class="line">&lt;-mytime.C</span><br><span class="line">mytime.stop()</span><br></pre></td></tr></table></figure><h3 id="ticker"><a href="#ticker" class="headerlink" title="ticker"></a>ticker</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myticker:=time.NewTicker(time.second)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  &lt;-myticker.C</span><br><span class="line">  fmt.Println(time.now())</span><br><span class="line">&#125;</span><br><span class="line">myticker.stop()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;并发关键字go&quot;&gt;&lt;a href=&quot;#并发关键字go&quot; class=&quot;headerlink&quot; title=&quot;并发关键字go&quot;&gt;&lt;/a&gt;并发关键字go&lt;/h2&gt;&lt;p&gt;  GoLang 使用go 关键字进行多并发操作&lt;/p&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="go" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/go/"/>
    
    
  </entry>
  
  <entry>
    <title>概述（1）</title>
    <link href="http://yoursite.com/2019/02/17/gonovice/"/>
    <id>http://yoursite.com/2019/02/17/gonovice/</id>
    <published>2019-02-17T04:03:45.000Z</published>
    <updated>2019-03-18T12:20:08.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h3> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name nametype</span><br><span class="line"><span class="comment">// for example </span></span><br><span class="line"><span class="keyword">var</span> myvar <span class="keyword">int</span> /<span class="keyword">float32</span> /<span class="keyword">string</span> /<span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> myvar = <span class="number">12</span> /<span class="number">12.2</span>/<span class="literal">true</span>/<span class="string">"hello"</span> <span class="comment">//infer the var type</span></span><br><span class="line">myvar := <span class="number">12</span> /<span class="number">12.2</span>/<span class="literal">true</span>/<span class="string">"hello"</span> <span class="comment">//must use : operator characteristic</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//pointer</span></span><br><span class="line"><span class="keyword">var</span> name *nametype</span><br><span class="line"></span><br><span class="line"><span class="comment">//切片和数组类似，不过切片比数组支持更多的操作</span></span><br><span class="line"><span class="comment">//你可以将其理解为数量不等的集合</span></span><br><span class="line"><span class="comment">//申请0个空间是一种位置，随后使用的时候，可以在进行申请空间</span></span><br><span class="line"><span class="comment">//相对而言，slice更加方便一些</span></span><br><span class="line"><span class="comment">//array</span></span><br><span class="line"><span class="keyword">var</span> arrayname [][]<span class="keyword">int</span> /<span class="keyword">float32</span>/<span class="keyword">string</span> /<span class="keyword">bool</span></span><br><span class="line"><span class="comment">//slices</span></span><br><span class="line">silces:=<span class="built_in">make</span>(<span class="keyword">type</span>,length)</span><br><span class="line"><span class="comment">//map dictionary</span></span><br><span class="line">mapName:=<span class="built_in">make</span>(<span class="keyword">map</span>[key-<span class="keyword">type</span>]value-<span class="keyword">type</span>)</span><br></pre></td></tr></table></figure><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><p>控制结构只有三种形式：</p><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> [[initialize][;condition;][caculate]]&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if-条件"><a href="#if-条件" class="headerlink" title="if 条件"></a>if 条件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [initialize ;][condition]&#123;</span><br><span class="line"></span><br><span class="line">&#125;[<span class="keyword">else</span> <span class="keyword">if</span>&#123;&#125;][<span class="keyword">else</span>&#123;&#125;]</span><br></pre></td></tr></table></figure><h3 id="switch-条件"><a href="#switch-条件" class="headerlink" title="switch 条件"></a>switch 条件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> [condition] &#123;</span><br><span class="line">    <span class="keyword">case</span> [result[condition]]:</span><br><span class="line">        [<span class="keyword">break</span>]</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        [<span class="keyword">break</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>通过for 循环语句是使用关键字range 遍历数组/切片/map<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> [key/index[_]] ,value :=<span class="keyword">range</span> mapvar&#123;</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">    <span class="comment">//execute some statement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数声明形式<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> [<span class="title">funName</span>]<span class="params">()</span> <span class="title">return</span>-<span class="title">type</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据函数形式大致为了以下几种：</p><h3 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plus</span><span class="params">(a,b <span class="keyword">int</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可变参数函数"><a href="#可变参数函数" class="headerlink" title="可变参数函数"></a>可变参数函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//example</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums ...<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Print(nums, <span class="string">" "</span>)</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        total += num</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(total)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example </span></span><br><span class="line">fmt.Println(<span class="string">"the return value is : "</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="number">4</span> &#125;())</span><br></pre></td></tr></table></figure><h3 id="闭包函数"><a href="#闭包函数" class="headerlink" title="闭包函数"></a>闭包函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initSqu</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span><span class="title">int</span></span> &#123;</span><br><span class="line">    i:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span><span class="title">int</span></span>&#123;</span><br><span class="line">        i++</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//to use </span></span><br><span class="line">nextInit:=initSqu()</span><br><span class="line">nextInit() <span class="comment">//1</span></span><br><span class="line">nextInit() <span class="comment">//2</span></span><br><span class="line"><span class="comment">//because they hava function address</span></span><br></pre></td></tr></table></figure><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//recusion</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factorial</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span>==n &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n*factorial(n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//to use</span></span><br><span class="line">fmt.<span class="built_in">println</span>(<span class="string">"the factorial value is : "</span>,factorial(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><h2 id="结构体与方法-接口"><a href="#结构体与方法-接口" class="headerlink" title="结构体与方法/接口"></a>结构体与方法/接口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">type</span> geometry <span class="keyword">interface</span> &#123;</span><br><span class="line">    area() <span class="keyword">float64</span></span><br><span class="line">    perimeter() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//example </span></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="keyword">type</span> rect <span class="keyword">struct</span>&#123;</span><br><span class="line">    width,height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> circle stuct&#123;</span><br><span class="line">    radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r.width*r.hight</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">perimeter</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r.width*<span class="number">2</span> + r.hight*<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span> <span class="title">area</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> math.Pi * c.radius * c.radius</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span> <span class="title">perimeter</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * math.Pi * c.radius</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//to use </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">measure</span><span class="params">(g geometry)</span></span>&#123;</span><br><span class="line">    fmt.Println(g.area())</span><br><span class="line">    fmt.Println(g.perimeter())</span><br><span class="line">&#125;</span><br><span class="line">rcValue:=rect&#123;<span class="number">12</span>,<span class="number">2</span>&#125;</span><br><span class="line">measure(rcValue)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h2&gt;&lt;h3 id=&quot;变量-1&quot;&gt;&lt;a href=&quot;#变量-1&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h3&gt; &lt;
      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="go" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/go/"/>
    
    
  </entry>
  
  <entry>
    <title>生活小记</title>
    <link href="http://yoursite.com/2019/02/16/life_record1/"/>
    <id>http://yoursite.com/2019/02/16/life_record1/</id>
    <published>2019-02-16T00:38:45.000Z</published>
    <updated>2019-02-25T15:04:29.614Z</updated>
    
    <content type="html"><![CDATA[<p>2019 / 2 / 16  乌鲁木齐机场</p><p>打开电脑随手写下了这篇文章，就想到哪写到哪了</p><hr><p>[ 02 / 16 上午]</p><p>与昨日，我与母亲倾诉了内心的想法：我到底改往何方</p><p>母亲回了我一句：去年我曾劝过你，留在事业单位，现在你后悔嘛</p><p>我愣了一下</p><hr><p>[ 02 / 15 下午]</p><p>在乌市出发前碰到了我儿时的同学 【张】</p><p>于是开玩笑道：给我5元钱，我帮你承担 [考研] 成绩的压力</p><p>晚上，我们在一起吃了个饭，我问他想去哪</p><p>他话语间流露，想要出去走走，不想呆在新疆了，他说这个地方他呆够了，现在他特别想到处逛逛</p><p>“你准备在成家？”</p><p>他说：“在江苏吧，也许其他地方…”</p><p>晚上的《流浪地球》挺好看的</p><hr><p>晚上，继昨天一样，失眠了</p><p>我已经不记得儿时曾经发过什么誓言，想要成为什么样的人</p><p>我也不知道我是不是成为了自己讨厌的人</p><p>. . .</p><hr><p>今年我26 ，而我的路，我不知道该向哪里</p><p>甚至看书，有时候都在发呆</p><p>我不知道您是否被这么一句话所影响 :  走正确的路</p><p>什么是正确的路啊</p><p>蒙上眼睛，走那个方向都是前方</p><p>. . .</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2019 / 2 / 16  乌鲁木齐机场&lt;/p&gt;
&lt;p&gt;打开电脑随手写下了这篇文章，就想到哪写到哪了&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[ 02 / 16 上午]&lt;/p&gt;
&lt;p&gt;与昨日，我与母亲倾诉了内心的想法：我到底改往何方&lt;/p&gt;
&lt;p&gt;母亲回了我一句：去年我曾劝过你，留在事业
      
    
    </summary>
    
      <category term="个人生活" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>求二叉树的路径和(path sum)</title>
    <link href="http://yoursite.com/2018/12/10/task-shchedule-weight/"/>
    <id>http://yoursite.com/2018/12/10/task-shchedule-weight/</id>
    <published>2018-12-10T06:36:12.000Z</published>
    <updated>2019-03-03T13:21:05.977Z</updated>
    
    <content type="html"><![CDATA[<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p><p>Note: A leaf is a node with no children.</p><p>Example:</p><p>Given the below binary tree and sum = 22,<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      <span class="number">5</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">4</span>   <span class="number">8</span></span><br><span class="line">   /   / \</span><br><span class="line">  <span class="number">11</span>  <span class="number">13</span>  <span class="number">4</span></span><br><span class="line"> /  \      \</span><br><span class="line"><span class="number">7</span>    <span class="number">2</span>      <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</p><hr><p>看到这道题，嗯~ </p><p>其实我锁定的本题的字眼在 “root-to-leaf”，这就是说明，至少你要从根节点一直遍历到叶节点为止。讲所有的叶节点遍历完之后，也就得到了多少个答案，然后从答案中筛选出预期的结果。</p><p>遍历的图比较好的方式一般使用递归的方式，因为迭代会使程序写法变得复杂~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calcuSum</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">nullptr</span> != root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span>!=root-&gt;left&amp;&amp;root-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">          calcuSum(root-&gt;left, sum + root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> != root-&gt;right&amp;&amp;root-&gt;left==<span class="literal">nullptr</span>)</span><br><span class="line">          calcuSum(root-&gt;right, sum + root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> != root-&gt;left&amp;&amp;<span class="literal">nullptr</span> != root-&gt;right) &#123;</span><br><span class="line">          calcuSum(root-&gt;left, sum + root-&gt;val);</span><br><span class="line">          calcuSum(root-&gt;right, sum + root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == root-&gt;left&amp;&amp;<span class="literal">nullptr</span> == root-&gt;right) &#123;</span><br><span class="line">          <span class="comment">//or calcuSum(root-&gt;right, sum + root-&gt;val);</span></span><br><span class="line">          calcuSum(root-&gt;left, sum + root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.insert(sum);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span>==root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        calcuSum(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(result.find(sum)!=result.end())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据鄙人的解题思路~ 写出上了以上代码~</p><p>上诉考虑到了容器的选择，我使用了set容器，主要是考虑从查找效率上。其实容器也可以选择vector，这个影响不是很大。</p><hr><p>有了上诉题目的引子~</p><p>根据查找的结果，显示出路径来，题目如下：</p><p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p><p>Note: A leaf is a node with no children.</p><p>Example:</p><p>Given the below binary tree and sum = 22,<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">      <span class="number">5</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">4</span>   <span class="number">8</span></span><br><span class="line">   /   / \</span><br><span class="line">  <span class="number">11</span>  <span class="number">13</span>  <span class="number">4</span></span><br><span class="line"> /  \    / \</span><br><span class="line"><span class="number">7</span>    <span class="number">2</span>  <span class="number">5</span>   <span class="number">1</span></span><br><span class="line">Return:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">   [<span class="number">5</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>],</span><br><span class="line">   [<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>这道题和上一题一样的，不同的是，我们需要记录路径了，路径怎么记录~</p><p>这时候，我们可以使用容器vector&lt;&gt;，然后利用形参的copy作用，讲所有root-to-leaf路径存储起来，我们只需要将上面例子的int num,换成vector<int>就行了，然后将这个值存储起来即可~~~</int></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the
      
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>路由器数据层</title>
    <link href="http://yoursite.com/2018/12/09/router-data-plane/"/>
    <id>http://yoursite.com/2018/12/09/router-data-plane/</id>
    <published>2018-12-09T09:10:21.000Z</published>
    <updated>2019-03-18T14:49:19.652Z</updated>
    
    <content type="html"><![CDATA[<p>网络层有两个关键的功能</p><ul><li><p><strong>转发</strong></p><p>当一个数据包到达输入端口时，router 移动数据包到合适的输出端口</p></li><li><p><strong>路由</strong></p><p>在整个网络中，局域网/广域网等 数据包从源地址到目的路之间的传输路径，而路径的选择时路由，一般路由可能时路由算法控制，或者手动设置</p></li></ul><p>本篇重点放在路由器转发上面</p><h2 id="router-component"><a href="#router-component" class="headerlink" title="router component"></a>router component</h2><ul><li><p><strong>input   ports</strong></p><p> 执行物理层/链路层功能，同时还会执行检索功能对输入的数据进行检索，然后输出到合适的 output ports</p></li><li><p><strong>output  ports</strong></p><p>存储从switch fabric 处过来的数据包，然后转发这些这些数据包到出口[outgoing link：链接到链路层和物理层]</p></li><li><p><strong>switch  fabric</strong></p><p>  连接 input port 和output port</p></li><li><p>routing processor</p><p>执行control-plane 功能，一般用于路由协议</p></li></ul><h2 id="forward-based-information"><a href="#forward-based-information" class="headerlink" title="forward based information"></a>forward based information</h2><p>一般来说，转发大致基于两种情况</p><ul><li><p><strong>基于目的IP</strong></p><p>  此种方式根据数据包目的IP，然后对照路由表，选择合适的输出端口</p></li><li><p><strong>基于全部信息</strong></p><p>  相对的，此种方式就不仅仅依据目的IP了，与此同时参考的信息还会有：源目的、网络拥塞状态等</p></li></ul><h2 id="switch-fabric"><a href="#switch-fabric" class="headerlink" title="switch fabric"></a>switch fabric</h2><p>switch fabric是路由器的核心，数据包从input port 穿过switch fabric 然后到 output port ，switch fabric 有一下几种实现方式</p><ul><li><p>switching via memory</p><p>  传统的router实现方式，数据包从input port 到达之后，通过中断的方式通知 router processor，然后共享内存复制数据包到合适的output ports buffers</p></li><li><p>switching via bus</p><p>  input port 直接通过bus 传输数据包到output port,由于bus只有一条，因此不能同时传输数据，转发速度受制于bus的转发速度</p></li><li><p>switching via an interconnection network</p><p>  interconnection network 使用cross-bar 的方式，这就意味着N-N的转发方式</p></li></ul><h2 id="queue-delay"><a href="#queue-delay" class="headerlink" title="queue  delay"></a>queue  delay</h2><p>无论是input port 还是output port 都会发生queue delay ,也就是wait的意思</p><ul><li><p>input port queue</p><p> 当switch fabric 处理速度赶不上 input port 速度的时候</p></li><li><p>output port queue</p><p>多个数据包被转发到相同的output ports，当output ports buffer 满了的时候，就会发生packet drop 事件</p></li></ul><h2 id="outgoing-link-packet-schedule"><a href="#outgoing-link-packet-schedule" class="headerlink" title="outgoing link packet schedule"></a>outgoing link packet schedule</h2><ul><li><p>FIFO</p><p>最先进入queue的数据包最新被转发出去</p></li><li><p>priority</p><p>根据优先级/权重对数据包进行分类[class i]，然后循环遍历classes,输出queue 中的数据包</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网络层有两个关键的功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;转发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当一个数据包到达输入端口时，router 移动数据包到合适的输出端口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;路由&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在整个
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>android NDK</title>
    <link href="http://yoursite.com/2018/12/05/android-NDK/"/>
    <id>http://yoursite.com/2018/12/05/android-NDK/</id>
    <published>2018-12-05T08:59:50.000Z</published>
    <updated>2019-03-18T12:20:00.658Z</updated>
    
    <content type="html"><![CDATA[<p>最近维护了公司的一个JNI项目，面向java/android平台使用，有幸接触了Java/Android 平台与c/c++ 的交互使用。</p><ul><li>Java 与 c/c++ 交互使用 dll 形式</li><li>Android 与c/C++ 交互使用.so文件格式</li></ul><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p><a href="https://baike.baidu.com/item/JNI/9412164?fr=aladdin" target="_blank">JNI 基础概念</a></p><p><a href="https://www3.ntu.edu.sg/home/ehchua/programming/java/JavaNativeInterface.html" target="_blank">JNI 编程基础</a></p><p><a href="https://developer.android.com/ndk/guides/android_mk?hl=zh-cn" target="_blank">android.mk 编写</a></p><p>假使我认为您已经能够使用c/c++ 编程，基本能够使用android studio的使用，不使用亦可以</p><h2 id="Java-使用dll"><a href="#Java-使用dll" class="headerlink" title="Java 使用dll"></a>Java 使用dll</h2><h3 id="c语言头文件生成"><a href="#c语言头文件生成" class="headerlink" title="c语言头文件生成"></a>c语言头文件生成</h3><ul><li>使用javac javaName.java 生成.class 文件</li><li>使用javah javaName 生成 .h 头文件</li></ul><p><strong>note:</strong> 倘如您的java中有包名，那么退回到包名的根目录，使用以下形式的命令</p><ul><li>javac com\application\javaName.java  生成.class 文件</li><li>avah com.application.javaName 生成 .h 头文件</li></ul><p>如下图<br><img src="java_h.png" alt=""></p><p>本实验的代码：</p><ul><li><p>jni_md.h /jni.h 文件在安装的JDK进行提供</p></li><li><p>MainJava.java</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainJava</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"MainJava"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">printTest</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> MainJava().printTest());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MainJava.h</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"jni.h"</span></span></span><br><span class="line"><span class="comment">/* Header for class MainJava */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_MainJava</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_MainJava</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Class:     MainJava</span></span><br><span class="line"><span class="comment">* Method:    printTest</span></span><br><span class="line"><span class="comment">* Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_MainJava_printTest</span><br><span class="line">(JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li>MainJava.c</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"MainJava.h"</span></span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_MainJava_printTest</span><br><span class="line">  (JNIEnv *env, jobject thisobj)&#123;</span><br><span class="line">      <span class="keyword">return</span> (*env)-&gt;NewStringUTF(env,<span class="string">"this is c level"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>makefile</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">RESULT=MainJava.dll</span><br><span class="line">CFLAG= -Wall -shared</span><br><span class="line">source=*.c</span><br><span class="line"></span><br><span class="line"><span class="variable">$(RESULT)</span>:<span class="variable">$(source)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAG)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    del <span class="variable">$(RESULT)</span></span><br></pre></td></tr></table></figure><h2 id="Android使用-so-文件"><a href="#Android使用-so-文件" class="headerlink" title="Android使用 .so 文件"></a>Android使用 .so 文件</h2><p>生成 .so文件可以使用android studio中的内置的NDK-build ，也可以选择手动生成，我这里使用手动生成。<a href="https://developer.android.google.cn/ndk/downloads/" target="_blank">NDK-build下载</a></p><ul><li>需要将javac/javah 生成的 .h /.c /android.mk application.mk 文件放入jni 文件夹中，然后在此目录中运行ndk-build 命令</li></ul><p>如下图<br><img src="android_h.png" alt=""></p><ul><li>将生成的libs 拷贝到android 项目中的app/libs下面</li><li>在app/build.gradle中加入</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.....</span><br><span class="line">sourceSets&#123;</span><br><span class="line">    main&#123;</span><br><span class="line">        jniLibs.srcDirs=[<span class="string">'libs'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下<br><img src="android_so.png" alt=""></p><h2 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h2><p>对于一些使用底层代码使用c/c++的程序，常常使用这种方式，移植到其他平台上，android/java 作为业务层呈现</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近维护了公司的一个JNI项目，面向java/android平台使用，有幸接触了Java/Android 平台与c/c++ 的交互使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java 与 c/c++ 交互使用 dll 形式&lt;/li&gt;
&lt;li&gt;Android 与c/C++ 交互使用.s
      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="android" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/android/"/>
    
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>TCP 传输机制</title>
    <link href="http://yoursite.com/2018/11/15/TCP-transport-institution/"/>
    <id>http://yoursite.com/2018/11/15/TCP-transport-institution/</id>
    <published>2018-11-15T00:40:55.000Z</published>
    <updated>2019-03-18T14:48:19.750Z</updated>
    
    <content type="html"><![CDATA[<p>说起TCP，第一印象是什么，嗯，可靠，面向连接。面向连接是每一个连接都是独立的。而对于可靠性，我的理解逻辑则按照下面的流程</p><p><img src="dataflow.png" alt=""></p><h2 id="TCP-流控制"><a href="#TCP-流控制" class="headerlink" title="TCP 流控制"></a>TCP 流控制</h2><p>流控制涉及到了TCP中windows size fidld,对于TCP而言，在每一个TCP成功建立的连接都会初始化两个缓冲区，发送缓冲区和接收缓冲区，window size 的字段就是为了防止缓冲区数据溢出从而做出了设置，对于接收者，我们假设有两个变量</p><ul><li>LastByteRead：从缓冲区最后读取的位置</li><li>LastByteRcvd：从缓冲区最后接收数据的位置</li><li>RcvBuffer：缓冲区的大小<br><em>LastByteRcvd-LastByteRead&lt;=RcvBuffer</em></li></ul><p>因而，我们要将通常将window size 设置成 cwnd = RcvBuffer-LastByteRcvd-LastByteRead，从而保证接收缓冲区不被溢出。相应的发送缓冲区 LastByteSent−LastByteAcked≤ cwnd</p><p>运用这一规则，在网络攻击中将windows size的值设置为1，就构成了http slow 攻击。</p><h2 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h2><p>首先大部分TCP拥塞控制时端对端的。相对应的有一个<a href="#网络协助方式">网络协助方式</a>（network-assist）</p><p>如果说流控制是控制避免TCP 缓冲区溢出，那么congestion control 就是在网络状态不好时，对TCP 发送流量进行控制，从而避免大量数据包丢失。</p><p>拥塞控制在TCP数据段中没有相应字段表示，但是还有有一个字段与他相关，那是ACK这个字段，拥塞能控制会根据接收到的ACK情况从而调整他的发送速率。</p><p>在TCP 发送数据过程中有三个阶段：<br><img src="congestion.png" alt="">此图来自《computer networking top to down》</p><p>从上图的状态图可以看到：</p><ul><li>在slow start:一旦正确接收到ack,那么cwnd增长时指数级别的，一旦发生数据超时，拥塞控制状态中，此时cwnd数值除以2。或者接收到3此重复的ACK（超时之前），进入快速重传阶段。</li><li>拥塞控制：在这个阶段，cwnd数据增长就比较慢了，由于各个平台实现TCP差异，但是总的原则不会变，他增长速率，同样的在这个状态下，一旦发送超时，或者ACK重复的情况，依旧会Cwnd 数值减半</li><li>快速恢复：这个状态不是必要存在的，进入此状态的条件时ACK 重复，此状态结束之后，一般会进入拥塞控制阶段</li></ul><h2 id="TCP-流量竞争"><a href="#TCP-流量竞争" class="headerlink" title="TCP 流量竞争"></a>TCP 流量竞争</h2><p> 一般来说，理想情况下，TCP连接时会平分网络节点的吞吐量的，但是由于每个TCP通过的路径的可能会有所差异，导致的网络状态的波动之类的情况，导致拥塞控制，可能会造成TCP流量的不平均的情况，因而，每个应用程序中TCP的连接数量的不同也会竞争流量，从而导致应用程序得到节点吞吐量不一样。</p><p> 当然UDP 可能就不会出现这种情况，因为不存在拥塞控制这一机制，收到就接收，收不到就收不到。</p><h2 id="网络协助方式"><a href="#网络协助方式" class="headerlink" title="网络协助方式"></a>网络协助方式</h2><p>此种方式时应用网络数据包丢失之类从而造成的拥塞控制对发送者进行一种反馈情况。</p><p>简单来说，TCP end-to-end 拥塞控制的形式，是根据ACK的情况进行判断网络状态，没有任何网络层参与，但是现在网络协助这种方式，是网络层根据网络状态直接将状态信息发送给接收端或者发送端的一种行为。</p><ul><li>网络层反馈给发送者：将网络状态直接发送给发送端</li><li>网络层发聩给接收者，由接收者发送给发送者： 接收端收到网络状态信息后，将此信息与ACK一起发送给发送端</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，TCP一直在处于发展中，目前而言也有类似其他的协议如DCCP(datagram congestion control Protocol)、DCTCP(data center TCP)、QUIC(quick udp internet connection,google 使用)、TFRC(TCP-friendly rate control,传输速率更平稳)、STTP….无论哪一种使用，哪一种更好，不仅仅取决其技术性，也取决社会行，商业性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;说起TCP，第一印象是什么，嗯，可靠，面向连接。面向连接是每一个连接都是独立的。而对于可靠性，我的理解逻辑则按照下面的流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;dataflow.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;TCP-流控制&quot;&gt;&lt;a href=&quot;#TCP-流
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>复路分解与多复路</title>
    <link href="http://yoursite.com/2018/11/13/TCP-IP-demultipexing-multiplexing/"/>
    <id>http://yoursite.com/2018/11/13/TCP-IP-demultipexing-multiplexing/</id>
    <published>2018-11-13T12:37:21.000Z</published>
    <updated>2019-03-18T14:53:02.220Z</updated>
    
    <content type="html"><![CDATA[<p>复路分离与多复路发生在传输层的一种行为。</p><ul><li><p><strong>demultiplexing:</strong></p><p>At the receiving end, the transport layer examines these fields to identify the receiving socket and then directs the segment to that socket. This job of delivering the data in a transport-layer segment to the correct socket is called <strong>demultiplexing</strong></p></li><li><p><strong>multiplexing:</strong></p><p>The job of gathering data chunks at the source host from different sockets, encapsulating each data chunk with header information (that will later be used in demultiplexing) to create segments, and passing the segments to the network layer is called multiplexing</p><p>中文含义</p></li><li><p><strong>复路分离</strong></p><p>在接收端，传输层根据数据段中的头字段特定字段[UDP：源port/目的port、TCP：源IP/port,目的IP/port]对数据帧进行分类，派送到不同的socket通道中，这个过程就是<strong>复路分离</strong></p></li><li><p><strong>多复路</strong></p><p>传输层从上层应用层中不同的应用（socket）接收数据，然后封装成一个数据帧，派送到网络层，这个过程是<strong>多复路</strong></p><p>那么具体流程是什么样的，请见下图</p><p><img src="figure1.1.png" alt=""></p></li></ul><hr><h2 id="怎么看待socket"><a href="#怎么看待socket" class="headerlink" title="怎么看待socket"></a>怎么看待socket</h2><ul><li><strong>socket 是接口</strong></li></ul><p>开发人员如果进行网络编程，使用socket 是不少的，现在比较常见的传输层协议常见TCP,UDP,SCTP,DCCP。socket是传输层与应用层的抽象网络接口，因此网络数据不可能直接通过应用层直接送到网络层，反之亦然，开发人员在应用层对socket拥有一切控制权，但是在传输层只有少量的控制权。</p><ul><li><strong>用socket干什么</strong></li></ul><p>上述所讲，socket 是接口，是建立在应用层和传输层之间的抽象层，因此对于低层的协议/数据，我们丝毫不用关心。举个例子，我们现在使用ftp 协议，我们只需要关系ftp中的对话规则，我怎么知道对话规则，直接找到RFC 文档，找到协议规则。不需要关心这个数据怎么传输到对方的。我们只需要做到知道两件事：<1>我发送了什么 <2> 我接收到了什么。这样看来，使用socket 就像是一个黑匣子，放进去什么东西，出来了什么东西。就是这么简单？ 对，就是这样</2></1></p><hr><h2 id="TCP-和-UDP-建立通信的区别"><a href="#TCP-和-UDP-建立通信的区别" class="headerlink" title="TCP 和 UDP 建立通信的区别"></a>TCP 和 UDP 建立通信的区别</h2><ul><li><p><strong>UDP</strong></p><p>if two UDP segments have different source IP addresses and/or source port numbers, but have the same destination IP address and destination port number, then the two segments will be directed to the same destination process via <strong>the same destination socket</strong>.</p></li><li><p><strong>TCP</strong></p><p>In particular, and in contrast with UDP, two arriving TCP segments with different source IP addresses or source port numbers will (with the exception of a TCP segment carrying the original connectionestablishment request) be <strong>directed to two different sockets</strong></p><p>socket 是跨进程的，是一个系统资源，通过上述两段文字，从字面上看，TCP 是每来一个客户端，便建立一个socket 资源，UDP 则始终是一条socket 接收使用。但是善于利用的人，可针对这些特点，进行恶意的消耗资源</p></li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本文只是针对了TCP/UDP 在网络框架（TCP/IP 5层结构）中一个大概的位置和作用，需要更加进行了解的请移步<a href="https://www.bau.edu.jo/UserPortal/UserProfile/PostsAttach/10617_1870_1.pdf" target="_blank" rel="noopener">computer_network_top_to_down</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;复路分离与多复路发生在传输层的一种行为。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;demultiplexing:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;At the receiving end, the transport layer examines these fie
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
</feed>
