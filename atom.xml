<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>QK</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-09T00:27:56.812Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>lwb</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BOOST.ASIO库</title>
    <link href="http://yoursite.com/2019/04/04/BOOST-ASIO%E5%BA%93/"/>
    <id>http://yoursite.com/2019/04/04/BOOST-ASIO库/</id>
    <published>2019-04-04T14:55:42.000Z</published>
    <updated>2019-04-09T00:27:56.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Asio代表着异步的输入输出，asio库使数据处理成为了可能，异步意味着当操作初始化的时候，初始化程序不需要等待操作的完成，相反，Boost.Asio当操作完成的时候会通知程序，这种方式的优点就是其他操作可以被并发的执行</p><p>Boost.Thread 是另一个并发执行的库，不同之处在于，Boost.Thread 处理程序内部资源，Boost.Asio处理外部资源，举个例子，你需要开发一个时间消耗计算的功能，你运行此功能在一个线程中并且在另一个CPU内核中，Thread允许你使用CPU内核资源，从这个角度看待程序，CPU内核是一个内部资源，如果你想要处理外部资源，你应该使用Boost.Asio库</p><p>网络连接是一个外部资源的例子，如果数据发送或者接收，网卡被告知执行这项操作，对于发送操作，网卡将指向发送缓冲区的数据进行发送，对于接收数据操作，接收缓冲区被填充满时进行接收，因此网卡是一个外部资源对于你的程序而言，他执行操作是独立的，它只需要时间–您可以在程序中使用的时间来执行其他操作，Boost.Asio 允许你更加有效的使用有效的设备通过可并发的能力。</p><p>Boost.Asio利用网络实现发送和接收数据是利用异步的方式，思考异步操作：函数立刻返回，但是没有返回值，这个处理结果在随后的时间给出</p><p>第一步：异步操作开始<br>第二部：程序接到通知当异步操作结束</p><p>由于操作是隔离的，因为这使处理外部资源没有阻塞的进行</p><h1 id="I-O-服务-和-I-O-对象"><a href="#I-O-服务-和-I-O-对象" class="headerlink" title="I/O 服务 和 I/O 对象"></a>I/O 服务 和 I/O 对象</h1><p>程序使用Boost.Asio进行异步数据处理是基于I/O服务和I/O对象，I/O服务是操作系统异步处理数据的抽象接口，I/O对象初始化了异步操作，这两个概念是将任务清晰地分开：1) I/O服务着眼于操作系统API ，2) I/O对象着眼于任务开发者需要去做</p><p>作为Boost.Asio用户，正常来说你不用直接连接I/O服务，I/O服务被I/O服务对象管理，一个I/O服务对象像一个注册器（I/O服务去注册），每一个I/O对象知道它的I/O服务并且通过I/O服务对象处理他的I/O服务</p><p>Boost.Asio 定义boost::asio::io_service,一个对于I/O服务对象单例类，每个程序基于Boost.Asio 中Boost::asio::io_service 的服务对象，这可以是一个全局变量。</p><p>当这仅有一个I/O服务对象类，几个I/O对象类存在，因为I/O 对象是面向任务的，任务需要被类实例化，举个例子，如果数据必须通过TCP/IP发送和接收数据，一个boost::asio::ip::tcp::socket类型的对象被使用，如果数据不得不通过一系列端口异步传输，boost::asio::serrial_port被初始化，如果你想要等待一段时间，你可以使用I/O对象boost::asio::steady_timer</p><p>boost::asio::steady_timer 就像闹钟一样 ，而不是当闹钟ring的时候，等待一个阻塞函数返回，你的程序将被通知，因为boost::asio::steady_timer仅仅是等待一段时间流逝之后，似乎没有外部资源被访问。然而，在这种情况下, 外部资源是操作系统在时间段到期时通知程序的能力，他解放了程序通过创建一个新的线程仅仅是调用一个阻塞函数，因为boost::asio::steady_timer是一个非常简单的I/O对象，他将被引进Boost.Asio</p><p><strong>Note</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">因为一个bug存在Boost.Asio中，以下有些例子可能在clang 无法编译，bug已经在 ticket <span class="number">8835</span>(https:<span class="comment">//svn.boost.org/trac10/ticket/8835),</span></span><br><span class="line"></span><br><span class="line">作为一种解决方法, 如果取代boost::chrono，使用<span class="built_in">std</span>::chrono，你可以编译</span><br></pre></td></tr></table></figure><h2 id="Example-1-Using-boost-asio-steady-timer"><a href="#Example-1-Using-boost-asio-steady-timer" class="headerlink" title="Example 1. Using boost::asio::steady_timer"></a>Example 1. Using boost::asio::steady_timer</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio/io_service.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio/steady_timer.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  io_service ioservice;</span><br><span class="line"></span><br><span class="line">  steady_timer timer&#123;ioservice, <span class="built_in">std</span>::chrono::seconds&#123;<span class="number">3</span>&#125;&#125;;</span><br><span class="line">  timer.async_wait([](<span class="keyword">const</span> boost::system::error_code &amp;ec)</span><br><span class="line">    &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 sec\n"</span>; &#125;);</span><br><span class="line"></span><br><span class="line">  ioservice.run();</span><br><span class="line">  system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Example 1. 创建了一个I/O 服务对象:ioservice,并且用它来初始化I/O对象timer,Like boost::asio::steady_timer, 所有的I/O对象期望一个I/O服务对象作为一个第一个参数在他们的构造器中，因为定时器代表了一个闹钟，第二个参数被传递给了boost::asio::steady_timer对象，该参数定义了是个时间间隔（闹钟过了这个时间会响起），在Example 1. 闹铃被设置成了3秒之后响起，这个时间开始于timer的定义</p><p>而不是定义调用一个当闹铃响起的时候，函数才返回的阻塞函数，Boost.Asio函数让你执行一个异步操作，通过调用成员函数async_wait()做到异步，同时你应该传入一个句柄，这个句柄可以是函数，或者函数对象，当异步操作最后这个句柄对象被调用，Example 1. 传入一个lambda函数。</p><p>async_wait（）立刻返回，而不是等到闹钟响起，lambda函数被调用在3秒之后才返回，当async_wait()返回，程序可以会其他的事情。</p><p>成员函数像async_wait()被调用是非阻塞，I/O对象通常也提供了阻塞的成员函数作为可替换的，举个例子，你可以调用类boost::asio::steady_timer中的成员函数wait()，因为这个成员函数是阻塞的，没有句柄被传入，wait()返回在一个特定的时间或一个时间时隔。</p><p>在main()中的倒数第二句，I/O服务对象的成员函数run()被调用，这个调用是需要的，因为操作系统特定的功能必须接管控制，记住：I/O服务在I/O服务对象中，实现异步操作需要基于操作系统特定功能函数。</p><p>当async_wait()初始化一个异步操作并且立刻返回，run()进行阻塞，很多操作系统通过一个阻塞函数支持异步操作，下面的示例说明了为什么这通常不是问题</p><h2 id="Example-2-Two-asynchronous-operations-with-boost-asio-steady-timer"><a href="#Example-2-Two-asynchronous-operations-with-boost-asio-steady-timer" class="headerlink" title="Example 2. Two asynchronous operations with boost::asio::steady_timer"></a>Example 2. Two asynchronous operations with boost::asio::steady_timer</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio/io_service.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio/steady_timer.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  io_service ioservice;</span><br><span class="line"></span><br><span class="line">  steady_timer timer1&#123;ioservice, <span class="built_in">std</span>::chrono::seconds&#123;<span class="number">3</span>&#125;&#125;;</span><br><span class="line">  timer1.async_wait([](<span class="keyword">const</span> boost::system::error_code &amp;ec)</span><br><span class="line">    &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 sec\n"</span>; &#125;);</span><br><span class="line"></span><br><span class="line">  steady_timer timer2&#123;ioservice, <span class="built_in">std</span>::chrono::seconds&#123;<span class="number">4</span>&#125;&#125;;</span><br><span class="line">  timer2.async_wait([](<span class="keyword">const</span> boost::system::error_code &amp;ec)</span><br><span class="line">    &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"4 sec\n"</span>; &#125;);</span><br><span class="line"></span><br><span class="line">  ioservice.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Example 2. 两个boost::asio::steady_timer被使用，第一个I/O对象是一个在3秒之后响起，第二个闹钟在四秒之后响起，lambda 函数被作为参数传入saync_wait()中被调用。</p><p>在Example 2. 中，I/O服务对象仅仅调用run()，此调用将控制权传递给执行异步操作的操作系统函数，通过他们的帮助，第一个lambda函数在3秒之后被调用，第二个lambda函数在四秒之后被调用。</p><p>异步操作需要调用阻塞函数, 这可能会让人感到意外。然而，这不是一个问题, 因为该程序必须被阻止退出。如果run() 不阻塞，main() 函数将会返回，程序将会推出，如果你不想要等待run()函数返回，你仅仅需要调用函数run()在一个new thread 中</p><p>上面的示例在一段时间后退出的原因是, 如果没有挂起的异步操作, 则会在run()返回之后。一旦所有闹钟都响了, 程序就不存在需要等待的异步操作。</p><h1 id="可扩展性-和-多线程"><a href="#可扩展性-和-多线程" class="headerlink" title="可扩展性 和 多线程"></a>可扩展性 和 多线程</h1><p>开发一个程序基于库像Boost.Asio不同于通常的c++风格，函数可能花费一段时间返回但不是被调用以顺序的方式，不同于调用阻塞函数，Boost.Asio开始一个异步操作，在操作完成后，相应的函数句柄应该被调用，这种方法的缺点是顺序被执行的函数物理隔离，使得代码变得更加难以理解。</p><p>一个库像Boost.Asio典型的被用来实现效率，不需要等待一个操作完成，在此之间，你可以执行其他的任务，因而，这是可能的开始几个异步操作也就就是说，他们是并发的，记住，异步操作通常被用来处理进程外部资源，因此这些外部资源可以是不用的设备，他们之间的工作是独立的并且并发执行操作。</p><p>可伸缩性描述了程序从额外资源中有效受益的能力，借助 Boost.Asio, 可以从外部设备并发执行操作的能力中获益，如果线程被使用，几个函数可以被并行的执行在可得到的CPU内核上。Boost.Asio与thread 用来提高可伸缩性，因为你的程序可以利用内部或者外部设备可以被独立执行或者相互协同的优势。</p><p>如果boost::asio::io_service中成员函数run()被调用，被关联的句柄在同一个线程中被调用。通过利用多线程，程序可以多次调用run()，异步操作完成后, I/O 服务对象将在其中一个线程中执行句柄，如果第二次操作完成在第一个操作不久之后，I/O服务对象可能在可能执行句柄在不同的线程中，现在，不仅进程的外部操作可以被并发操作，而且处理句柄也可以进行并发</p><p>Example 3. Two threads for the I/O service object to execute handlers concurrently</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio/io_service.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio/steady_timer.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  io_service ioservice;</span><br><span class="line"></span><br><span class="line">  steady_timer timer1&#123;ioservice, <span class="built_in">std</span>::chrono::seconds&#123;<span class="number">3</span>&#125;&#125;;</span><br><span class="line">  timer1.async_wait([](<span class="keyword">const</span> boost::system::error_code &amp;ec)</span><br><span class="line">    &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 sec\n"</span>; &#125;);</span><br><span class="line"></span><br><span class="line">  steady_timer timer2&#123;ioservice, <span class="built_in">std</span>::chrono::seconds&#123;<span class="number">3</span>&#125;&#125;;</span><br><span class="line">  timer2.async_wait([](<span class="keyword">const</span> boost::system::error_code &amp;ec)</span><br><span class="line">    &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 sec\n"</span>; &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::thread thread1&#123;[&amp;ioservice]()&#123; ioservice.run(); &#125;&#125;;</span><br><span class="line">  <span class="built_in">std</span>::thread thread2&#123;[&amp;ioservice]()&#123; ioservice.run(); &#125;&#125;;</span><br><span class="line">  thread1.join();</span><br><span class="line">  thread2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>早先的例子已经被转化成了多线程程序 Example 3. 通过std::thread。 main()函数中创建了两个函数，每个线程中run()函数被调用，对于I/O服务而言这是可能的的当异步操作完成时，在不同的线程中执行句柄函数。</p><p>在Example 3. 闹钟都应该在3秒之后ring。 因为两个线程都是可利用的，lambda函数可以被并发的执行，如果第二个闹钟ring第一个闹钟句柄函数正在执行的时候，此时第二个闹钟在另一个线程中被执行，如果第一个闹钟的句柄也已经完成返回，那么第二个闹钟可以在任一个闹钟中执行。</p><p>当然，使用多线程，并不是总是有意义的,Example 3. 标准输出可能并不会顺序输出信息，相反，他们可能是混合的。在连个句柄中，他们可能运行在不同的线程中，分享着相同的全局资源std::cout,为了内部中断，处理std::cout将被同步。如果句柄不能都被并发执行，那么多线程的优点就丧失啦。</p><p>Example 4. One thread for each of two I/O service objects to execute handlers concurrently</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio/io_service.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio/steady_timer.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  io_service ioservice1;</span><br><span class="line">  io_service ioservice2;</span><br><span class="line"></span><br><span class="line">  steady_timer timer1&#123;ioservice1, <span class="built_in">std</span>::chrono::seconds&#123;<span class="number">3</span>&#125;&#125;;</span><br><span class="line">  timer1.async_wait([](<span class="keyword">const</span> boost::system::error_code &amp;ec)</span><br><span class="line">    &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 sec\n"</span>; &#125;);</span><br><span class="line"></span><br><span class="line">  steady_timer timer2&#123;ioservice2, <span class="built_in">std</span>::chrono::seconds&#123;<span class="number">3</span>&#125;&#125;;</span><br><span class="line">  timer2.async_wait([](<span class="keyword">const</span> boost::system::error_code &amp;ec)</span><br><span class="line">    &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 sec\n"</span>; &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::thread thread1&#123;[&amp;ioservice1]()&#123; ioservice1.run(); &#125;&#125;;</span><br><span class="line">  <span class="built_in">std</span>::thread thread2&#123;[&amp;ioservice2]()&#123; ioservice2.run(); &#125;&#125;;</span><br><span class="line">  thread1.join();</span><br><span class="line">  thread2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于Boost.Asio使程序变的更扩展性，一个推荐的方法在一个I/O服务对象中调用run()，而不是在几个线程中调用调用一个I/O服务对象，你可以创建多个I/O服务对象。</p><p>Example 4. 中，每个I/O 服务对象绑定一个I/O对象，他们工作和以前的例子一样。这是不可能的给出什么时候应该使用超出一个I/O服务对象的建议，因为boost::asio::io_service 表示一个操作系统接口，任何决定依赖于特定的接口。</p><p>在windows上，boost::asio::io_service 通常基于IOCP，在linux 基于epoll,有几个I/O服务对象意味着几个完成的端口将被使用或者epoll 将被多次调用，是否比使用一个端口和一个epoll调用更好依赖独立的案例。</p><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>尽管Boost.Asio可以用来处理任何数据的异步曹祖，但它主要被用来进行网络编程，这是因为在I/O对象被增加前，Boost.Asio库网络函数已经存在了，对于异步操作，网络函数是一个完美的使用。因为通过网络传输数据可能花费大量的时间，他意味着ack确认和errors并不是和发送数据和接收数据一样迅速</p><p>Boost.Asio 提供了许多I/O对象用来开发网络编程，Example 5.使用类boost::asio::ip::tcp::socket来与另一台计算机建立连接，本例子中像一个web服务器发送一个http请求进行下载主页。</p><p>Example 5. A Web cliet with boost::asio::ip::tcp::socket</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio/io_service.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio/write.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio/buffer.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio/ip/tcp.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio::ip;</span><br><span class="line"></span><br><span class="line">io_service ioservice;</span><br><span class="line">tcp::resolver resolv&#123;ioservice&#125;;</span><br><span class="line">tcp::socket tcp_socket&#123;ioservice&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">char</span>, 4096&gt; bytes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_handler</span><span class="params">(<span class="keyword">const</span> boost::system::error_code &amp;ec,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="built_in">std</span>::<span class="keyword">size_t</span> bytes_transferred)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!ec)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.write(bytes.data(), bytes_transferred);</span><br><span class="line">    tcp_socket.async_read_some(buffer(bytes), read_handler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect_handler</span><span class="params">(<span class="keyword">const</span> boost::system::error_code &amp;ec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!ec)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> r =</span><br><span class="line">      <span class="string">"GET / HTTP/1.1\r\nHost: theboostcpplibraries.com\r\n\r\n"</span>;</span><br><span class="line">    write(tcp_socket, buffer(r));</span><br><span class="line">    tcp_socket.async_read_some(buffer(bytes), read_handler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resolve_handler</span><span class="params">(<span class="keyword">const</span> boost::system::error_code &amp;ec,</span></span></span><br><span class="line"><span class="function"><span class="params">  tcp::resolver::iterator it)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!ec)</span><br><span class="line">    tcp_socket.async_connect(*it, connect_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcp::resolver::query q&#123;<span class="string">"theboostcpplibraries.com"</span>, <span class="string">"80"</span>&#125;;</span><br><span class="line">  resolv.async_resolve(q, resolve_handler);</span><br><span class="line">  ioservice.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Example 5. 当连接被建立的时候，使用了三个句柄函数： connect_handler() &amp; read_handler() 被调用，并且数据被接收，resolve_handler()用来进行域名解析。</p><p>因为数据仅仅当连接建立的时候才能被接收，并且连接被建立仅仅当域名被解析的时候，多个异步操作在*_handler（）中被开始，在resolve_handler() ，迭代器it ,他指向一个域名解析的终端，被和tcp_socket一起使用建立连接。<br>在connect_handler()函数中，tcp_socke被用来发送一个http请求并且接收数据，因为所有的操作是异步的，依赖于操作，额外的参数可能需要被传递，举个例子，这个迭代器it指向一个域名解析后的终端，the array bytes 被用来存储数据接收。</p><p>在main()函数中，boost::asio::ip::tcp::resolver::query 被初始化一个实例对象q ,q表示一个域名查询，一个boost::asio::ip::tcp::resolver I/O 对象。通过传递q给async__resolver()函数，一个异步操作开始解析域名。Example 5. 解析域名theboostcpplibraries.com ,在一个异步操作开始之后，I/O服务对象run()被调用传递控制权给操作系统。</p><p>当域名被解析之后,resolve_handler()被调用，这个handler首先检查域名是否解析成功,ec==0,然后socket用来建立连接，第二个参数是服务器的地址，是一个boost::asio::ip::tcp::resolver::iterator,这个参数是域名解析的结果。</p><p>调用async_connect()随后调用connect_handle句柄函数，ec又一次的首先检查是否连接建立是否成功，如果成功，async_read_some()在socket被调用。伴随着async_read_some()的调用，读取数据开始，数据被接收存储在数组bytes，他被作为第一参数传递给async_read_some()。</p><p>当一个或者多个字节已经接收到并且复制到数组bytes，read_handler()被调用,参数bytes_transferred是std::size_t类型，表示已经接收到字节的数量。通常来说,*_handler()应该首先检查ec是否异步操作成功完成。只有这种情况，结果才会被写到标准输出中去。</p><p>请留意read_handler（）在数据已经写道std::cout之后又一次的调用async_read_some()，这是需要的，因为在单个异步操作中你不能确保整个主页面被下载并且复制到数组中。重复调用async_read_some()函数随之重复调用read_handler()只有当连接关闭的时候才会结束，他在web server已经发送了整个主页面。之后read_handler()报告一个错误的ec，在这个观点上，没有更多的数据写到std::cout上，并且async_read()不会在被调用。因为这没有了挂起的异步操作，程序退出。</p><p>Example 6. A time server with boost::asio::ip::tcp::acceptor</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio/io_service.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio/write.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio/buffer.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio/ip/tcp.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio::ip;</span><br><span class="line"></span><br><span class="line">io_service ioservice;</span><br><span class="line">tcp::endpoint tcp_endpoint&#123;tcp::v4(), <span class="number">2014</span>&#125;;</span><br><span class="line">tcp::acceptor tcp_acceptor&#123;ioservice, tcp_endpoint&#125;;</span><br><span class="line">tcp::socket tcp_socket&#123;ioservice&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_handler</span><span class="params">(<span class="keyword">const</span> boost::system::error_code &amp;ec,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="built_in">std</span>::<span class="keyword">size_t</span> bytes_transferred)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!ec)</span><br><span class="line">    tcp_socket.shutdown(tcp::socket::shutdown_send);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept_handler</span><span class="params">(<span class="keyword">const</span> boost::system::error_code &amp;ec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!ec)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">time_t</span> now = <span class="built_in">std</span>::time(<span class="literal">nullptr</span>);</span><br><span class="line">    data = <span class="built_in">std</span>::ctime(&amp;now);</span><br><span class="line">    async_write(tcp_socket, buffer(data), write_handler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcp_acceptor.listen();</span><br><span class="line">  tcp_acceptor.async_accept(tcp_socket, accept_handler);</span><br><span class="line">  ioservice.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Example 6. 是一个时间服务器，你可以与一个telnet client连接获取当前时间，之后关闭time server</p><p>time server使用 I/O对象 boost::asio::ip::tcp::acceptor 接受一个来自其他程序的连接请求。你必须初始化这个对象以至于他知道是什么协议运行在那个端口上。在例子中，boost::asio::ip::tcp::endpoint 的类对象tcp_endpoint被用来告知tcp_acceptor接受一个版本为4的网络协议，端口为2014的连接请求。</p><p>在acceptor 被初始化，listen() 被调用使acceptor开始监听。然后async_accept()被调用用来接收第一个连接请求，一个socket被作为第一个参数传递给async_accept()，它被用来发送和接收数据在一个新的连接上。</p><p>一旦另一个建立连接，accept_handler()被调用，如果调用成功，当前时间被发送通过boost::asio::async_write(),这个函数写所有数据到socket，boost::asio::ip::tcp::socket 也提供了一个成员函数async_write_some()。当至少有一个字节发送，此函数调用handler，然后handler必须先检查多少字节需要发送并且多少字节仍需要发送，之后又一次的调用async_write_some(),重复计算剩下的字节并且async_write_some()可以被避免被调用通过使用boost::asio::async_write()，这个函数开始异步操作仅仅当所有的数据全部被发送才完成。</p><p>在数据已经发送之后，write_handler()被调用，这个函数调用shutdown()传入参数boost::asio::ip::tcp::socket::shutdown_send,也就是说数据已经用过socket发送完了数据。因此这没有了挂起的异步操作。Example 6. 程序退出。 请留意，虽然data仅仅在accept_handler()中使用，但是它并不是一个局部变量。从boost::asio::buffer()到boost::asio::async_write()使用引用的方式传递data，当boost::asio::async_write()和accept_handler()返回的时候，异步操作已经开始，但是还没有结束，data必须存在直到异步操作完成，如果data 是一个全局变量，这将是一个有效的保证。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>开发一个客户端和服务端，它可以传输一个文件从一个计算机到另一个，当服务端的开始的时候，他应该罗列并显示所有本地网卡上所有IP,并且等待一个客户端连接，当客户端开始的时候，命令行选项包括服务器地址，本地文件名。客户端应该传输文件给服务端，服务端保存文件到当前目录下。在传输过程中，客户端应该显示文件传输的进度，以至于用户能够知道文件传输的进度，实现客户端和服务端以回调的方式。</p><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><!-- ## 参考资料> - []()> - []() -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Asio代表着异步的输入输出，asio库使数据处理成为了可能，异步意味着当操作初始化的时候，初始化程序不需要等待操作的完成，相反，Boost
      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="cpp" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/cpp/"/>
    
      <category term="boost库" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/cpp/boost%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>goGetURL简单开始</title>
    <link href="http://yoursite.com/2019/04/03/goGetURL%E7%AE%80%E5%8D%95%E5%BC%80%E5%A7%8B/"/>
    <id>http://yoursite.com/2019/04/03/goGetURL简单开始/</id>
    <published>2019-04-03T10:06:28.000Z</published>
    <updated>2019-04-04T03:25:40.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="页面爬取与解析"><a href="#页面爬取与解析" class="headerlink" title="页面爬取与解析"></a>页面爬取与解析</h1><p>先上简单的示例<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/xml"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"golang.org/x/net/html"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> per <span class="keyword">struct</span> &#123;</span><br><span class="line">XMLName xml.Name <span class="string">`xml:"div"`</span></span><br><span class="line">Name    []<span class="keyword">string</span> <span class="string">`xml:"p"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">resp, err := http.Get(<span class="string">"https://wbleigk.github.io/about/"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"error"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"><span class="comment">//io.Copy(os.Stdout, resp.Body)</span></span><br><span class="line">doc, _ := html.Parse(resp.Body)</span><br><span class="line"></span><br><span class="line">re := visit(<span class="literal">nil</span>, doc)</span><br><span class="line">parseXML(strings.Join(re, <span class="string">""</span>), per&#123;&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">visit</span><span class="params">(links []<span class="keyword">string</span>, n *html.Node)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == <span class="string">"div"</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, a := <span class="keyword">range</span> n.Attr &#123;</span><br><span class="line"><span class="keyword">if</span> a.Key == <span class="string">"class"</span> &amp;&amp; a.Val == <span class="string">"article-entry"</span> &#123;</span><br><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">w := io.Writer(&amp;buf)</span><br><span class="line">html.Render(w, n)</span><br><span class="line"><span class="comment">//fmt.Println(buf.String())</span></span><br><span class="line">links = <span class="built_in">append</span>(links, buf.String())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> c := n.FirstChild; c != <span class="literal">nil</span>; c = c.NextSibling &#123;</span><br><span class="line">links = visit(links, c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> links</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseXML</span><span class="params">(content <span class="keyword">string</span>, v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">perR := v.(per)</span><br><span class="line">xml.Unmarshal([]<span class="keyword">byte</span>(content), &amp;perR)</span><br><span class="line"><span class="keyword">for</span> _, elem := <span class="keyword">range</span> perR.Name &#123;</span><br><span class="line">fmt.Println(elem)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现步骤：</p><p>1、http.Get() 抓取网页相应页面</p><p>考虑到网页延迟的情况，可以增加WaitForServer函数<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WaitForServer</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> timeout = <span class="number">1</span> * time.Minute</span><br><span class="line">deadline := time.Now().Add(timeout)</span><br><span class="line"><span class="keyword">for</span> tries := <span class="number">0</span>; time.Now().Before(deadline); tries++ &#123;</span><br><span class="line">_, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// success</span></span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"server not responding (%s); retrying..."</span>, err)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"server %s failed to respond after %s"</span>, url, timeout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、抓取的内容送到html包中解析html.Parse() 解析出html tag node</p><p>3、处理html.Node 节点，索引处自己想要的内容，这一部分，你需要自己对照原始页面对应html内容，看看对自己有兴趣的Node tag,将这一部分保存下来，作为返回值进行处理</p><p>4、将感兴趣的内容处理之后，之后使用xml encode 解码，将自己想要的内容转为了自己想要的内容</p><h1 id="模板数据转化"><a href="#模板数据转化" class="headerlink" title="模板数据转化"></a>模板数据转化</h1><p>当你从网页上抓取了你想要的数据之后，那么你需要做出一个模板报告</p><p>模板转化，这一部分是让golang 内部数据转化成模板（doc/html）中的模板</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"text/template"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//!+template</span></span><br><span class="line"><span class="keyword">const</span> templ = <span class="string">`</span></span><br><span class="line"><span class="string">Total :&#123;&#123;.Total&#125;&#125;</span></span><br><span class="line"><span class="string">----------------------------------------</span></span><br><span class="line"><span class="string">&#123;&#123;range .Item&#125;&#125;</span></span><br><span class="line"><span class="string">Number: &#123;&#123;.Number&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> report = template.Must(template.New(<span class="string">"test"</span>).Parse(templ))</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Re <span class="keyword">struct</span> &#123;</span><br><span class="line">Total <span class="keyword">int</span></span><br><span class="line">Item  []Item</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">Number <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// reR := Re&#123;Total: 2, Number: []Item&#123;&#123;"1"&#125;, &#123;"2"&#125;, &#123;"3"&#125;&#125;&#125;</span></span><br><span class="line">reR := Re&#123;Total: <span class="number">2</span>, Item: []Item&#123;&#123;<span class="string">"1"</span>&#125;, &#123;<span class="string">"2"</span>&#125;, &#123;<span class="string">"3"</span>&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := report.Execute(os.Stdout, reR); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// Total :2</span></span><br><span class="line"><span class="comment">// ----------------------------------------</span></span><br><span class="line"><span class="comment">// Number: 1</span></span><br><span class="line"><span class="comment">// Number: 2</span></span><br><span class="line"><span class="comment">// Number: 3</span></span><br></pre></td></tr></table></figure><!-- ## 参考资料> - []()> - []() -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;页面爬取与解析&quot;&gt;&lt;a href=&quot;#页面爬取与解析&quot; class=&quot;headerlink&quot; title=&quot;页面爬取与解析&quot;&gt;&lt;/a&gt;页面爬取与解析&lt;/h1&gt;&lt;p&gt;先上简单的示例&lt;br&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="go" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/go/"/>
    
      <category term="go web" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/go/go-web/"/>
    
    
  </entry>
  
  <entry>
    <title>cpp可变模板variadic_template</title>
    <link href="http://yoursite.com/2019/03/30/cpp%E5%8F%AF%E5%8F%98%E6%A8%A1%E6%9D%BFvariadic-template/"/>
    <id>http://yoursite.com/2019/03/30/cpp可变模板variadic-template/</id>
    <published>2019-03-30T03:51:39.000Z</published>
    <updated>2019-03-30T14:50:26.453Z</updated>
    
    <content type="html"><![CDATA[<p>英文原版：<a href="https://eli.thegreenplace.net/2014/variadic-templates-in-c/#id5" target="_blank" rel="noopener">https://eli.thegreenplace.net/2014/variadic-templates-in-c/#id5</a></p><p>在 C++11 之前, 编写任意数量的参数的函数的唯一方法是使用不同的函数 (如 printf)、省略号语法 (…) 和伴随的 va _ 家族。如果你曾经用这种方法编写过代码, 你就知道它有多麻烦了。除了类型不安全 (所有类型解析都必须在运行时使用 va _ arg 中的强制转换显式完成) 之外, 正确的方法也很棘手。Va _ 宏执行低级内存操作, 我看到了很多代码, 这些代码会对故障进行分段, 因为它没有足够仔细地使用它们。</p><p>但是, 这种方法总是让我最困扰的是, 把一些在编译时清楚地知道的东西留给了运行时。是的, 当我们编写一个可变函数时, 我们不知道它将被使用的所有方式。但当编译器将整个程序放在一起时, 它确实知道。它非常清楚地看到了整个程序中函数的所有调用, 以及它所传递的所有可能的参数类型 (毕竟类型是在 C++ 中的编译时解析的)</p><h1 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h1><p>cpp11其中一个新特征就是可变参数模板，最终他以一种任意参数的类型安全形式并且在编译器处理所有参数逻辑解析来写函数，可变参数模板不仅仅运用在函数上，其他任意数量参数的模板上也行（类 etc）</p><p>#基本例子<br>让我们从实现一个可以加上所有参数的模板函数开始<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">addr</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T ,<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">T <span class="title">addr</span><span class="params">(T first, Args...args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> first + addr(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"int sum is :"</span> &lt;&lt; addr(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">7</span>) &lt;&lt; <span class="built_in">endl</span>;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s1 = <span class="string">"x"</span>, s2 = <span class="string">"aa"</span>, s3 = <span class="string">"bb"</span>, s4 = <span class="string">"yy"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"string sum is :"</span> &lt;&lt; addr(s1, s2, s3, s4) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>addr 将接受任意类型和参数数量的参数，只要参数类型能够执行‘+’操作，这种检查在编译期执行，这没什么魔法-仅仅是遵循了c++中的通用模板和重载方案规则</p><p>typename..Args 可称为 <strong><em>template parameter pack</em></strong> ，Args…args 是 <strong><em>function parameter pack</em></strong> (Args 也完全可以是任意其他名字) 可变模板的编写方式与编写递归代码的方式相似-你需要基函数（addr(T t) 上面的声明）和一个泛型的“递归” ，它用来递归自身，留意泛型定义的addr,第一个参数，template parameter pack 中的参数被放入参数first 总，因为每一次调用，参数包将变得减少一个参数</p><p>为了更加的直观的看到调用过程，我们在泛型函数addr()中插入std::cout&lt;&lt;<strong>PRETTY_FUNCTION</strong> &lt;&lt;std::endl; 语句 [It’s a gcc extension, supported by Clang as well,but msvc do’t work]</p><p>我们执行addr(1,2,3,8,7),将看到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T adder(T, Args...) [T = int, Args = &lt;int, int, int, int&gt;]</span><br><span class="line">T adder(T, Args...) [T = int, Args = &lt;int, int, int&gt;]</span><br><span class="line">T adder(T, Args...) [T = int, Args = &lt;int, int&gt;]</span><br><span class="line">T adder(T, Args...) [T = int, Args = &lt;int&gt;]</span><br><span class="line">T adder(T) [T = int]</span><br></pre></td></tr></table></figure></p><h1 id="一些简单变量"><a href="#一些简单变量" class="headerlink" title="一些简单变量"></a>一些简单变量</h1><p>当阅读c++模板元编程的时候，一个经常听到的词语是“模式匹配”，那么这部分语言如何构成相当完整的编译时函数语言</p><p>上诉的例子已经给我们展示了基本的使用-模板参数通过一个一个脱落展开的直到碰到基函数，下面将展示一个更有趣的模式配置例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> First ,<span class="keyword">typename</span> Second&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LWBcompare</span><span class="params">(First f, Second s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> f == s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Base, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LWBcompare</span><span class="params">(Base first, Base second, Args...args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> first == second &amp;&amp; compare(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LWBcompare<br> 接受任意数量的参数，并且返回bool，类型不是强制性的，一切都可以被比较，比如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LWBcompare(<span class="number">1.5</span>, <span class="number">1.5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure></p><p>返回true，但是当我们改变第二个参数的时候为1的时候，则会编译失败，因为doubl和int 不是同一类型</p><p>更有趣的是，LWBcompare仅仅执行在偶数参数的时候，因为他们参数解包的时候是成对的，因此奇数个参数的时候会导致编译失败，我们添加1个可变参数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LWBcompare</span><span class="params">(T a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里，我们定义了所有的奇数个参数返回false，因为最终的解包的时候，只剩下一个参数，基函数只能配置这个函数。</p><p>需要留意的是，例子中LWBcompare 强制比较参加比较的类型需要是相同的类型，但是只要类型之间是课比较的，就能够调用此函数。</p><h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>如果你担心依赖可变参数的代码执行性能，这是没有必要，实际上没有发生递归调用，所有的一系列函数都在编译期产生之后调用的，这些函数实际上相当短（一般可变参数不超过5-6个），因此编译器会内联产生的代码，它很可能最终被编译为完全没有函数调用的机器代码。实际上, 你最终得到的并不像循环展开</p><p>相比较c-style 可变参数函数，cpp 性能更好，因为c-style 可变参数模板必须在运行时解析，va_ 宏被逐字操作在运行栈，因此，可变参数模板对可变参数函数来说，通常来说是性能优化的</p><h1 id="类型安全的可变参数函数"><a href="#类型安全的可变参数函数" class="headerlink" title="类型安全的可变参数函数"></a>类型安全的可变参数函数</h1><p>在文章的开始提到了函数 printf 作为一个可变参数函数，没有使用模板，然而，我们知道printf 并不是一个类型安全的，printf同类型的函数也不是类型安全的，如哦你传递一个数字进入一个%s格式，糟糕的结果可能会发生，因为编译器并不会对你进行警告。</p><p>这是很明显的，可变参数模板使我们能够写出类型安全的函数，这printf 这个例子中，当实现到达新的格式指令时, 它实际上可以断言传递的参数的类型，这种断言不会在编译时触发, 但它会触发–并且可以生成一个很好的错误消息, 而不是未定义的行为</p><h1 id="可变参数数据结构"><a href="#可变参数数据结构" class="headerlink" title="可变参数数据结构"></a>可变参数数据结构</h1><p>传统数据结构[structs since the times of C and calsses in c++]在编译期定义了字段，它们可以表示在运行时增长的类型 (例如 std:: 向量), 但如果要添加新字段, 这是编译器必须看到的，可变参数模板使这种限制成为了可能，让数据结构可以有任意个字段，每次使用拥有初始化的的字段数量，一个很好的例子是tuple类，因此，下面将演示如何构造这个一个数据结构。</p><p>完整代码路径: <a href="https://github.com/eliben/code-for-blog/blob/master/2014/variadic-tuple.cpp" target="_blank" rel="noopener">variadic-tuple</a></p><p>首先让我们开始定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Ts</span>&gt; <span class="title">struct</span> <span class="title">tuple</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tuple</span>&lt;T, Ts...&gt; :</span> tuple&lt;Ts...&gt; &#123;</span><br><span class="line">  tuple(T t, Ts... ts) : tuple&lt;Ts...&gt;(ts...), tail(t) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  T tail;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>我们以基本情况-类模板tuple的定义,他是空的，特化则进行参数包的解包，并且定义了一个成员类型，用于接收这个类型，也用于接收剩下的类型，这个架构的基类是一个空tuple，为了得到了更好的理解，让我们举个具体的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="keyword">double</span> ,<span class="keyword">uint64_t</span>,<span class="keyword">const</span> <span class="keyword">char</span>*&gt; t1(<span class="number">122</span>,<span class="number">42</span>,<span class="string">"big"</span>);</span><br></pre></td></tr></table></figure><p>先忽略构造函数，这有一个tuple的伪代码-过程 构造</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tuple</span>&lt;double, uint64_t, const char*&gt; :</span> tuple&lt;<span class="keyword">uint64_t</span>, <span class="keyword">const</span> <span class="keyword">char</span>*&gt; &#123;</span><br><span class="line">  <span class="keyword">double</span> tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tuple</span>&lt;uint64_t, const char*&gt; :</span> tuple&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; &#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tuple</span>&lt;const char*&gt; :</span> tuple &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tuple</span> &#123;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原始3元素元组中的数据成员的布局将是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">const</span> <span class="keyword">char</span>* tail, <span class="keyword">uint64_t</span> tail, <span class="keyword">double</span> tail]</span><br></pre></td></tr></table></figure></p><p>需要注意的是：空基类没有占用任何空间，这取决 <a href="https://en.cppreference.com/w/cpp/language/ebo" target="_blank" rel="noopener">empty base optimization</a>。使用clang的<a href="https://eli.thegreenplace.net/2012/12/17/dumping-a-c-objects-memory-layout-with-clang/" target="_blank" rel="noopener">layout dump feature</a>,我们核验</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*** Dumping AST Record Layout</span><br><span class="line">   <span class="number">0</span> | <span class="class"><span class="keyword">struct</span> <span class="title">tuple</span>&lt;double, unsigned long, const char *&gt;</span></span><br><span class="line"><span class="class">   0 |   <span class="title">struct</span> <span class="title">tuple</span>&lt;unsigned long, const char *&gt; (<span class="title">base</span>)</span></span><br><span class="line"><span class="class">   0 |     <span class="title">struct</span> <span class="title">tuple</span>&lt;const char *&gt; (<span class="title">base</span>)</span></span><br><span class="line"><span class="class">   0 |       <span class="title">struct</span> <span class="title">tuple</span>&lt;&gt; (<span class="title">base</span>) (<span class="title">empty</span>)</span></span><br><span class="line"><span class="class">   0 |       <span class="title">const</span> <span class="title">char</span> * <span class="title">tail</span></span></span><br><span class="line"><span class="class">   8 |     <span class="title">unsigned</span> <span class="title">long</span> <span class="title">tail</span></span></span><br><span class="line"><span class="class">  16 |   <span class="title">double</span> <span class="title">tail</span></span></span><br><span class="line"><span class="class">     | [<span class="title">sizeof</span>=24, <span class="title">dsize</span>=24, <span class="title">align</span>=8</span></span><br><span class="line"><span class="class">     |  <span class="title">nvsize</span>=24, <span class="title">nvalign</span>=8]</span></span><br></pre></td></tr></table></figure><p>数据结构的的大小和结构是我们所期待的那样</p><p>so , 上面struct 定义让我们可以创建tuple，但是我还不能对此多出其他额外的操作，处理tuple使用get函数模板，让我们看他是怎么工作的，首先，我们定义一个帮助类型然我们处理第k个元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span>, <span class="class"><span class="keyword">class</span>&gt; <span class="title">struct</span> <span class="title">elem_type_holder</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Ts</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">elem_type_holder</span>&lt;0, tuple&lt;T, Ts...&gt;&gt; &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> k, <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Ts</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">elem_type_holder</span>&lt;k, tuple&lt;T, Ts...&gt;&gt; &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> elem_type_holder&lt;k - <span class="number">1</span>, tuple&lt;Ts...&gt;&gt;::type type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>elem_type_holder 也是另一个类模板，他拥有我么所感兴趣的数字K和类型tuple，这是编译期的模板元编程构造常量和类型，并不是运行期对象，举个例子elem_type_holder&lt;2,some_tuple_type&gt;,我们可以得到以下伪代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elem_type_holder</span>&lt;2, tuple&lt;T, Ts...&gt;&gt; &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> elem_type_holder&lt;<span class="number">1</span>, tuple&lt;Ts...&gt;&gt;::type type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elem_type_holder</span>&lt;1, tuple&lt;T, Ts...&gt;&gt; &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> elem_type_holder&lt;<span class="number">0</span>, tuple&lt;Ts...&gt;&gt;::type type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elem_type_holder</span>&lt;0, tuple&lt;T, Ts...&gt;&gt; &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>elem_type_holder&lt;2,some_tuple_type&gt; 剥落两个类型变量从tuple的开头，设置他的变量值到第三个type，这就是我们所需要的，通过与此协同，我们可以实现get</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> k, <span class="class"><span class="keyword">class</span>... <span class="title">Ts</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">std</span>:</span>:enable_if&lt;</span><br><span class="line">    k == <span class="number">0</span>, <span class="keyword">typename</span> elem_type_holder&lt;<span class="number">0</span>, tuple&lt;Ts...&gt;&gt;::type&amp;&gt;::type</span><br><span class="line">get(tuple&lt;Ts...&gt;&amp; t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t.tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> k, <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Ts</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">std</span>:</span>:enable_if&lt;</span><br><span class="line">    k != <span class="number">0</span>, <span class="keyword">typename</span> elem_type_holder&lt;k, tuple&lt;T, Ts...&gt;&gt;::type&amp;&gt;::type</span><br><span class="line">get(tuple&lt;T, Ts...&gt;&amp; t) &#123;</span><br><span class="line">  tuple&lt;Ts...&gt;&amp; base = t;</span><br><span class="line">  <span class="keyword">return</span> get&lt;k - <span class="number">1</span>&gt;(base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<a href="https://en.cppreference.com/w/cpp/types/enable_if" target="_blank" rel="noopener">enbale_if</a> 被用来在两个模板函数之间进行选择，一个用来k==0,一个是泛型get k！=0 每次调用都剥落一个类型，而不去使用。</p><p>因为返回的是一个引用，我们可以利用get去读取和修改这个值<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="keyword">double</span>, <span class="keyword">uint64_t</span>, <span class="keyword">const</span> <span class="keyword">char</span>*&gt; t1(<span class="number">12.2</span>, <span class="number">42</span>, <span class="string">"big"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"0th elem is "</span> &lt;&lt; get&lt;<span class="number">0</span>&gt;(t1) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1th elem is "</span> &lt;&lt; get&lt;<span class="number">1</span>&gt;(t1) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2th elem is "</span> &lt;&lt; get&lt;<span class="number">2</span>&gt;(t1) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">get&lt;<span class="number">1</span>&gt;(t1) = <span class="number">103</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1th elem is "</span> &lt;&lt; get&lt;<span class="number">1</span>&gt;(t1) &lt;&lt; <span class="string">"\n"</span>;</span><br></pre></td></tr></table></figure></p><h1 id="适用于catch-all函数的可变模板（又称为：template-template-parameter）"><a href="#适用于catch-all函数的可变模板（又称为：template-template-parameter）" class="headerlink" title="适用于catch-all函数的可变模板（又称为：template template parameter）"></a>适用于catch-all函数的可变模板（又称为：template template parameter）</h1><p>这里有另一个有趣的例子，它不同于我们上诉的例子，因为他并不是真正的使用传统的递归方式实现可变模板，相反他表达了一个“任何模板参数都可以到达这里”的概念。</p><p>也就是说，我们想要写一个函数可以显示出标准库容器，我们想要他工作在任何容器，并且我们也想要用户尽可能的写的小，所以我们不打算用迭代器，我仅仅想要print_container(c) 工作在任何容器上，这是第一种途径。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">ContainerType</span>,</span></span><br><span class="line"><span class="class">          <span class="title">typename</span> <span class="title">ValueType</span>,</span></span><br><span class="line"><span class="class">          <span class="title">typename</span> <span class="title">AllocType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print_container</span>(<span class="title">const</span> <span class="title">ContainerType</span>&lt;ValueType, AllocType&gt;&amp; <span class="title">c</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : c) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很多STL容器是可以传入参数value type and allocator type 的模板，举个例子，vector ,list, and so on , 所以我们可以这样写调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vd&#123;<span class="number">3.14</span>, <span class="number">8.1</span>, <span class="number">3.2</span>, <span class="number">1.0</span>&#125;;</span><br><span class="line">print_container(vd);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">print_container(li);</span><br></pre></td></tr></table></figure><p>并且这也是我们所期待的，但是当我们传入map的时候，我们将得到一个编译错误</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; msi&#123;&#123;<span class="string">"foo"</span>, <span class="number">42</span>&#125;, &#123;<span class="string">"bar"</span>, <span class="number">81</span>&#125;, &#123;<span class="string">"bazzo"</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">print_container(msi);</span><br><span class="line">^~~~~~~~~~~~~~~</span><br><span class="line">error: no matching function for call to 'print_container'</span><br><span class="line">note: candidate <span class="keyword">template</span> ignored: substitution failure :</span><br><span class="line">      <span class="keyword">template</span> <span class="keyword">template</span> argument has different <span class="keyword">template</span></span><br><span class="line">      parameters than its corresponding <span class="keyword">template</span> <span class="keyword">template</span> parameter</span><br></pre></td></tr></table></figure><p>这是因为map 模板有四个参数，而不是两个，相同的问题将出现在set身上，set 有三个模板参数，这是人很烦恼-当print_container函数的代码一样对于所有的容器？因为这些容器的签名是不一致的，我们可以写出不冗余的代码嘛？可变参数模板可以解决这个问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>...&gt; <span class="class"><span class="keyword">class</span> <span class="title">ContainerType</span>,</span></span><br><span class="line"><span class="class">          <span class="title">typename</span> <span class="title">ValueType</span>, <span class="title">typename</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print_container</span>(<span class="title">const</span> <span class="title">ContainerType</span>&lt;ValueType, Args...&gt;&amp; <span class="title">c</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : c) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们要说的是，ContainerType 是一个template template parameter 且参数类型是任意数量的，我们不关系多少数量，这个交给编译器去决定，这个函数版本将工作的map,set,unordered_map 和其他容器，有一个额外的支持函数需要做</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Implement &lt;&lt; for pairs: this is needed to print out mappings where range</span></span><br><span class="line"><span class="comment">// iteration goes over (key, value) pairs.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> <span class="built_in">std</span>::pair&lt;T, U&gt;&amp; p) &#123;</span><br><span class="line">  out &lt;&lt; <span class="string">"["</span> &lt;&lt; p.first &lt;&lt; <span class="string">", "</span> &lt;&lt; p.second &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="可变函数模板的转发"><a href="#可变函数模板的转发" class="headerlink" title="可变函数模板的转发"></a>可变函数模板的转发</h1><p>一些相关的例子中的模板本身并不会做太多，但是不得不转发他们的参数给一些其他的模板和函数，这个实现很有用因为c++在使用固有的可变参数构造时，从模板参数看构造函数，给一个泛型类型T ，调用T的构造函数，我可能需要传递任意类型的参数，不想函数类型指定他们参数在编译期，仅仅给了一个泛型类型T，我们不知道构造什么类型的参数T，类型T有多少参数需要传入</p><p>一个重要的例子就是std::make_unique 函数，可使用自从c++14,我们可以使用它用一下方式<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;FooType&gt; f = <span class="built_in">std</span>::make_unique&lt;FooType&gt;(<span class="number">1</span>, <span class="string">"str"</span>, <span class="number">2.13</span>);</span><br></pre></td></tr></table></figure></p><p> FooType 是个任意类型的并且可以被任意方式构造，make_unique 怎么知道他的构造签名呢，一种典型的实现</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;T&gt; make_unique(Args&amp;&amp;... args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- ## 参考资料> - []()> - []() -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;英文原版：&lt;a href=&quot;https://eli.thegreenplace.net/2014/variadic-templates-in-c/#id5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://eli.thegreenplace.n
      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="cpp" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/cpp/"/>
    
      <category term="元编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/cpp/%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>vscode_sshFS文件系统</title>
    <link href="http://yoursite.com/2019/03/29/vscode-sshFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2019/03/29/vscode-sshFS文件系统/</id>
    <published>2019-03-29T04:45:45.000Z</published>
    <updated>2019-04-03T14:26:57.934Z</updated>
    
    <content type="html"><![CDATA[<p>如果让你编辑Linux/Unix,下的服务器的文件，你会怎么做</p><p>第一种方案：<br>1、打开ssh<br>2、打开vim 编辑</p><p>第二种方案：<br>1、打开samba or ftp 服务<br>2、打开映射的文件系统直接编辑</p><p>第三种:<br>我要介绍VScode 中的ssh-FS插件，通过over ssh port and server 将文件系统映射到vscode中。</p><p>步骤：<br>1、vscode 搜索插件： ssh fs &amp; install<br>2、CTRL + shift + p ,选择创建 配置文件<br>3、编辑配置文件，使用ssh fs: edit configuration<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"sshfs.configs"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"host"</span>: <span class="string">"192.168.31.153"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"myHost"</span>,</span><br><span class="line">            <span class="attr">"password"</span>: <span class="string">"root"</span>,</span><br><span class="line">            <span class="attr">"root"</span>: <span class="string">"/root"</span>,</span><br><span class="line">            <span class="attr">"username"</span>: <span class="string">"root"</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4、connect as workspace folder</p><p>同样你也可以配合另一个插件，体验更好。<br>plugins name : ssh tooling</p><p>配置文件与ssh的配置文件一致，这个插件的作用就是执行了命令<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -F ssh.config</span><br></pre></td></tr></table></figure></p><p>ssh.config<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host root</span><br><span class="line">    HostName <span class="number">192.168</span><span class="number">.31</span><span class="number">.153</span></span><br><span class="line">    # LocalForward <span class="number">22</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.153</span>:<span class="number">22</span></span><br><span class="line">    User root</span><br><span class="line">    # PasswordAuthentication root</span><br></pre></td></tr></table></figure></p><!-- ## 参考资料> - []()> - []() -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果让你编辑Linux/Unix,下的服务器的文件，你会怎么做&lt;/p&gt;
&lt;p&gt;第一种方案：&lt;br&gt;1、打开ssh&lt;br&gt;2、打开vim 编辑&lt;/p&gt;
&lt;p&gt;第二种方案：&lt;br&gt;1、打开samba or ftp 服务&lt;br&gt;2、打开映射的文件系统直接编辑&lt;/p&gt;
&lt;p&gt;第三种
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Cmake 简单结构</title>
    <link href="http://yoursite.com/2019/03/28/Cmake/"/>
    <id>http://yoursite.com/2019/03/28/Cmake/</id>
    <published>2019-03-28T04:37:23.000Z</published>
    <updated>2019-03-29T04:35:32.995Z</updated>
    
    <content type="html"><![CDATA[<p>本主题以及本系列后续的博客讲Cmake编写，之所以写这一主题，是因为对国内大部分cmake blog实属不满意，于是自己将参考《mastering cmake》这一本书写出一个自己的简单的cmake笔记,以供自己查阅</p><p>为什么不写MakeFile，因为我觉得写MakeFile没有写CMakeList.txt方便，至于其他的原因，请自行bing</p><p>简单项目：<br>file structure<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">----</span><br><span class="line">   |</span><br><span class="line">   --CMakeLists.txt</span><br><span class="line">   --hello.cpp</span><br></pre></td></tr></table></figure></p><p>CMakeLists.txt<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># the name of the resulting workspace should be </span></span><br><span class="line"><span class="keyword">project</span>(hello )</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the executable target to the build process</span></span><br><span class="line"><span class="comment"># if ur have many file , u could add them</span></span><br><span class="line"><span class="comment"># example :add_executable(hello hello.cpp file1.cpp file2.cpp )</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello hello.cpp)</span><br></pre></td></tr></table></figure></p><p>hello.cpp<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"hello"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一个简单的项目完成了，由于这是很小的项目，我们使用cmake command Line 形式进行生成workspace  ，对于大型项目还是推荐使用gui /interactive<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -S . -G <span class="string">"NMake Makefiles"</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure></p><p>之后编译就没问题啦 </p><p>当然你可以使用cmake 中的 –build 选项,直接进行编译</p><!-- ## 参考资料> - []()> - []() -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本主题以及本系列后续的博客讲Cmake编写，之所以写这一主题，是因为对国内大部分cmake blog实属不满意，于是自己将参考《mastering cmake》这一本书写出一个自己的简单的cmake笔记,以供自己查阅&lt;/p&gt;
&lt;p&gt;为什么不写MakeFile，因为我觉得写M
      
    
    </summary>
    
      <category term="项目构建" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://yoursite.com/2019/03/27/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/03/27/单例模式/</id>
    <published>2019-03-27T13:26:54.000Z</published>
    <updated>2019-03-27T13:28:42.491Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cSingle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">cSingle(<span class="keyword">const</span> cSingle&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">cSingle&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> cSingle&amp;) =<span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> cSingle* <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> cSingle __instance;</span><br><span class="line"><span class="keyword">return</span> &amp;__instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">cSingle() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cSingle* first = cSingle::instance();</span><br><span class="line">cSingle* second = cSingle::instance();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"the first address is :"</span> &lt;&lt; first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"the second address is :"</span> &lt;&lt; second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- ## 参考资料> - []()> - []() -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单例模式&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>retry task in cpp &amp;golang</title>
    <link href="http://yoursite.com/2019/03/27/%E4%BB%BB%E5%8A%A1%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B/"/>
    <id>http://yoursite.com/2019/03/27/任务重新开始/</id>
    <published>2019-03-27T12:26:33.000Z</published>
    <updated>2019-03-29T04:34:22.006Z</updated>
    
    <content type="html"><![CDATA[<p>今日偶然看到 retry task 的玩意，貌似这个在Instant message 挺常见的</p><p>今日就来个 cpp &amp; GoLang 的写法，主要是掌握系统时间的控制</p><p>GoLang<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WaitForServer</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> timeout = <span class="number">1</span> * time.Minute</span><br><span class="line">deadline := time.Now().Add(timeout)</span><br><span class="line"><span class="keyword">for</span> tries := <span class="number">0</span>; time.Now().Before(deadline); tries++ &#123;</span><br><span class="line">_, err := http.Head(url)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// success</span></span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"server not responding (%s); retrying..."</span>, err)</span><br><span class="line">        <span class="comment">//time.Sleep(time.Second &lt;&lt; uint(tries)) // exponential back-off</span></span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"server %s failed to respond after %s"</span>, url, timeout)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">go</span> WaitForServer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于cpp 同样的通信原理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">work_thread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">chrono::system_clock::time_point oneMinute=chrono::system_clock::now() + chrono::seconds(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">while</span> (chrono::system_clock::now()&lt; oneMinute)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// execute some network operatoe</span></span><br><span class="line">        <span class="comment">//... tcp /ip socket</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(socketID.receive is <span class="keyword">not</span> <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"the time is "</span> &lt;&lt; i++ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        this_thread::sleep_for(chrono::seconds(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> result = async(lauch::async,work_thread);</span><br><span class="line">    <span class="keyword">if</span>(result.get())&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今日偶然看到 retry task 的玩意，貌似这个在Instant message 挺常见的&lt;/p&gt;
&lt;p&gt;今日就来个 cpp &amp;amp; GoLang 的写法，主要是掌握系统时间的控制&lt;/p&gt;
&lt;p&gt;GoLang&lt;br&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="cpp" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/cpp/"/>
    
      <category term="STL(类对象)" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/cpp/STL-%E7%B1%BB%E5%AF%B9%E8%B1%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>git简单使用</title>
    <link href="http://yoursite.com/2019/03/26/git%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/03/26/git简单使用/</id>
    <published>2019-03-26T13:49:13.000Z</published>
    <updated>2019-03-26T14:29:24.905Z</updated>
    
    <content type="html"><![CDATA[<p>选择git，而不是svn的原因，可能是因为git，在个人PC上自成版本库，而svn则不行，需要联网（局域网 or 广域网）</p><p>而对于我常用的命令也不多，可能就那么几个，以下做个简单描述</p><p>首先弄清楚几个概念</p><p><strong>工作区：</strong></p><p>就是你在电脑上看到的目录(.git隐藏目录版本库除外)</p><p><strong>版本库(Repository)：</strong></p><p>工作区有一个隐藏目录.git文件夹，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区，可以理解为缓冲区，一次性提交多个修改)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。master分支指向提交</p><p>我们前面说过使用Git提交文件到版本库有两步：<br>第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。<br>第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。</p><h3 id="1-初始化-or-添加远程库"><a href="#1-初始化-or-添加远程库" class="headerlink" title="1. 初始化 or 添加远程库"></a>1. 初始化 or 添加远程库</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地库初始化 </span></span><br><span class="line">git init</span><br><span class="line"><span class="comment"># 远程库关联</span></span><br><span class="line">git remote add origin https://yourRepository</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程库克隆</span></span><br><span class="line">git <span class="built_in">clone</span>  https://yourRepository</span><br><span class="line"><span class="comment"># 目前本地git 拥有远程库查看</span></span><br><span class="line">git remote show</span><br></pre></td></tr></table></figure><h3 id="2-代码（文本）修改-增加、删除、修改文件"><a href="#2-代码（文本）修改-增加、删除、修改文件" class="headerlink" title="2. 代码（文本）修改 {增加、删除、修改文件}"></a>2. 代码（文本）修改 {增加、删除、修改文件}</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加文件 or 修改文件</span></span><br><span class="line">git add modifyOraddFile.*</span><br><span class="line"><span class="comment"># 删除文件没有对应 添加缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前修改状态</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交到版本库</span></span><br><span class="line">git commit -m <span class="string">"add | modify | delete file , or repaire bug function etc"</span></span><br></pre></td></tr></table></figure><h3 id="3-代码版本回溯"><a href="#3-代码版本回溯" class="headerlink" title="3. 代码版本回溯"></a>3. 代码版本回溯</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回退到上个/上上个/上上上个/..... 山里有个庙个版本</span></span><br><span class="line">git reset --hard HEAD^ <span class="comment"># ^是回退版本的个数</span></span><br><span class="line"><span class="comment"># 回退特定版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看版本号</span></span><br><span class="line">git reflog</span><br><span class="line"><span class="comment">#回退版本号</span></span><br><span class="line">git reset --hard <span class="string">"version ID"</span></span><br></pre></td></tr></table></figure><h3 id="4-分支操作"><a href="#4-分支操作" class="headerlink" title="4. 分支操作"></a>4. 分支操作</h3><p>常用于bug修复，但是我不喜欢使用stash 这个命令，更喜欢新建分支，因为清晰明了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看分支</span></span><br><span class="line">git branch</span><br><span class="line"><span class="comment"># 新建分支并切换</span></span><br><span class="line">git checkout -b branchName <span class="comment">#新建当前分支，以当前分支为基础</span></span><br><span class="line"><span class="comment"># 分支切换</span></span><br><span class="line">git checkout branchName</span><br><span class="line"><span class="comment"># 分支删除</span></span><br><span class="line">git branch -d branchName</span><br></pre></td></tr></table></figure><h3 id="5-分支合并"><a href="#5-分支合并" class="headerlink" title="5. 分支合并"></a>5. 分支合并</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 合并分支代码branchName 到当前分支代码</span></span><br><span class="line">git merge branchName</span><br></pre></td></tr></table></figure><h3 id="6-分支推送"><a href="#6-分支推送" class="headerlink" title="6.分支推送"></a>6.分支推送</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推送分支</span></span><br><span class="line">git push origin branchName</span><br></pre></td></tr></table></figure><p>打完收工~ </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;选择git，而不是svn的原因，可能是因为git，在个人PC上自成版本库，而svn则不行，需要联网（局域网 or 广域网）&lt;/p&gt;
&lt;p&gt;而对于我常用的命令也不多，可能就那么几个，以下做个简单描述&lt;/p&gt;
&lt;p&gt;首先弄清楚几个概念&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作区：&lt;/
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>cpp SFINAE</title>
    <link href="http://yoursite.com/2019/03/26/cpp%E7%89%B9%E5%8C%96/"/>
    <id>http://yoursite.com/2019/03/26/cpp特化/</id>
    <published>2019-03-26T10:17:55.000Z</published>
    <updated>2019-03-26T13:39:24.753Z</updated>
    
    <content type="html"><![CDATA[<p>cpp 模板SFINAE(“Substitution Failure Is Not An Error”)</p><p>下面是一段引文，来自网站 <a href="https://en.cppreference.com/w/" target="_blank" rel="noopener">https://en.cppreference.com/w/</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This rule applies during overload resolution of function templates: When substituting the explicitly specified <span class="keyword">or</span> deduced type <span class="keyword">for</span> the <span class="keyword">template</span> parameter fails, the specialization is discarded from the overload <span class="built_in">set</span> instead of causing a compile error.</span><br><span class="line"></span><br><span class="line">This feature is used in <span class="keyword">template</span> metaprogramming.</span><br></pre></td></tr></table></figure><p>推断辅助函数：decay_t / decltype</p><p>涉及：函数重载（overload） / 参数计算后进栈</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// this overload is always in the set of overloads</span></span><br><span class="line"><span class="comment">// ellipsis parameter has the lowest ranking for overload resolution</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Catch-all overload called\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// this overload is added to the set of overloads if</span></span><br><span class="line">    <span class="comment">// C is a reference-to-class type and F is a pointer to member function of C</span></span><br><span class="line">    <span class="comment">// (void)(c.*f)(), void() </span></span><br><span class="line">    <span class="comment">// the return type is void()</span></span><br><span class="line">    <span class="comment">// but (void)(c.*f)(), void() execute comma </span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">C</span>, <span class="title">class</span> <span class="title">F</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">auto</span> <span class="title">test</span>(<span class="title">C</span> <span class="title">c</span>, <span class="title">F</span> <span class="title">f</span>) -&gt; <span class="title">decltype</span>((<span class="title">void</span>)(<span class="title">c</span>.*<span class="title">f</span>)(), <span class="title">void</span>())</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Reference overload called\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// this overload is added to the set of overloads if</span></span><br><span class="line">    <span class="comment">// C is a pointer-to-class type and F is a pointer to member function of C</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">C</span>, <span class="title">class</span> <span class="title">F</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">auto</span> <span class="title">test</span>(<span class="title">C</span> <span class="title">c</span>, <span class="title">F</span> <span class="title">f</span>) -&gt; <span class="title">decltype</span>((<span class="title">void</span>)((<span class="title">c</span>-&gt;*<span class="title">f</span>)()), <span class="title">void</span>())</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pointer overload called\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span> <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    X x;</span><br><span class="line">    test( x, &amp;X::f);</span><br><span class="line">    test(&amp;x, &amp;X::f);</span><br><span class="line">    test(<span class="number">42</span>, <span class="number">1337</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="comment">// Reference overload called</span></span><br><span class="line">    <span class="comment">// Pointer overload called</span></span><br><span class="line">    <span class="comment">// Catch-all overload called</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;cpp 模板SFINAE(“Substitution Failure Is Not An Error”)&lt;/p&gt;
&lt;p&gt;下面是一段引文，来自网站 &lt;a href=&quot;https://en.cppreference.com/w/&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="cpp" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/cpp/"/>
    
      <category term="元编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/cpp/%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>c#加载cppdll</title>
    <link href="http://yoursite.com/2019/03/25/c-%E5%8A%A0%E8%BD%BDcppdll/"/>
    <id>http://yoursite.com/2019/03/25/c-加载cppdll/</id>
    <published>2019-03-25T07:44:58.000Z</published>
    <updated>2019-03-26T13:40:10.957Z</updated>
    
    <content type="html"><![CDATA[<p>来源与前一阵子有一个朋友请教我关于c#调用c/cpp dll 的方式</p><h3 id="1-cpp-c-封装成dll"><a href="#1-cpp-c-封装成dll" class="headerlink" title="1. cpp/c 封装成dll"></a>1. cpp/c 封装成dll</h3><p>环境：vs2019<br>项目类型：新建空项目<br>文件类型：c/cpp<br>fileContent:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> __declspec(dllexport) myPrint()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> __declspec(dllexport) a(<span class="keyword">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>项目属性：dll</p><hr><h3 id="2-c-调用端"><a href="#2-c-调用端" class="headerlink" title="2. c# 调用端"></a>2. c# 调用端</h3><p>环境：vs2019<br>项目类型：新建空项目<br>文件类型：c#控制台程序<br>fileContent:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> hellocaller</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Program</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="comment">//[DllImport(@"..\\hello\\Release\\hello.dll")]</span></span><br><span class="line">        <span class="comment">//private static extern void myPrint();</span></span><br><span class="line">        <span class="comment">//[DllImport(@"..\\hello\\Release\\hello.dll")]</span></span><br><span class="line">        <span class="comment">//private static extern int a(int b);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        [DllImport(<span class="string">"kernel32.dll"</span>, EntryPoint = <span class="string">"LoadLibrary"</span>)]</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">LoadLibrary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            [MarshalAs(UnmanagedType.LPStr)] <span class="built_in">string</span> lpLibFileName)</span></span>;</span><br><span class="line"></span><br><span class="line">        [DllImport(<span class="string">"kernel32.dll"</span>, EntryPoint = <span class="string">"GetProcAddress"</span>)]</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">GetProcAddress</span><span class="params">(<span class="keyword">int</span> hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">            [MarshalAs(UnmanagedType.LPStr)] <span class="built_in">string</span> lpProcName)</span></span>;</span><br><span class="line"></span><br><span class="line">        [DllImport(<span class="string">"kernel32.dll"</span>, EntryPoint = <span class="string">"FreeLibrary"</span>)]</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">bool</span> <span class="title">FreeLibrary</span><span class="params">(<span class="keyword">int</span> hModule)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">delegate <span class="keyword">int</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(<span class="built_in">string</span>[] args)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hModule = LoadLibrary(@<span class="string">"..\\hello\\Release\\hello.dll"</span>);</span><br><span class="line">            <span class="comment">//if(hModule == 0) </span></span><br><span class="line">            <span class="comment">//    return false;</span></span><br><span class="line">            IntPtr intPtr = GetProcAddress(hModule, <span class="string">"a"</span>);</span><br><span class="line">            A a = (A)Marshal.GetDelegateForFunctionPointer(intPtr, typeof(A));</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(a(<span class="number">3</span>));</span><br><span class="line">            <span class="comment">//myPrint();</span></span><br><span class="line">            FreeLibrary(hModule);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><!-- ## 参考资料> - []()> - []() -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来源与前一阵子有一个朋友请教我关于c#调用c/cpp dll 的方式&lt;/p&gt;
&lt;h3 id=&quot;1-cpp-c-封装成dll&quot;&gt;&lt;a href=&quot;#1-cpp-c-封装成dll&quot; class=&quot;headerlink&quot; title=&quot;1. cpp/c 封装成dll&quot;&gt;&lt;/a&gt;1
      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="cpp" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/cpp/"/>
    
      <category term="DLL交互" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/cpp/DLL%E4%BA%A4%E4%BA%92/"/>
    
    
  </entry>
  
  <entry>
    <title>接口interface心得（1）</title>
    <link href="http://yoursite.com/2019/03/18/go%E6%8E%A5%E5%8F%A3%E5%B0%8F%E5%BE%97/"/>
    <id>http://yoursite.com/2019/03/18/go接口小得/</id>
    <published>2019-03-18T14:52:09.000Z</published>
    <updated>2019-03-29T04:39:18.597Z</updated>
    
    <content type="html"><![CDATA[<p>看到go 语言的接口一个与众不同的地方~</p><p>我的印象中，在go中，基本上是以下这种行为</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span>  main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> people <span class="keyword">interface</span> &#123;</span><br><span class="line">getOccupation() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span>  student <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> worker <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu student)</span><span class="title">getOccupation</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"student"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(wk worker)</span><span class="title">getOccupation</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"worker"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printOccupation</span><span class="params">(pe people)</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"the occupation is : "</span>,pe.getOccupation())</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">printOccupation(student&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的代码没什么出奇的地方</p><p>请看下面一段代码<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span>  main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ioreader <span class="keyword">interface</span> &#123;</span><br><span class="line">MyReader()[]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> fileExcute <span class="keyword">interface</span> &#123;</span><br><span class="line">MyReader()[]<span class="keyword">byte</span></span><br><span class="line">MyWrite([]<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFlush2</span><span class="params">(io ioreader)</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"code snippet is executing: MyFlush2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFlush</span><span class="params">(io fileExcute)</span></span>&#123;</span><br><span class="line">MyFlush2(io)</span><br><span class="line">fmt.Println(<span class="string">"code snippet is executing: MyFlush"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Myfile <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file Myfile)</span> <span class="title">MyReader</span><span class="params">()</span> []<span class="title">byte</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fil Myfile)</span> <span class="title">MyWrite</span><span class="params">([]<span class="keyword">byte</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">MyFlush(Myfile&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时候一个结构体实现了两个接口，而且作为参数传递，接口fileExcute中的方法比ioreader接口中的方法要多</p><p>且被当成参数传递给了ioreader，数据类型也兼容，反过来将ioreader 传递给fileExecute 就会出错，因为会出现部分方法没有实现的错误</p><p>可见go语言中的interface 很是灵活</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看到go 语言的接口一个与众不同的地方~&lt;/p&gt;
&lt;p&gt;我的印象中，在go中，基本上是以下这种行为&lt;/p&gt;
&lt;figure class=&quot;highlight golang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li
      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="go" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/go/"/>
    
      <category term="基本知识" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/go/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>screen</title>
    <link href="http://yoursite.com/2019/03/18/%E5%B7%A5%E5%85%B7screen/"/>
    <id>http://yoursite.com/2019/03/18/工具screen/</id>
    <published>2019-03-18T14:00:40.000Z</published>
    <updated>2019-03-29T01:39:15.138Z</updated>
    
    <content type="html"><![CDATA[<p>玩过Linux的多多少少听过 screen 这个玩意~</p><p>sreen 是为了长时间工作的一种会话管理工具，你不用担心你退出终端而中断你的任务</p><p>比如你在公司远程连接了云服务器，但是任务没有做完，怎么办，没关系，我们只要使用screen</p><p>回到家中登上云服务器attach  screen session 就可以，我们完全可以在不同的物理中断上共享</p><p>相同会话进程组~</p><p>他就像你在本地shell执行程序一样，其实是在绘画断开的时候阻断了信号signup信号</p><p>是我最喜爱的工具之一</p><p><strong>创建会话开始</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen</span><br></pre></td></tr></table></figure></p><p><strong>创建任务</strong><br>为了方便attach session ，一般使用下面的方式进行创建任务<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">screen -S session name [task]</span><br><span class="line">//for example </span><br><span class="line">screen -S  modifycpp vim hello.cpp</span><br></pre></td></tr></table></figure></p><p><strong>暂停任务</strong></p><p>暂停当前工作，返回shell 窗口<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+a d</span><br></pre></td></tr></table></figure></p><p><strong>创建新的shell</strong><br>创建一个新的shell 窗口<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+a c</span><br></pre></td></tr></table></figure></p><p><strong>会话窗口切换</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctrl+a p // 前一个窗口</span><br><span class="line">ctrl+a n //下一个窗口</span><br></pre></td></tr></table></figure></p><p><strong>附加会话</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -x [session id]/[session name]</span><br></pre></td></tr></table></figure></p><p><strong>查看会话</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -ls</span><br></pre></td></tr></table></figure></p><p>以上是我比较常用的几个命令吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;玩过Linux的多多少少听过 screen 这个玩意~&lt;/p&gt;
&lt;p&gt;sreen 是为了长时间工作的一种会话管理工具，你不用担心你退出终端而中断你的任务&lt;/p&gt;
&lt;p&gt;比如你在公司远程连接了云服务器，但是任务没有做完，怎么办，没关系，我们只要使用screen&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://yoursite.com/2019/03/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/03/18/设计模式/</id>
    <published>2019-03-18T12:21:20.000Z</published>
    <updated>2019-03-18T13:15:00.176Z</updated>
    
    <content type="html"><![CDATA[<p>开此分类的原因，是因为有人在吃饭的时候向我问起了设计模式</p><p>关于设计模式的几大原则</p><h3 id="1、单一职责原则"><a href="#1、单一职责原则" class="headerlink" title="1、单一职责原则"></a><strong>1、单一职责原则</strong></h3><p>功能职责边界划分清楚，当一个功能crash/uncorrect ,不会影响另一个功能模块</p><h3 id="2、里氏替换原则"><a href="#2、里氏替换原则" class="headerlink" title="2、里氏替换原则"></a><strong>2、里氏替换原则</strong></h3><p>子类继承父类的时候，尽量不去覆盖和重写父类的方法，这样就算，传入参数发生了变动（父类-&gt;子类），也不会影响原对象的功能（父类）</p><h3 id="3、依赖倒置原则"><a href="#3、依赖倒置原则" class="headerlink" title="3、依赖倒置原则"></a><strong>3、依赖倒置原则</strong></h3><p>与面向接口编程很像，设计功能类时，考虑到可扩展性，一般我们在本类中维持一个接口，这样我们不用修改接口，直接通过实现接口，来完成功能的可扩展性</p><h3 id="4、接口隔离原则"><a href="#4、接口隔离原则" class="headerlink" title="4、接口隔离原则"></a><strong>4、接口隔离原则</strong></h3><p>这个更像是数据库范式中的第三范式，我们应该完全实现接口中的方法，而不是部分实现，从而接口不是最小职责的原则</p><h3 id="5、迪米特法则"><a href="#5、迪米特法则" class="headerlink" title="5、迪米特法则"></a><strong>5、迪米特法则</strong></h3><p>高内聚低耦合，也就是对外提供统一的接口，其他类或者自己不访问其他类的内部数据</p><h3 id="6、开闭原则"><a href="#6、开闭原则" class="headerlink" title="6、开闭原则"></a><strong>6、开闭原则</strong></h3><p>很模糊的一个设计原则，只针对原有代码进行扩展，而不修改，更像是针对接口进行扩展，而不修改原有接口的内容</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开此分类的原因，是因为有人在吃饭的时候向我问起了设计模式&lt;/p&gt;
&lt;p&gt;关于设计模式的几大原则&lt;/p&gt;
&lt;h3 id=&quot;1、单一职责原则&quot;&gt;&lt;a href=&quot;#1、单一职责原则&quot; class=&quot;headerlink&quot; title=&quot;1、单一职责原则&quot;&gt;&lt;/a&gt;&lt;strong
      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="http://yoursite.com/2019/03/12/CPP%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/03/12/CPP拓扑排序/</id>
    <published>2019-03-12T15:47:01.000Z</published>
    <updated>2019-03-29T04:24:48.168Z</updated>
    
    <content type="html"><![CDATA[<p>todo</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;todo&lt;/p&gt;

      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>cpp11线程概述</title>
    <link href="http://yoursite.com/2019/03/05/cpp11%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/03/05/cpp11线程/</id>
    <published>2019-03-05T13:45:03.000Z</published>
    <updated>2019-03-29T04:26:53.294Z</updated>
    
    <content type="html"><![CDATA[<p>本来不想动~，想多看一点其他书~，但还是强迫自己写下这篇cpp11的线程概述~</p><p>关于cpp的线程详解有一本书讲的蛮不错~，前一阵子再看《cpp concurrency in action》 主讲线程细节</p><hr><h1 id="一-、线程"><a href="#一-、线程" class="headerlink" title="一 、线程"></a>一 、线程</h1><h2 id="上层接口"><a href="#上层接口" class="headerlink" title="上层接口"></a>上层接口</h2><h3 id="1-asnc-and-Futures"><a href="#1-asnc-and-Futures" class="headerlink" title="1 asnc() and Futures"></a>1 asnc() and Futures</h3><p><strong>aysnc()</strong> :提供一个可运行在后台的接口，其功能实现调用通过回调函数<br><strong>future&lt;&gt;</strong> : 让你等待一个线程的运行结果，返回值或者异常<br><strong>shared_future&lt;&gt;</strong> : 与future不同的是，future取回的值只能被处理一次，而shared_future 可以被处理多次</p><p>example:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">this_thread::sleep_for(chrono::seconds(<span class="number">2</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   main()&#123;</span><br><span class="line">       <span class="keyword">auto</span> result = future&lt;<span class="keyword">int</span>&gt;(async([]() &#123;<span class="keyword">return</span> <span class="number">2</span>; &#125;)).get()+getValue();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"the value is :"</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>async() 函数有三个可选的状态</p><ol><li>立刻运行 launch::async=0x1</li><li>推迟运行，在适当的机会运行 launch::deferred =0x2</li><li>默认状态，可能是立刻运行或者推迟运行 launch::async|launch::deferred</li></ol><p>但是这三种状态都可以使用get()函数从而进行任务变化为运行的状态</p><p>而wait() 系列的函数则是被动的东岱，而不是强迫任务开始，get()则不然，是强迫你任务开始，而wait()对应三种状态：</p><ol><li>future_status::ready</li><li>future_status::deferred</li><li>future_status::timeout</li></ol><p>So, let me make clear: If you start to use async(), you should pass all objects necessary to process the passed functionality by value so that async() uses only local copies. If copying is too expensive, ensure that the objects are passed as constant reference and that mutable is not used</p><h2 id="底层接口-：thread"><a href="#底层接口-：thread" class="headerlink" title="底层接口 ：thread"></a>底层接口 ：thread</h2><p>thrad 使用方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(function object)</span></span>;</span><br></pre></td></tr></table></figure></p><ol><li>thread 没有launch 策略，c++标准库尽可能的开始一个传入的函数对象，如果不可行，会抛出一个system_error的错误</li><li>没有接口可以处理线程的输出结构和返回值，你只能获取一个独一无二的线程ID</li><li>如果一个异常发生，而你没有捕获，那么程序将立刻中断，给线程传递一个外部的异常指针变量exception_ptrs</li><li>你必须执行join()或者detach()操作，否则程序将发生中断</li><li>如果你让线程在后台运行，一旦main() 函数结束，所有的线程将会立刻中断</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function">thread <span class="title">t</span><span class="params">([]() &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; <span class="built_in">endl</span>; this_thread::sleep_for(chrono::seconds(<span class="number">3</span>)); &#125;)</span></span>;</span><br><span class="line">t.join();</span><br></pre></td></tr></table></figure><h3 id="1-detached-threads"><a href="#1-detached-threads" class="headerlink" title="1 detached threads"></a>1 detached threads</h3><p>分离线程如果使用了非局部变量很容易成为一个问题，因为你一旦分离了线程，就意味了你失去了对它的控制，那么至于它运行多久，我们就不知道了。因为有可能在非局部变量生命周期结束的时候，线程有可能还没有结束，那么你的线程很可能会出现问题。因此，强烈将以，你传递给线程从copy-value 的方式，而不是引用的方式。</p><h3 id="2-Promises"><a href="#2-Promises" class="headerlink" title="2 Promises"></a>2 Promises</h3><p>为了能够取回线程中的值，像async()一样，我们使用promises函数特性辅助<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start thread using a promise to store the outcome</span></span><br><span class="line"><span class="built_in">std</span>::promise&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; p;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">([](<span class="built_in">string</span> &amp;b)&#123;b=<span class="number">12</span>;&#125;,<span class="built_in">std</span>::ref(p))</span></span>;</span><br><span class="line">t.detach();</span><br><span class="line">...</span><br><span class="line"><span class="comment">// create a future to process the outcome</span></span><br><span class="line"><span class="built_in">std</span>::future&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; f(p.get_future());</span><br><span class="line"><span class="comment">// process the outcome</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"result: "</span> &lt;&lt; f.get() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><h3 id="3-packeaged-task-lt-gt"><a href="#3-packeaged-task-lt-gt" class="headerlink" title="3 packeaged_task&lt;&gt;"></a>3 packeaged_task&lt;&gt;</h3><p>aysnc() 让你处理立刻执行还是推迟，然后返回结果，有时候，你可能需要自己决定什么时间怎么执行一个任务，那么packaged_task&lt;&gt;就是这个目的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">compute</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::packaged_task&lt;<span class="keyword">double</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; task(compute); <span class="comment">// create a task</span></span><br><span class="line"><span class="built_in">std</span>::future&lt;<span class="keyword">double</span>&gt; f = task.get_future(); <span class="comment">// get its future</span></span><br><span class="line">...</span><br><span class="line">task(<span class="number">7</span>,<span class="number">5</span>); <span class="comment">// start the task (typically in a separate thread)</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">double</span> res = f.get(); <span class="comment">// wait for its end and process result/exception</span></span><br></pre></td></tr></table></figure></p><p>note:</p><p>thread.native_handle(): Returns a platform-specific type native_handle_type fornonportable extensions</p><p>unsigned int std::thread::hardware_concurrency ()<br>• Returns the number of possible threads.</p><p>• This value is just a hint and does not guarantee to be exact.</p><p>• Returns 0 if the number is not computable or well defined.</p><hr><h1 id="二-、同步"><a href="#二-、同步" class="headerlink" title="二 、同步"></a>二 、同步</h1><p>并发处理相同的数据~</p><p>相同数据：意味着相同的内存位置，如果不同线程处理不同的变量、对象或者不同的成员，自然也就没有问题啦，自c11，除了位域（bitfield），每个变量都被保证拥有自己的内存地址。并发的处理相同的数据，如果仅仅读是没有问题的，如果当一个超过1个线程修改了数据，那么就会陷入数据不同步的麻烦中，这也是数据竞争，也可以理解为不同线程间的矛盾处理，会产生未定义行为（undefined behave）</p><p>数据竞争带来的后果是，代码中是你想做的，但是实际输出结果不是你想要的</p><p>产生这种原因来源于编译器或者cpu的指令的优化~，首先我们得理解cpp对于并发的并发给了我们什么承诺（保证），像cpp 这样的编程语言总是抽象的支持在不同的硬件和平台上，根据他们的架构和目的，从而提供了不同的能力和接口，因而cpp规定了相应语句和操作产生的结果，并不是产生相应的汇编代码（assembler code）,cpp标准只要求结果，至于你怎么实现，却没有明确的定义。</p><p>因此，你不能期待编程语言给予你太多的承诺，实际上根据as-if rule,只要保证外部行为表现相同，每个编译器都通常选择优化代码，因此编译器产生的代码也是黑盒的。</p><p>我们也就知道，任何未定义的都可能是编译器和硬件提供商为了产生尽可能高效的代码导致的，比如：编译器可能会展开循环、打乱执行语句、消除无用代码、预取数据，并且在现代架构中，一个硬件缓冲区可能打乱存储和加载的顺序。</p><p>执行语句的乱序对于提高性能很有用，但是他们在并发中也极有可能破坏所期待结构的行为，因此，安全并不是默认保证的</p><h3 id="可能会发生的错误"><a href="#可能会发生的错误" class="headerlink" title="可能会发生的错误"></a>可能会发生的错误</h3><p><strong>数据处理不同步</strong>： 当两个线程并行处理读取和写入的操作，可能遇到以下情况</p><ul><li>半写入数据：当一个线程正在读取数据，另一个线程正在修改数据，当读取数据读到写入的一般的时间，也是读取的状态既不是旧值也不是新值</li><li>乱序：对于每一个线程的行为可能是正确的，但是一旦讲所有线程联系起来，可能会产生不可预期的结果</li></ul><p>但是cpp还是提供了一些先生安全保证</p><ul><li>处理不同数据： 处理统一容器的不同位置的数据</li><li>并发处理流：  并发处理字符流，文件流，流缓冲区可能导致未定义行为，但是对于格式化输入输出标准流被同步于c i/o,是可能的，虽然他可能导致插入字符</li></ul><h3 id="1-解决方案"><a href="#1-解决方案" class="headerlink" title="1 解决方案"></a>1 解决方案</h3><p>为了保证正确并行数据，我们使用以下方案</p><ol><li><p>原子操作 ：这意味着对于一个变量读取和写入都是原子的，或者语句的序列发生时排他性的，没有任何的中断，因此任何一个线程可以读取到新值。</p></li><li><p>保证执行顺序：我们需要保证一组特定的语句严格按照语句顺序执行，而不被编译器和硬件优化乱序执行。</p></li></ol><p>接口从高到底的：future-&gt;promises-&gt;thread-&gt;mutex &amp; lock -&gt;condition variaable -&gt;atomic data type -&gt;fences<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[风险低-&gt;高][性能低-&gt;高]</span><br><span class="line">```  </span><br><span class="line">没有提到<span class="keyword">volatile</span>的原因，在java中这个关键字提供原子性顺序执行，但是在cpp 中没有提供这种保证，仅仅指定处理外部资源~不应该被优化</span><br><span class="line"></span><br><span class="line">#### <span class="number">2</span> mutex <span class="keyword">and</span> lock</span><br><span class="line"></span><br><span class="line">mutex :用于控制并行处理资源的排他性，资源可能是一个对象、多个对象的集合体</span><br><span class="line">lock  ：于mutex 统一使用</span><br><span class="line"></span><br><span class="line">辅助函数：完成初始化即使用的功能</span><br><span class="line">lock_guard&lt;&gt;</span><br><span class="line">unique_guard&lt;&gt;</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="built_in">std</span>::mutex printMutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; l(printMutex)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> elem : s)&#123;</span><br><span class="line">        ....<span class="comment">// handle ?process</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> f1 =<span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,print,<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">auto</span> f2 =<span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,print,<span class="string">"world"</span>);</span><br><span class="line">f1.get();</span><br><span class="line">f2.get();</span><br></pre></td></tr></table></figure></p><h4 id="3-递归锁-recursive-mutex"><a href="#3-递归锁-recursive-mutex" class="headerlink" title="3 递归锁 recursive_mutex"></a>3 递归锁 recursive_mutex</h4><p>循环锁定同一个信号量，典型的事例活动对象、监听器，内部包含了信号量和锁，但是其他方法同样包含，而且需要调用已经包含了信号量和锁的函数，则需要使用递归锁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseAccess</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::recursive_mutex dbMutex;</span><br><span class="line">    ... <span class="comment">// state of database access</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertData</span> <span class="params">(...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::recursive_mutex&gt; lg(dbMutex);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertData</span> <span class="params">(...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::recursive_mutex&gt; lg(dbMutex);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createTableAndinsertData</span> <span class="params">(...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::recursive_mutex&gt; lg(dbMutex);</span><br><span class="line">        ...</span><br><span class="line">    createTable(...); <span class="comment">// OK: no deadlock</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-try-and-timeout-lock"><a href="#4-try-and-timeout-lock" class="headerlink" title="4 try and timeout lock"></a>4 try and timeout lock</h4><p>有时候，程序想要获取一个锁，但是却不想阻塞，这种情况下，信号量mutex提供了try_lock() 成员函数会尝试获取一个锁，如果成功返回true,反之false<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="comment">// try to acquire a lock and do other stuff while this isn’t possible</span></span><br><span class="line"><span class="keyword">while</span> (m.try_lock() == <span class="literal">false</span>) &#123;</span><br><span class="line">    doSomeOtherStuff();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lg(m,<span class="built_in">std</span>::adopt_lock);</span><br><span class="line"><span class="comment">// Note that try_lock() might fail spuriously. </span></span><br><span class="line"><span class="comment">// That is, it might fail (return false) even if the lock is not taken.</span></span><br><span class="line"><span class="comment">// This behavior is provided for memory-ordering reasons but is not widely known</span></span><br></pre></td></tr></table></figure></p><p>如果你想指定一个时间的话，可以使用time_mutex<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::time_mutex m;</span><br><span class="line"><span class="comment">// try to acquire a lock and do other stuff while this isn’t possible</span></span><br><span class="line"><span class="keyword">while</span> (m.try_lock_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>)) == <span class="literal">false</span>) &#123;</span><br><span class="line">    doSomeOtherStuff();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lg(m,<span class="built_in">std</span>::adopt_lock);</span><br></pre></td></tr></table></figure></p><p>一般而言，如果你想锁住超过1个以上的信号量，比如 传输一个受保护的资源向另一个受保护的资源</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex m1;</span><br><span class="line"><span class="built_in">std</span>::mutex m2;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock (m1, m2); <span class="comment">// lock both mutexes (or none if not possible)</span></span><br><span class="line">    <span class="comment">//Note that this lock() provides a deadlock-avoidance mechanism</span></span><br><span class="line">    <span class="comment">//which, however, means that the order of locking inside a multiple lock is undefined.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * std::try_lock()</span></span><br><span class="line"><span class="comment">     * try_lock() does not provide a deadlock-avoidance mechanism. Instead, it guarantees</span></span><br><span class="line"><span class="comment">     * that the locks are tried in the order of the passed arguments</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lockM1(m1,<span class="built_in">std</span>::adopt_lock);</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lockM2(m2,<span class="built_in">std</span>::adopt_lock);</span><br><span class="line">...</span><br><span class="line">&#125; <span class="comment">// automatically unlock all mutexes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * only the code snippet</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">lock_guard <span class="title">lg</span><span class="params">(m)</span> <span class="comment">//Creates a lock guard for the mutex m and locks it</span></span></span><br><span class="line"><span class="function">lock_guard <span class="title">lg</span><span class="params">(m,adopt_lock)</span> <span class="comment">//Creates a lock guard for the already locked mutex m</span></span></span><br><span class="line">lg.~lock_guard()</span><br></pre></td></tr></table></figure><ul><li>unique_lock&lt;&gt;</li></ul><p>如果说lock_guard&lt;&gt;仅仅提供简单的初始化即使用的功能，其内部仅仅完成了mutex.lock() mutex.unlock()~</p><p>那么unique_lock&lt;&gt; 不但提供了lock_guard&lt;&gt;所具备的功能之外，还提供了更复杂的功能，他决定了你可以时间怎么去对一个信号量加锁和释放，因此这个锁的的对象可以在初始化的时候绑定信号量与否</p><p>从成员函数上来看，unique_lock&lt;&gt; 更为灵活，几乎和mutex保持着一致的成员函数~ 除吃之外，使用和lock_guard没有什么区别</p><ul><li>call_once<br>Sometimes multiple threads might not need some functionality that should get processed whenever the first thread needs it. A typical example is lazy initialization: The first time one of the threads needs something that has to get processed, you process it (but not before, because you want to save the time to process it if it is not needed).</li></ul><h4 id="5-条件变量-condition-variable"><a href="#5-条件变量-condition-variable" class="headerlink" title="5 条件变量 condition_variable"></a>5 条件变量 condition_variable</h4><p>有时候，一些线程需要等待其他线程执行的结果，因此你不得不因为一些其他原因不能够处理共享数据，而执行一些同步性的并行操作</p><p>future也可以处理这样的操作，一个线程等待另一个线程，但是只能处理一次，而实际上future的目的仅仅是为了返回值和异常</p><p>对于条件变量的实现，我们可以使用以下方式进行实现~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> readyFlag;</span><br><span class="line"><span class="built_in">std</span>::mutex readyFlagMutex;</span><br><span class="line"><span class="comment">// wait until readyFlag is true:</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; ul(readyFlagMutex);</span><br><span class="line">    <span class="keyword">while</span> (!readyFlag) &#123;</span><br><span class="line">        ul.unlock();</span><br><span class="line">        <span class="built_in">std</span>::this_thread::yield(); <span class="comment">// hint to reschedule to the next thread</span></span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">100</span>));</span><br><span class="line">        ul.lock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// release lock</span></span><br></pre></td></tr></table></figure><p>我们完全可以使用以上的方式实现我们的目的，至于为什么不使用，以下给予了解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The waiting thread consumes valuable processing time repeatedly checking the flag</span><br><span class="line">and when it locks the mutex the thread setting the ready flag is blocked. ...</span><br><span class="line">In addition, it’s hard to get the sleep period right: too short a sleep in between checks</span><br><span class="line">and the thread still wastes processing time checking, too long a sleep</span><br><span class="line">and the thread will carry on sleeping even when the task it is waiting for is complete,</span><br><span class="line">introducing a delay</span><br></pre></td></tr></table></figure><p>因而c++给我们提供了条件变量使用，condition_variable 和 mutex 一起配合使用,</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex queueMutex;</span><br><span class="line"><span class="built_in">std</span>::condition_variable queueCondVar;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">provider</span> <span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// push different values (val til val+5 with timeouts of val milliseconds into the queue</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lg(queueMutex);</span><br><span class="line">            <span class="built_in">queue</span>.push(val+i);</span><br><span class="line">        &#125; <span class="comment">// release lock</span></span><br><span class="line">        queueCondVar.notify_one();</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(val));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span> <span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// pop values if available (num identifies the consumer)</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; ul(queueMutex);</span><br><span class="line">        queueCondVar.wait(ul,[]&#123; <span class="keyword">return</span> !<span class="built_in">queue</span>.empty(); &#125;);</span><br><span class="line">        val = <span class="built_in">queue</span>.front();</span><br><span class="line">        <span class="built_in">queue</span>.pop();</span><br><span class="line">        &#125; <span class="comment">// release lock</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"consumer "</span> &lt;&lt; num &lt;&lt; <span class="string">": "</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// start three providers for values 100+, 300+, and 500+</span></span><br><span class="line">    <span class="keyword">auto</span> p1 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,provider,<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">auto</span> p2 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,provider,<span class="number">300</span>);</span><br><span class="line">    <span class="keyword">auto</span> p3 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,provider,<span class="number">500</span>);</span><br><span class="line">    <span class="comment">// start two consumers printing the values</span></span><br><span class="line">    <span class="keyword">auto</span> c1 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,consumer,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> c2 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,consumer,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-原子操作-atomic"><a href="#6-原子操作-atomic" class="headerlink" title="6 原子操作 atomic"></a>6 原子操作 atomic</h4><p>原子操作：意味着对于一个变量读取和写入都是原子的，与此同时通过atomic的成员函数来看，我们除了这些操作无法提供更为复杂的操作，比如对一个容器、结构体等共享变量做复杂的操作~</p><p>因而，原子操作更适用于基本数据类型~ int /bool /point</p><hr><p>Lock-Free - 无锁技术越来越被开发人员重视，因为锁对于性能的影响实在是太大了，所以如果想开发出一个高性能的程序，你就非常有必要学习 Lock-Free 的编程方式</p><p>菜鸟 正在飞翔<del>~</del><del>~</del>~~~</p><hr><h1 id="三-、异步"><a href="#三-、异步" class="headerlink" title="三 、异步"></a>三 、异步</h1><p>todo</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本来不想动~，想多看一点其他书~，但还是强迫自己写下这篇cpp11的线程概述~&lt;/p&gt;
&lt;p&gt;关于cpp的线程详解有一本书讲的蛮不错~，前一阵子再看《cpp concurrency in action》 主讲线程细节&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;一-、线程&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="cpp" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/cpp/"/>
    
      <category term="多线程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/cpp/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>cpp缓冲与流对象</title>
    <link href="http://yoursite.com/2019/03/04/cpp%E7%BC%93%E5%86%B2%E4%B8%8E%E6%B5%81%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2019/03/04/cpp缓冲与流对象/</id>
    <published>2019-03-04T13:50:56.000Z</published>
    <updated>2019-03-26T13:44:55.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a><img src="iosArchitect.png" alt="流类图"></h2><p>如上图就是cpp 流的结构~</p><p><strong>ios_base</strong> : 定义了所有流独立于字符类型和字符特征的共有的属性，这个类由流状态函数/流格式标记函数组成</p><p><strong>basic_ios&lt;&gt;</strong> :定了所有流共有的属性但是依赖于字符类型和字符特征，这个属性包含了使用了派生自basic_streambuf&lt;&gt;的流缓冲区，这个缓冲区执行确切的读写能力。</p><p><strong>basic_istream&lt;&gt; &amp;&amp; bacsic_ostream&lt;&gt;</strong>  : 虚继承了basic_ios&lt;&gt; ，分别用来读写</p><p><strong>basic_iostream&lt;&gt;</strong> : 派生自basic_istream&lt;&gt; &amp;&amp; bacsic_ostream&lt;&gt; 可以用来读和写</p><p><strong>basic_streambuf&lt;&gt;</strong> : 是iostream 库的核心，定了接口用来写向流和从流中读取字符，这些接口可以被其他流使用执行读写能力</p><h2 id="1-责任划分"><a href="#1-责任划分" class="headerlink" title="1. 责任划分"></a>1. 责任划分</h2><p>  派生自basic_ios只用来处理数据的格式、流的状态，而字符的读写被basic_streambuf&lt;&gt;执行，流缓冲区提供给其他流接口用来处理字符读写{socket、graphic、user interface component}</p><h2 id="2-流对象类别"><a href="#2-流对象类别" class="headerlink" title="2. 流对象类别"></a>2. 流对象类别</h2><ol><li>标准输入输出 :iostream 、istream 、ostream</li><li>文件流 : fstream</li><li>字符流 : stringstream</li></ol><h2 id="3-流的状态"><a href="#3-流的状态" class="headerlink" title="3. 流的状态"></a>3. 流的状态</h2><ol><li>goodbit: 一切都是正常的，没有任何bit位被设置</li><li>eofbit : 到达文件结尾</li><li>failbit: 发生错误，i/o操作不成功</li><li>badbit : 致命的错误，产生未定义状态</li></ol><p>对应的函数：good()、eof()、fail()、bad()、rdstate()、clear()、setstate()</p><h2 id="4-标准输入输出函数"><a href="#4-标准输入输出函数" class="headerlink" title="4. 标准输入输出函数"></a>4. 标准输入输出函数</h2><p>&lt;&lt; &amp;&amp; &gt;&gt;两个操作符是带有格式格式的输入输出方式，如果用户想用原生态数据（没有格式化），可以使用流的成员函数</p><h3 id="4-1-输入成员函数"><a href="#4-1-输入成员函数" class="headerlink" title="4.1 输入成员函数"></a>4.1 输入成员函数</h3><ol><li>get()</li><li>getline()</li><li>read()</li><li>readsome()</li></ol><h3 id="4-2-输出成员函数"><a href="#4-2-输出成员函数" class="headerlink" title="4.2 输出成员函数"></a>4.2 输出成员函数</h3><ol><li>put()</li><li>write()</li><li>flush()</li></ol><h3 id="4-3-流的辅助类-sentry"><a href="#4-3-流的辅助类-sentry" class="headerlink" title="4.3 流的辅助类 sentry"></a>4.3 流的辅助类 sentry</h3><p>辅助类形式<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sentry <span class="title">se</span><span class="params">(strm)</span></span>; <span class="comment">// indirect pre- and postprocessing</span></span><br><span class="line"><span class="keyword">if</span> (se) &#123;</span><br><span class="line">... <span class="comment">// the actual processing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>哨兵类用来做流对象的预处理和后处理的工作~</p><p>这些操作包括：同步几个流，检查流是否正常，是否跳过空格，实现特定任务{多线程环境下，完成相应的锁定}</p><h3 id="4-4-流格式操作"><a href="#4-4-流格式操作" class="headerlink" title="4.4 流格式操作"></a>4.4 流格式操作</h3><p>头文件<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>而对应的format 在std::ios::XXX</p><h4 id="4-4-1-成员函数"><a href="#4-4-1-成员函数" class="headerlink" title="4.4.1 成员函数"></a>4.4.1 成员函数</h4><p>流对象中</p><ol><li>setf</li><li>unsetf</li><li>flag </li><li>copyfmt</li><li>imbue  //set local object [internationalization]</li><li>getloc  //get the local object [internationalization]</li></ol><h4 id="4-4-2全局函数"><a href="#4-4-2全局函数" class="headerlink" title="4.4.2全局函数"></a>4.4.2全局函数</h4><p>这些函数在iomanip头文件中</p><ol><li>setiosflags</li><li>resetiosflags</li><li>… </li></ol><h2 id="5-文件流"><a href="#5-文件流" class="headerlink" title="5. 文件流"></a>5. 文件流</h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="fileArchi.png" alt="文件流类图"></h2><p>文件流派生自标准输入输出流，主要用于文件的读写</p><h3 id="5-1-文件打开标记"><a href="#5-1-文件打开标记" class="headerlink" title="5.1 文件打开标记"></a>5.1 文件打开标记</h3><ol><li>in</li><li>out</li><li>app<br>而这三者可以任意组合</li></ol><h3 id="5-2-文件随机处理指针"><a href="#5-2-文件随机处理指针" class="headerlink" title="5.2 文件随机处理指针"></a>5.2 文件随机处理指针</h3><p>输入流：</p><ol><li>tellg</li><li>seekg</li></ol><p>输出流：</p><ol><li>tellp</li><li>seekp</li></ol><h2 id="6-字符串流"><a href="#6-字符串流" class="headerlink" title="6. 字符串流"></a>6. 字符串流</h2><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="stringArchi.png" alt="字符串流类图"></h2><h3 id="6-1-成员函数"><a href="#6-1-成员函数" class="headerlink" title="6.1 成员函数"></a>6.1 成员函数</h3><p>输出流</p><ol><li>str() : 返回一个字符串</li><li>str(string) : 把string 设置成</li></ol><p>输入流：<br>“&gt;&gt;” 操作符，用来将缓冲区的数据输入到特定的类型</p><h2 id="7-输入流和输出流的连接"><a href="#7-输入流和输出流的连接" class="headerlink" title="7. 输入流和输出流的连接"></a>7. 输入流和输出流的连接</h2><p>通常而言，你需要连接两个流，比如可能需要确保在读取输入之前在屏幕上写入要求输入的文本，读写使用同一个流，操作相同的流使用不同的数据格式</p><h3 id="7-1-成员函数"><a href="#7-1-成员函数" class="headerlink" title="7.1 成员函数"></a>7.1 成员函数</h3><ol><li>tie() :返回一个已经绑定到流上的输出流指针</li><li>tie(ostream *strm) : 设置输出流对象，返回之前的流指针</li></ol><h3 id="7-2流缓冲区的绑定-释放"><a href="#7-2流缓冲区的绑定-释放" class="headerlink" title="7.2流缓冲区的绑定/释放"></a>7.2流缓冲区的绑定/释放</h3><ol><li>rdbuf() :返回流缓冲区的指针</li><li>rdbuf(streambuf* ) :设置流缓冲区，返回之前的缓冲区对象指针。</li></ol><p>利用流缓冲区的绑定和释放，我们可以实现重定向的作用<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redirect</span><span class="params">(ostream&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"the first row"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  redirect(<span class="built_in">cout</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"the last row"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redirect</span> <span class="params">(ostream&amp; strm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// save output buffer of the stream</span></span><br><span class="line"><span class="comment">// - use unique pointer with deleter that ensures to restore</span></span><br><span class="line"><span class="comment">// the original output buffer at the end of the function</span></span><br><span class="line">  <span class="keyword">auto</span> del = [&amp;](streambuf* p) &#123;</span><br><span class="line">  strm.rdbuf(p);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;streambuf,<span class="keyword">decltype</span>(del)&gt; origBuffer(strm.rdbuf(),del);</span><br><span class="line">  <span class="comment">// redirect ouput into the file redirect.txt</span></span><br><span class="line">  <span class="function">ofstream <span class="title">file</span><span class="params">(<span class="string">"redirect.txt"</span>)</span></span>;</span><br><span class="line">  strm.rdbuf (file.rdbuf());</span><br><span class="line">  file &lt;&lt; <span class="string">"one row for the file"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  strm &lt;&lt; <span class="string">"one row for the stream"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="comment">// closes file AND its buffer automatically</span></span><br></pre></td></tr></table></figure></p><p>基本上基础关于流的基础知识也就是这么多~</p><p>对于流缓冲区的使用，用户自定义模式~，这一步，将单独写一篇博客用来描述</p><p>sleeping~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;img src=&quot;iosArchitect.png&quot; alt=&quot;流类图&quot;&gt;&lt;/h2&gt;&lt;p&gt;如上图就是cpp 流的结构~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ios_base&lt;/
      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="cpp" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/cpp/"/>
    
      <category term="STL(类对象)" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/cpp/STL-%E7%B1%BB%E5%AF%B9%E8%B1%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>GoWeb &lt;1&gt;</title>
    <link href="http://yoursite.com/2019/03/03/goWeb/"/>
    <id>http://yoursite.com/2019/03/03/goWeb/</id>
    <published>2019-03-03T15:38:19.000Z</published>
    <updated>2019-04-04T01:52:22.093Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="go" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/go/"/>
    
      <category term="go web" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/go/go-web/"/>
    
    
  </entry>
  
  <entry>
    <title>个人博客简介</title>
    <link href="http://yoursite.com/2019/03/02/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2019/03/02/个人博客简介/</id>
    <published>2019-03-02T09:37:11.000Z</published>
    <updated>2019-04-06T14:07:52.609Z</updated>
    
    <content type="html"><![CDATA[<p>18年10月着手博客</p><p>博客都是我用自己的自由时间写出来的，仅仅代表自己观点和理解，如有人偶然访问到了本角落，倘若能给你帮助，那自然很好</p><hr><p>Max Ehrmann ‘《Desiderata 》</p><p>Go placidly amid the noise and haste,</p><p>and remember what peace there may be in silence.</p><p>As far as possible without surrender</p><p>be on good terms with all persons.</p><p>Speak your truth quietly and clearly;</p><p>and listen to others,</p><p>even the dull and the ignorant;</p><p>they too have their story.</p><hr><p>Avoid loud and aggressive persons,</p><p>they are vexations to the spirit.</p><p>If you compare yourself with others,</p><p>you may become vain and bitter;</p><p>for always there will be greater and lesser persons than yourself.</p><p>Enjoy your achievements as well as your plans.</p><hr><p>Keep interested in your own career, however humble;</p><p>it is a real possession in the changing fortunes of time.</p><p>Exercise caution in your business affairs;</p><p>for the world is full of trickery.</p><p>But let this not blind you to what virtue there is;</p><p>many persons strive for high ideals;</p><p>and everywhere life is full of heroism.</p><hr><p>Be yourself.</p><p>Especially, do not feign affection.</p><p>Neither be cynical about love;</p><p>for in the face of all aridity and disenchantment</p><p>it is as perennial as the grass.</p><hr><p>Take kindly the counsel of the years,</p><p>gracefully surrendering the things of youth.</p><p>Nurture strength of spirit to shield you in sudden misfortune.</p><p>But do not distress yourself with dark imaginings.</p><p>Many fears are born of fatigue and loneliness.</p><p>Beyond a wholesome discipline,</p><p>be gentle with yourself.</p><hr><p>You are a child of the universe,</p><p>no less than the trees and the stars;</p><p>you have a right to be here.</p><p>And whether or not it is clear to you,</p><p>no doubt the universe is unfolding as it should.</p><hr><p>Therefore be at peace with God,</p><p>whatever you conceive Him to be,</p><p>and whatever your labors and aspirations,</p><p>in the noisy confusion of life keep peace with your soul.</p><hr><p>With all its sham, drudgery, and broken dreams,</p><p>it is still a beautiful world.</p><p>Be cheerful.</p><p>Strive to be happy.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;18年10月着手博客&lt;/p&gt;
&lt;p&gt;博客都是我用自己的自由时间写出来的，仅仅代表自己观点和理解，如有人偶然访问到了本角落，倘若能给你帮助，那自然很好&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Max Ehrmann ‘《Desiderata 》&lt;/p&gt;
&lt;p&gt;Go placidly amid
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据类型</title>
    <link href="http://yoursite.com/2019/03/01/go%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/03/01/go数据类型/</id>
    <published>2019-02-28T16:04:57.000Z</published>
    <updated>2019-03-29T04:37:21.321Z</updated>
    
    <content type="html"><![CDATA[<p>go 中的数组和切片</p><p>自然而言的让我想起了cpp中的一些玩意</p><p>数组:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array:=[<span class="number">2</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">array:=[...]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">//or</span></span><br></pre></td></tr></table></figure></p><p>切片：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">slice:=[]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">slice:=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span></span><br></pre></td></tr></table></figure></p><p>好像也没太大的区别嘛</p><p>从声明上看，唯一的差别就是数组固定了长度，切片没有固定的长度</p><p>嗯 ~ ，其他差别呢~</p><p><strong>数组比较</strong></p><p>如果在cpp 中呢<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> b[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"the value is equality ? :"</span> &lt;&lt;boolalpha &lt;&lt;(a == b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//output is : false</span></span><br></pre></td></tr></table></figure></p><p>想想也是呢， 好歹人家也是数组也是可以当指针用来着，在不同的内存空间来着，地址不同，自然也就不同</p><p>但是在go中<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array1:=[<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">array2:=[...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">array1==array</span><br><span class="line"><span class="comment">//output: true</span></span><br></pre></td></tr></table></figure></p><p>相等的~！ 嗯~  在go中，好像把数组当成了一 基本类型再用</p><p>那你想啊，这不是还有切片啊</p><p>不过这个切片的确是不能比较的，他们只能和nil 进行比较</p><p>这个切片是scale型，又区别cpp的数组，行为倒是和vector容器有些相似~</p><p>因为内部同样有两个变量可控制，你可以理解为下面的形式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span>&#123;</span><br><span class="line">    ptr * <span class="keyword">int</span><span class="comment">//or other type //uint float32...</span></span><br><span class="line">    <span class="built_in">len</span> ,<span class="built_in">cap</span> <span class="keyword">uint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦超过容量cap ,人家也是要扩展的，这时候可能返回的指针会发生~~~~</p><p>切片人家还是安全性的</p><p>你要判断一个切片是否为空，最好使用len()函数</p><p>而不是使用 slice==nil的形式 ，因为</p><p><strong>slice:=[]int{}</strong> 这种情况下 切片不为空</p><p>好像说了半天，也不知道切片是干嘛的</p><p>嗯~</p><p>其实切片就是一个可以<strong>添加/修改/返回元素子序列</strong>的操作</p><p><strong>append()</strong>:用来添加一个/多个元素 ，或者自身 /其他切片</p><p><strong>slice[:]</strong>：用来返回子序列的 ，也返回了一个<strong>新的切片</strong>和原来的没关系</p><p>由于这种特性~</p><p>使得切片也变得相当灵活~</p><p>比如你可以完全用它实现一个stack/queue 数据结构 </p><p>用它拼接字符串</p><p>自由的插入字符</p><hr><p><strong>结构体</strong></p><p>结构体是基本类型的集合，在golang 中结构体支持anonymous struct，从而避免重复定义。</p><hr><p><strong>map</strong></p><p>map 该怎么说这个数据结构呢,map 有键值对的组成的，内置hash算法对值时刻进行放置</p><p>cpp 中关于map的容器都有<strong>map/unorder_map /mutilmap /unorder_map</strong> 四种类型，其中<strong>mutil 前缀表示key可以重复</strong> ,unorder前缀用来表示插入值的时候不需要排序，一般没有什么特殊的要求~,我们在cpp 中都是使用unordered_map这种容易。</p><p>在golang中的map 其实和unordered_map这种容器很相似，具体体现：1&gt;key是唯一的 2&gt;内部没有排序</p><ul><li>golang map声明<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mymap <span class="keyword">map</span>[<span class="keyword">type</span>]<span class="keyword">type</span> <span class="comment">//nil</span></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">mymap:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">type</span>]<span class="keyword">type</span>) <span class="comment">//len==0,but mymap!=nil</span></span><br><span class="line"></span><br><span class="line">mymap[<span class="string">"string"</span>]=<span class="keyword">int</span>(<span class="number">2</span>)<span class="comment">// 例子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//嵌套map</span></span><br><span class="line"><span class="keyword">var</span> mymap <span class="keyword">map</span>[<span class="keyword">type</span>]<span class="keyword">map</span>[<span class="keyword">type</span>]<span class="keyword">int</span></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">mymap:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">type</span>]<span class="keyword">map</span>[<span class="keyword">type</span>]<span class="keyword">int</span>)</span><br><span class="line">myint:=mymap[<span class="keyword">type</span>][<span class="keyword">type</span>]</span><br></pre></td></tr></table></figure></li></ul><p>看起来的好像map使用挺方便的，实际上，在我们插入的时候，进行了key的<strong>比较</strong>~，这里的比较不是排序的比较，而是操作符“==”的比较，那么至少就要求我们要对map变量key必须key可以比较。</p><p>那我们知道在golang 中slice /float 很难进行比较多的，但是我们又想让他们成为我们的key，这时候我们就要将这些 key 做一些处理，将其转化为我们可以比较的类型/方式</p><hr><p><strong>map 的排序输出</strong></p><p>我们知道map输出的元素是不一定的，但是有时候，我们需要将其排序输出那么该怎么办~</p><p>实际上，我们可以采用一种折中的方式进行处理，首先我们使用range 函数将 key set进行排序，之后通过索引map的key进行输出，从而达到，排序输出的目的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;go 中的数组和切片&lt;/p&gt;
&lt;p&gt;自然而言的让我想起了cpp中的一些玩意&lt;/p&gt;
&lt;p&gt;数组:&lt;br&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;
      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="go" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/go/"/>
    
      <category term="基本知识" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/go/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>平衡树</title>
    <link href="http://yoursite.com/2019/02/22/Go%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    <id>http://yoursite.com/2019/02/22/Go平衡树/</id>
    <published>2019-02-22T01:26:00.000Z</published>
    <updated>2019-03-29T04:24:25.057Z</updated>
    
    <content type="html"><![CDATA[<p>本篇使用go语言实现二叉树</p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>二叉树的创建与c/c++创建并无多大的异处。其关键之处还是在于掌握好一级指针和二级指针的使用，go语言同样支持这两种指针</p><p>本次使用的数据结构一切从简，不适用sentinel模式<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="keyword">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">createTree</span><span class="params">(tree **TreeNode, val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">       Treetmp := &amp;TreeNode&#123;val, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">       <span class="keyword">if</span> <span class="literal">nil</span> == *tree &#123;</span><br><span class="line">           *tree = Treetmp</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> val &gt; (*tree).Val &#123;</span><br><span class="line">           createTree(&amp;(*tree).Right, val)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           createTree(&amp;(*tree).Left, val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里你可能好奇 Treetmp 地址离开了作用域利用消失，此值无效，关于这个答案，我在《The Go Programming Language》</p><ul><li><p>It is perfectly safe for a function to return the address of a local variable</p></li><li><p>…</p></li><li><p>Because the lifetime of a variable is determined only by whether or not it is reachable, a local<br>variable may outlive a single iteration of the enclosing loop. It may continue to exist even after<br>its enclosing function has returned.</p></li></ul><p>因而 ，这也是优化点</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(tree *TreeNode)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">nil</span> != tree &#123;</span><br><span class="line">        fmt.Println(tree.Val)</span><br><span class="line">        <span class="built_in">print</span>(tree.Left)</span><br><span class="line">        <span class="built_in">print</span>(tree.Right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="avl-平衡"><a href="#avl-平衡" class="headerlink" title="avl 平衡"></a>avl 平衡</h1><p>二叉树失衡有四种模式，LL 、LR、RR、RL</p><p>以下实现了两种方式avl:</p><p>基本函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LLTree</span><span class="params">(root **TreeNode)</span></span> &#123;</span><br><span class="line">    newRoot := (*root).Left</span><br><span class="line">    oldRight := newRoot.Right</span><br><span class="line"></span><br><span class="line">    newRoot.Right = *root</span><br><span class="line">    (*root).Left = oldRight</span><br><span class="line">    (*root) = newRoot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RRTree</span><span class="params">(root **TreeNode)</span></span> &#123;</span><br><span class="line">    newRoot := (*root).Right</span><br><span class="line">    oldLeft := newRoot.Left <span class="comment">//old root will get left node</span></span><br><span class="line"></span><br><span class="line">    newRoot.Left = *root</span><br><span class="line">    (*root).Right = oldLeft</span><br><span class="line">    (*root) = newRoot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LRTree</span><span class="params">(root **TreeNode)</span></span> &#123;</span><br><span class="line">    RRTree(&amp;(*root).Left)</span><br><span class="line">    LLTree(root)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RLTree</span><span class="params">(root **TreeNode)</span></span> &#123;</span><br><span class="line">    LLTree(&amp;(*root).Right)</span><br><span class="line">    RRTree(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>获取树的深度：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMaxDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">nil</span> == root &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    leftDepth := getMaxDepth(root.Left) + <span class="number">1</span></span><br><span class="line">    RightDepth := getMaxDepth(root.Right) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> leftDepth &gt; RightDepth &#123;</span><br><span class="line">        <span class="keyword">return</span> leftDepth</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">return</span> RightDepth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>将一颗失衡的数，进行平衡</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B2Tree</span><span class="params">(root **TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">nil</span> == *root &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    leftDepth := B2Tree(&amp;(*root).Left) + <span class="number">1</span></span><br><span class="line">    RightDepth := B2Tree(&amp;(*root).Right) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> leftDepth-RightDepth &gt;= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="comment">//LX</span></span><br><span class="line">        <span class="keyword">if</span> B2Tree(&amp;(*root).Left) &gt; B2Tree(&amp;(*root).Right) &#123;</span><br><span class="line">            <span class="comment">//LL</span></span><br><span class="line">            LLTree(root)</span><br><span class="line">            <span class="keyword">return</span> getMaxDepth(*root)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//LR</span></span><br><span class="line">            LRTree(root)</span><br><span class="line">            <span class="keyword">return</span> getMaxDepth(*root)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> RightDepth-leftDepth &gt;= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="comment">//RX</span></span><br><span class="line">        <span class="keyword">if</span> B2Tree(&amp;(*root).Left) &gt; B2Tree(&amp;(*root).Right) &#123;</span><br><span class="line">            <span class="comment">//RL</span></span><br><span class="line">            RLTree(root)</span><br><span class="line">            <span class="keyword">return</span> getMaxDepth(*root)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//RR</span></span><br><span class="line">            RRTree(root)</span><br><span class="line">            <span class="keyword">return</span> getMaxDepth(*root)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> leftDepth &gt; RightDepth &#123;</span><br><span class="line">            <span class="keyword">return</span> leftDepth</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RightDepth</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>边插入边平衡</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createTreeBT</span><span class="params">(tree **TreeNode, val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    Treetmp := &amp;TreeNode&#123;val, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">nil</span> == *tree &#123;</span><br><span class="line">        *tree = Treetmp</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> val &gt; (*tree).Val &#123;</span><br><span class="line">        createTree(&amp;(*tree).Right, val)</span><br><span class="line">        <span class="keyword">if</span> getMaxDepth((*tree).Right)-getMaxDepth((*tree).Left) &gt;= <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> val &gt; (*tree).Right.Val &#123;</span><br><span class="line">                <span class="comment">//RR</span></span><br><span class="line">                RRTree(tree)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//RL</span></span><br><span class="line">                RLTree(tree)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createTree(&amp;(*tree).Left, val)</span><br><span class="line">        <span class="keyword">if</span> getMaxDepth((*tree).Left)-getMaxDepth((*tree).Right) &gt; <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> val &gt; (*tree).Left.Val &#123;</span><br><span class="line">                <span class="comment">//LR</span></span><br><span class="line">                LRTree(tree)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//LL</span></span><br><span class="line">                LLTree(tree)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇使用go语言实现二叉树&lt;/p&gt;
&lt;h1 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h1&gt;&lt;h2 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
</feed>
