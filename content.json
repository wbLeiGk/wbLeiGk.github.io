{"meta":{"title":"QK","subtitle":null,"description":null,"author":"lwb","url":"http://yoursite.com"},"pages":[{"title":"About","date":"2019-01-31T10:52:58.271Z","updated":"2019-01-31T10:52:58.271Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"专业：计算机科学与技术 毕业：17届 技能栈：c/c++/python/go 目前从事：音视频对讲 email：leiwb.gk =&gt;Google eg : 16年CAD软件开发 17年网络安全 18年音视频对讲"},{"title":"Categories","date":"2019-01-31T10:50:15.859Z","updated":"2018-11-30T03:26:01.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-01-31T10:50:15.860Z","updated":"2018-11-30T03:26:01.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"生活小记2","slug":"life-record2","date":"2019-02-25T14:46:48.000Z","updated":"2019-02-25T15:12:22.978Z","comments":true,"path":"2019/02/25/life-record2/","link":"","permalink":"http://yoursite.com/2019/02/25/life-record2/","excerpt":"","text":"2019 / 2 / 25 能够阻挡得似乎是你 能够说服你的还是你 能够原谅你的还是你 . . . 我曾羡慕过很多人 现在依旧，未来还是 但是似乎我并讨厌自己现在的处境 我喜欢努力的自己 不够用心的努力的你，让我不甚喜欢 很多世俗的道理，你看过，你听过，你经历过 但是并不意味，你一定去选择接受与否 喜欢你用心的感受这个世界 学会感受 不论是否喜欢，有时候选择去经历一下，好像也并没有那么糟 对于这个大千世界，你是一个孩子 不要放弃任何学习的机会，很多时候并不是能力限制了你 而是你自己成为了你的阻碍 请多请教，多思考 今日起的你，应该面带笑容 是发自内心的笑容 是自我承认的笑容 是勇敢面对的笑容 是欣赏他人的笑容 是尊重他人的笑容 你看，你还真不够成熟 u just a kid just run chasing the sunset","categories":[{"name":"个人生活","slug":"个人生活","permalink":"http://yoursite.com/categories/个人生活/"}],"tags":[]},{"title":"实现二叉树平衡","slug":"GoTree","date":"2019-02-22T01:26:00.000Z","updated":"2019-02-25T15:04:39.657Z","comments":true,"path":"2019/02/22/GoTree/","link":"","permalink":"http://yoursite.com/2019/02/22/GoTree/","excerpt":"","text":"本篇使用go语言实现二叉树 二叉树结构二叉树的创建与c/c++创建并无多大的异处。其关键之处还是在于掌握好一级指针和二级指针的使用，go语言同样支持这两种指针 本次使用的数据结构一切从简，不适用sentinel模式12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 创建123456789 func createTree(tree **TreeNode, val int) &#123; Treetmp := &amp;TreeNode&#123;val, nil, nil&#125; if nil == *tree &#123; *tree = Treetmp &#125; else if val &gt; (*tree).Val &#123; createTree(&amp;(*tree).Right, val) &#125; else &#123; createTree(&amp;(*tree).Left, val)&#125; 在这里你可能好奇 Treetmp 地址离开了作用域利用消失，此值无效，关于这个答案，我在《The Go Programming Language》 It is perfectly safe for a function to return the address of a local variable … Because the lifetime of a variable is determined only by whether or not it is reachable, a localvariable may outlive a single iteration of the enclosing loop. It may continue to exist even afterits enclosing function has returned. 因而 ，这也是优化点 遍历1234567func print(tree *TreeNode) &#123; if nil != tree &#123; fmt.Println(tree.Val) print(tree.Left) print(tree.Right) &#125;&#125; avl 平衡二叉树失衡有四种模式，LL 、LR、RR、RL 以下实现了两种方式avl: 基本函数：1234567891011121314151617181920212223242526func LLTree(root **TreeNode) &#123; newRoot := (*root).Left oldRight := newRoot.Right newRoot.Right = *root (*root).Left = oldRight (*root) = newRoot&#125;func RRTree(root **TreeNode) &#123; newRoot := (*root).Right oldLeft := newRoot.Left //old root will get left node newRoot.Left = *root (*root).Right = oldLeft (*root) = newRoot&#125;func LRTree(root **TreeNode) &#123; RRTree(&amp;(*root).Left) LLTree(root)&#125;func RLTree(root **TreeNode) &#123; LLTree(&amp;(*root).Right) RRTree(root)&#125; 获取树的深度：1234567891011func getMaxDepth(root *TreeNode) int &#123; if nil == root &#123; return 0 &#125; leftDepth := getMaxDepth(root.Left) + 1 RightDepth := getMaxDepth(root.Right) + 1 if leftDepth &gt; RightDepth &#123; return leftDepth &#125; return RightDepth&#125; 将一颗失衡的数，进行平衡 1234567891011121314151617181920212223242526272829303132333435func B2Tree(root **TreeNode) int &#123; if nil == *root &#123; return 0 &#125; leftDepth := B2Tree(&amp;(*root).Left) + 1 RightDepth := B2Tree(&amp;(*root).Right) + 1 if leftDepth-RightDepth &gt;= 2 &#123; //LX if B2Tree(&amp;(*root).Left) &gt; B2Tree(&amp;(*root).Right) &#123; //LL LLTree(root) return getMaxDepth(*root) &#125; else &#123; //LR LRTree(root) return getMaxDepth(*root) &#125; &#125; else if RightDepth-leftDepth &gt;= 2 &#123; //RX if B2Tree(&amp;(*root).Left) &gt; B2Tree(&amp;(*root).Right) &#123; //RL RLTree(root) return getMaxDepth(*root) &#125; else &#123; //RR RRTree(root) return getMaxDepth(*root) &#125; &#125; else &#123; if leftDepth &gt; RightDepth &#123; return leftDepth &#125; return RightDepth &#125;&#125; 边插入边平衡 12345678910111213141516171819202122232425262728func createTreeBT(tree **TreeNode, val int) &#123; Treetmp := &amp;TreeNode&#123;val, nil, nil&#125; if nil == *tree &#123; *tree = Treetmp &#125; else if val &gt; (*tree).Val &#123; createTree(&amp;(*tree).Right, val) if getMaxDepth((*tree).Right)-getMaxDepth((*tree).Left) &gt;= 2 &#123; if val &gt; (*tree).Right.Val &#123; //RR RRTree(tree) &#125; else &#123; //RL RLTree(tree) &#125; &#125; &#125; else &#123; createTree(&amp;(*tree).Left, val) if getMaxDepth((*tree).Left)-getMaxDepth((*tree).Right) &gt; 2 &#123; if val &gt; (*tree).Left.Val &#123; //LR LRTree(tree) &#125; else &#123; //LL LLTree(tree) &#125; &#125; &#125;&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"go","slug":"编程语言/go","permalink":"http://yoursite.com/categories/编程语言/go/"}],"tags":[]},{"title":"(2) go并发概述 1","slug":"goGoroutine","date":"2019-02-17T14:24:47.000Z","updated":"2019-02-19T11:58:33.990Z","comments":true,"path":"2019/02/17/goGoroutine/","link":"","permalink":"http://yoursite.com/2019/02/17/goGoroutine/","excerpt":"","text":"并发关键字go GoLang 使用go 关键字进行多并发操作 123456789//example 1go func()&#123; fmt.Println(\"hello world\")&#125;//example 2func hello()&#123; fmt.Println(\"hello world\")&#125;go hello() 同步操作: channelGoLang 使用Channels 进行多个协程之间进行同步操纵，它更像是一个管道，发送值到管道，再从值取回来 等待channel 操作 : selectgo 与 channel 结合select 是一个强大的工作123456789101112131415161718c1 := make(chan string, 1)c2 := make(chan string, 1)go func() &#123; time.Sleep(2 * time.Second) c1 &lt;- \"hello\"&#125;()go func() &#123; time.Sleep(5 * time.Second) c2 &lt;- \"world\"&#125;()for index := 0; index &lt; 2; index++ &#123; select &#123; case msg1 := &lt;-c1: fmt.Println(\"the msg1 value is : \", msg1) case msg2 := &lt;-c2: fmt.Println(\"the msg2 value is : \", msg2) &#125;&#125; 定时器timeer1234// 只执行指定时间 一次mytime:=time.NewTimer(time.second)&lt;-mytime.Cmytime.stop() ticker123456myticker:=time.NewTicker(time.second)for &#123; &lt;-myticker.C fmt.Println(time.now())&#125;myticker.stop()","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"go","slug":"编程语言/go","permalink":"http://yoursite.com/categories/编程语言/go/"}],"tags":[]},{"title":"(1) go初识","slug":"gonovice","date":"2019-02-17T04:03:45.000Z","updated":"2019-02-17T14:28:28.004Z","comments":true,"path":"2019/02/17/gonovice/","link":"","permalink":"http://yoursite.com/2019/02/17/gonovice/","excerpt":"","text":"变量变量 12345678910111213141516171819var name nametype// for example var myvar int /float32 /string /boolvar myvar = 12 /12.2/true/\"hello\" //infer the var typemyvar := 12 /12.2/true/\"hello\" //must use : operator characteristic//pointervar name *nametype//切片和数组类似，不过切片比数组支持更多的操作//你可以将其理解为数量不等的集合//申请0个空间是一种位置，随后使用的时候，可以在进行申请空间//相对而言，slice更加方便一些//arrayvar arrayname [][]int /float32/string /bool//slicessilces:=make(type,length)//map dictionarymapName:=make(map[key-type]value-type) 控制结构控制结构只有三种形式： for 循环123for [[initialize][;condition;][caculate]]&#123;&#125; if 条件123if [initialize ;][condition]&#123;&#125;[else if&#123;&#125;][else&#123;&#125;] switch 条件123456switch [condition] &#123; case [result[condition]]: [break] default: [break]&#125; 遍历通过for 循环语句是使用关键字range 遍历数组/切片/map1234for [key/index[_]] ,value :=range mapvar&#123; //todo //execute some statement&#125; 函数函数声明形式123func [funName]() return-type&#123;&#125; 根据函数形式大致为了以下几种： 普通函数1234//examplefunc plus(a,b int)int&#123; return a+b&#125; 可变参数函数12345678910 //example func sum(nums ...int) &#123; fmt.Print(nums, \" \") total := 0 for _, num := range nums &#123; total += num &#125; fmt.Println(total) &#125;&#125; 匿名函数12//example fmt.Println(\"the return value is : \", func() int &#123; return 4 &#125;()) 闭包函数12345678910111213//examplefunc initSqu() func()int &#123; i:=0 return func()int&#123; i++ return i &#125;&#125;//to use nextInit:=initSqu()nextInit() //1nextInit() //2//because they hava function address 递归函数123456789//recusionfunc factorial(n int) int&#123; if 0==n &#123; return 1 &#125; return n*factorial(n-1)&#125;//to usefmt.println(\"the factorial value is : \",factorial(3)) 结构体与方法/接口123456789101112131415161718192021222324252627282930313233//接口type geometry interface &#123; area() float64 perimeter() float64&#125;//example //结构体type rect struct&#123; width,height float64&#125;type circle stuct&#123; radius float64&#125;// 方法func (r rect) area() float64&#123; return r.width*r.hight&#125;func (r rect) perimeter float64&#123; return r.width*2 + r.hight*2&#125;func (c circle) area float64&#123; return math.Pi * c.radius * c.radius&#125;func (c circle) perimeter() float64&#123; return 2 * math.Pi * c.radius&#125;//to use func measure(g geometry)&#123; fmt.Println(g.area()) fmt.Println(g.perimeter())&#125;rcValue:=rect&#123;12,2&#125;measure(rcValue)","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"go","slug":"编程语言/go","permalink":"http://yoursite.com/categories/编程语言/go/"}],"tags":[]},{"title":"生活小记","slug":"life_record1","date":"2019-02-16T00:38:45.000Z","updated":"2019-02-25T15:04:29.614Z","comments":true,"path":"2019/02/16/life_record1/","link":"","permalink":"http://yoursite.com/2019/02/16/life_record1/","excerpt":"","text":"2019 / 2 / 16 乌鲁木齐机场 打开电脑随手写下了这篇文章，就想到哪写到哪了 [ 02 / 16 上午] 与昨日，我与母亲倾诉了内心的想法：我到底改往何方 母亲回了我一句：去年我曾劝过你，留在事业单位，现在你后悔嘛 我愣了一下 [ 02 / 15 下午] 在乌市出发前碰到了我儿时的同学 【张】 于是开玩笑道：给我5元钱，我帮你承担 [考研] 成绩的压力 晚上，我们在一起吃了个饭，我问他想去哪 他话语间流露，想要出去走走，不想呆在新疆了，他说这个地方他呆够了，现在他特别想到处逛逛 “你准备在成家？” 他说：“在江苏吧，也许其他地方…” 晚上的《流浪地球》挺好看的 晚上，继昨天一样，失眠了 我已经不记得儿时曾经发过什么誓言，想要成为什么样的人 我也不知道我是不是成为了自己讨厌的人 . . . 今年我26 ，而我的路，我不知道该向哪里 甚至看书，有时候都在发呆 我不知道您是否被这么一句话所影响 : 走正确的路 什么是正确的路啊 蒙上眼睛，走那个方向都是前方 . . .","categories":[{"name":"个人生活","slug":"个人生活","permalink":"http://yoursite.com/categories/个人生活/"}],"tags":[]},{"title":"基于权重的任务调度","slug":"task-shchedule-weight","date":"2018-12-10T06:36:12.000Z","updated":"2019-02-17T03:11:31.319Z","comments":true,"path":"2018/12/10/task-shchedule-weight/","link":"","permalink":"http://yoursite.com/2018/12/10/task-shchedule-weight/","excerpt":"","text":"","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[]},{"title":"路由器数据层","slug":"router-data-plane","date":"2018-12-09T09:10:21.000Z","updated":"2019-02-17T03:11:47.580Z","comments":true,"path":"2018/12/09/router-data-plane/","link":"","permalink":"http://yoursite.com/2018/12/09/router-data-plane/","excerpt":"","text":"网络层有两个关键的功能 转发 当一个数据包到达输入端口时，router 移动数据包到合适的输出端口 路由 在整个网络中，局域网/广域网等 数据包从源地址到目的路之间的传输路径，而路径的选择时路由，一般路由可能时路由算法控制，或者手动设置 本篇重点放在路由器转发上面 router component input ports 执行物理层/链路层功能，同时还会执行检索功能对输入的数据进行检索，然后输出到合适的 output ports output ports 存储从switch fabric 处过来的数据包，然后转发这些这些数据包到出口[outgoing link：链接到链路层和物理层] switch fabric 连接 input port 和output port routing processor 执行control-plane 功能，一般用于路由协议 forward based information一般来说，转发大致基于两种情况 基于目的IP 此种方式根据数据包目的IP，然后对照路由表，选择合适的输出端口 基于全部信息 相对的，此种方式就不仅仅依据目的IP了，与此同时参考的信息还会有：源目的、网络拥塞状态等 switch fabricswitch fabric是路由器的核心，数据包从input port 穿过switch fabric 然后到 output port ，switch fabric 有一下几种实现方式 switching via memory 传统的router实现方式，数据包从input port 到达之后，通过中断的方式通知 router processor，然后共享内存复制数据包到合适的output ports buffers switching via bus input port 直接通过bus 传输数据包到output port,由于bus只有一条，因此不能同时传输数据，转发速度受制于bus的转发速度 switching via an interconnection network interconnection network 使用cross-bar 的方式，这就意味着N-N的转发方式 queue delay无论是input port 还是output port 都会发生queue delay ,也就是wait的意思 input port queue 当switch fabric 处理速度赶不上 input port 速度的时候 output port queue 多个数据包被转发到相同的output ports，当output ports buffer 满了的时候，就会发生packet drop 事件 outgoing link packet schedule FIFO 最先进入queue的数据包最新被转发出去 priority 根据优先级/权重对数据包进行分类[class i]，然后循环遍历classes,输出queue 中的数据包","categories":[{"name":"network","slug":"network","permalink":"http://yoursite.com/categories/network/"}],"tags":[{"name":"network","slug":"network","permalink":"http://yoursite.com/tags/network/"}]},{"title":"android NDK","slug":"android-NDK","date":"2018-12-05T08:59:50.000Z","updated":"2019-02-17T03:57:51.857Z","comments":true,"path":"2018/12/05/android-NDK/","link":"","permalink":"http://yoursite.com/2018/12/05/android-NDK/","excerpt":"","text":"最近维护了公司的一个JNI项目，面向java/android平台使用，有幸接触了Java/Android 平台与c/c++ 的交互使用。 Java 与 c/c++ 交互使用 dll 形式 Android 与c/C++ 交互使用.so文件格式 预备知识JNI 基础概念 JNI 编程基础 android.mk 编写 假使我认为您已经能够使用c/c++ 编程，基本能够使用android studio的使用，不使用亦可以 Java 使用dllc语言头文件生成 使用javac javaName.java 生成.class 文件 使用javah javaName 生成 .h 头文件 note: 倘如您的java中有包名，那么退回到包名的根目录，使用以下形式的命令 javac com\\application\\javaName.java 生成.class 文件 avah com.application.javaName 生成 .h 头文件 如下图 本实验的代码： jni_md.h /jni.h 文件在安装的JDK进行提供 MainJava.java 12345678910 public class MainJava &#123; static&#123; System.loadLibrary(\"MainJava\"); &#125; public native String printTest(); public static void main(String[] args) &#123; System.out.println(new MainJava().printTest()); &#125;&#125; MainJava.h 123456789101112131415161718192021/* DO NOT EDIT THIS FILE - it is machine generated */#include \"jni.h\"/* Header for class MainJava */#ifndef _Included_MainJava#define _Included_MainJava#ifdef __cplusplusextern \"C\" &#123;#endif/** Class: MainJava* Method: printTest* Signature: ()Ljava/lang/String;*/JNIEXPORT jstring JNICALL Java_MainJava_printTest(JNIEnv *, jobject);#ifdef __cplusplus&#125;#endif#endif MainJava.c 12345 #include\"MainJava.h\"JNIEXPORT jstring JNICALL Java_MainJava_printTest (JNIEnv *env, jobject thisobj)&#123; return (*env)-&gt;NewStringUTF(env,\"this is c level\"); &#125; makefile 12345678910CC=gccRESULT=MainJava.dllCFLAG= -Wall -sharedsource=*.c$(RESULT):$(source) $(CC) $(CFLAG) $^ -o $@clean: del $(RESULT) Android使用 .so 文件生成 .so文件可以使用android studio中的内置的NDK-build ，也可以选择手动生成，我这里使用手动生成。NDK-build下载 需要将javac/javah 生成的 .h /.c /android.mk application.mk 文件放入jni 文件夹中，然后在此目录中运行ndk-build 命令 如下图 将生成的libs 拷贝到android 项目中的app/libs下面 在app/build.gradle中加入 123456.....sourceSets&#123; main&#123; jniLibs.srcDirs=['libs'] &#125;&#125; 效果如下 后语对于一些使用底层代码使用c/c++的程序，常常使用这种方式，移植到其他平台上，android/java 作为业务层呈现","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"android","slug":"编程语言/android","permalink":"http://yoursite.com/categories/编程语言/android/"}],"tags":[{"name":"NDK","slug":"NDK","permalink":"http://yoursite.com/tags/NDK/"}]},{"title":"TCP 传输机制","slug":"TCP-transport-institution","date":"2018-11-15T00:40:55.000Z","updated":"2018-12-09T09:10:41.007Z","comments":true,"path":"2018/11/15/TCP-transport-institution/","link":"","permalink":"http://yoursite.com/2018/11/15/TCP-transport-institution/","excerpt":"","text":"说起TCP，第一印象是什么，嗯，可靠，面向连接。面向连接是每一个连接都是独立的。而对于可靠性，我的理解逻辑则按照下面的流程 TCP 流控制流控制涉及到了TCP中windows size fidld,对于TCP而言，在每一个TCP成功建立的连接都会初始化两个缓冲区，发送缓冲区和接收缓冲区，window size 的字段就是为了防止缓冲区数据溢出从而做出了设置，对于接收者，我们假设有两个变量 LastByteRead：从缓冲区最后读取的位置 LastByteRcvd：从缓冲区最后接收数据的位置 RcvBuffer：缓冲区的大小LastByteRcvd-LastByteRead&lt;=RcvBuffer 因而，我们要将通常将window size 设置成 cwnd = RcvBuffer-LastByteRcvd-LastByteRead，从而保证接收缓冲区不被溢出。相应的发送缓冲区 LastByteSent−LastByteAcked≤ cwnd 运用这一规则，在网络攻击中将windows size的值设置为1，就构成了http slow 攻击。 TCP 拥塞控制首先大部分TCP拥塞控制时端对端的。相对应的有一个网络协助方式（network-assist） 如果说流控制是控制避免TCP 缓冲区溢出，那么congestion control 就是在网络状态不好时，对TCP 发送流量进行控制，从而避免大量数据包丢失。 拥塞控制在TCP数据段中没有相应字段表示，但是还有有一个字段与他相关，那是ACK这个字段，拥塞能控制会根据接收到的ACK情况从而调整他的发送速率。 在TCP 发送数据过程中有三个阶段：此图来自《computer networking top to down》 从上图的状态图可以看到： 在slow start:一旦正确接收到ack,那么cwnd增长时指数级别的，一旦发生数据超时，拥塞控制状态中，此时cwnd数值除以2。或者接收到3此重复的ACK（超时之前），进入快速重传阶段。 拥塞控制：在这个阶段，cwnd数据增长就比较慢了，由于各个平台实现TCP差异，但是总的原则不会变，他增长速率，同样的在这个状态下，一旦发送超时，或者ACK重复的情况，依旧会Cwnd 数值减半 快速恢复：这个状态不是必要存在的，进入此状态的条件时ACK 重复，此状态结束之后，一般会进入拥塞控制阶段 TCP 流量竞争 一般来说，理想情况下，TCP连接时会平分网络节点的吞吐量的，但是由于每个TCP通过的路径的可能会有所差异，导致的网络状态的波动之类的情况，导致拥塞控制，可能会造成TCP流量的不平均的情况，因而，每个应用程序中TCP的连接数量的不同也会竞争流量，从而导致应用程序得到节点吞吐量不一样。 当然UDP 可能就不会出现这种情况，因为不存在拥塞控制这一机制，收到就接收，收不到就收不到。 网络协助方式此种方式时应用网络数据包丢失之类从而造成的拥塞控制对发送者进行一种反馈情况。 简单来说，TCP end-to-end 拥塞控制的形式，是根据ACK的情况进行判断网络状态，没有任何网络层参与，但是现在网络协助这种方式，是网络层根据网络状态直接将状态信息发送给接收端或者发送端的一种行为。 网络层反馈给发送者：将网络状态直接发送给发送端 网络层发聩给接收者，由接收者发送给发送者： 接收端收到网络状态信息后，将此信息与ACK一起发送给发送端 总结总的来说，TCP一直在处于发展中，目前而言也有类似其他的协议如DCCP(datagram congestion control Protocol)、DCTCP(data center TCP)、QUIC(quick udp internet connection,google 使用)、TFRC(TCP-friendly rate control,传输速率更平稳)、STTP….无论哪一种使用，哪一种更好，不仅仅取决其技术性，也取决社会行，商业性。","categories":[{"name":"network","slug":"network","permalink":"http://yoursite.com/categories/network/"}],"tags":[{"name":"network","slug":"network","permalink":"http://yoursite.com/tags/network/"}]},{"title":"复路分解与多复路","slug":"TCP-IP-demultipexing-multiplexing","date":"2018-11-13T12:37:21.000Z","updated":"2018-12-09T09:08:16.856Z","comments":true,"path":"2018/11/13/TCP-IP-demultipexing-multiplexing/","link":"","permalink":"http://yoursite.com/2018/11/13/TCP-IP-demultipexing-multiplexing/","excerpt":"","text":"复路分离与多复路发生在传输层的一种行为。 demultiplexing: At the receiving end, the transport layer examines these fields to identify the receiving socket and then directs the segment to that socket. This job of delivering the data in a transport-layer segment to the correct socket is called demultiplexing multiplexing: The job of gathering data chunks at the source host from different sockets, encapsulating each data chunk with header information (that will later be used in demultiplexing) to create segments, and passing the segments to the network layer is called multiplexing 中文含义 复路分离 在接收端，传输层根据数据段中的头字段特定字段[UDP：源port/目的port、TCP：源IP/port,目的IP/port]对数据帧进行分类，派送到不同的socket通道中，这个过程就是复路分离 多复路 传输层从上层应用层中不同的应用（socket）接收数据，然后封装成一个数据帧，派送到网络层，这个过程是多复路 那么具体流程是什么样的，请见下图 怎么看待socket socket 是接口 开发人员如果进行网络编程，使用socket 是不少的，现在比较常见的传输层协议常见TCP,UDP,SCTP,DCCP。socket是传输层与应用层的抽象网络接口，因此网络数据不可能直接通过应用层直接送到网络层，反之亦然，开发人员在应用层对socket拥有一切控制权，但是在传输层只有少量的控制权。 用socket干什么 上述所讲，socket 是接口，是建立在应用层和传输层之间的抽象层，因此对于低层的协议/数据，我们丝毫不用关心。举个例子，我们现在使用ftp 协议，我们只需要关系ftp中的对话规则，我怎么知道对话规则，直接找到RFC 文档，找到协议规则。不需要关心这个数据怎么传输到对方的。我们只需要做到知道两件事：我发送了什么 我接收到了什么。这样看来，使用socket 就像是一个黑匣子，放进去什么东西，出来了什么东西。就是这么简单？ 对，就是这样 TCP 和 UDP 建立通信的区别 UDP if two UDP segments have different source IP addresses and/or source port numbers, but have the same destination IP address and destination port number, then the two segments will be directed to the same destination process via the same destination socket. TCP In particular, and in contrast with UDP, two arriving TCP segments with different source IP addresses or source port numbers will (with the exception of a TCP segment carrying the original connectionestablishment request) be directed to two different sockets socket 是跨进程的，是一个系统资源，通过上述两段文字，从字面上看，TCP 是每来一个客户端，便建立一个socket 资源，UDP 则始终是一条socket 接收使用。但是善于利用的人，可针对这些特点，进行恶意的消耗资源 结束语本文只是针对了TCP/UDP 在网络框架（TCP/IP 5层结构）中一个大概的位置和作用，需要更加进行了解的请移步computer_network_top_to_down","categories":[{"name":"network","slug":"network","permalink":"http://yoursite.com/categories/network/"}],"tags":[{"name":"network","slug":"network","permalink":"http://yoursite.com/tags/network/"}]}]}