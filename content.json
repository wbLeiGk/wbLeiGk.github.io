{"meta":{"title":"QK","subtitle":null,"description":null,"author":"lwb","url":"http://yoursite.com"},"pages":[{"title":"Categories","date":"2019-01-31T10:50:15.859Z","updated":"2018-11-30T03:26:01.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2019-01-31T10:52:58.271Z","updated":"2019-01-31T10:52:58.271Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"专业：计算机科学与技术 毕业：17届 技能栈：c/c++/python/go 目前从事：音视频对讲 email：leiwb.gk =&gt;Google eg : 16年CAD软件开发 17年网络安全 18年音视频对讲"},{"title":"Tags","date":"2019-01-31T10:50:15.860Z","updated":"2018-11-30T03:26:01.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"基于权重的任务调度","slug":"task-shchedule-weight","date":"2018-12-10T06:36:12.000Z","updated":"2018-12-10T06:40:25.873Z","comments":true,"path":"2018/12/10/task-shchedule-weight/","link":"","permalink":"http://yoursite.com/2018/12/10/task-shchedule-weight/","excerpt":"","text":"","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"路由器数据层","slug":"router-data-plane","date":"2018-12-09T09:10:21.000Z","updated":"2018-12-09T10:23:25.328Z","comments":true,"path":"2018/12/09/router-data-plane/","link":"","permalink":"http://yoursite.com/2018/12/09/router-data-plane/","excerpt":"","text":"网络层有两个关键的功能 转发 当一个数据包到达输入端口时，router 移动数据包到合适的输出端口 路由 在整个网络中，局域网/广域网等 数据包从源地址到目的路之间的传输路径，而路径的选择时路由，一般路由可能时路由算法控制，或者手动设置 本篇重点放在路由器转发上面 router component input ports 执行物理层/链路层功能，同时还会执行检索功能对输入的数据进行检索，然后输出到合适的 output ports output ports 存储从switch fabric 处过来的数据包，然后转发这些这些数据包到出口[outgoing link：链接到链路层和物理层] switch fabric 连接 input port 和output port routing processor 执行control-plane 功能，一般用于路由协议 forward based information一般来说，转发大致基于两种情况 基于目的IP 此种方式根据数据包目的IP，然后对照路由表，选择合适的输出端口 基于全部信息 相对的，此种方式就不仅仅依据目的IP了，与此同时参考的信息还会有：源目的、网络拥塞状态等 switch fabricswitch fabric是路由器的核心，数据包从input port 穿过switch fabric 然后到 output port ，switch fabric 有一下几种实现方式 switching via memory 传统的router实现方式，数据包从input port 到达之后，通过中断的方式通知 router processor，然后共享内存复制数据包到合适的output ports buffers switching via bus input port 直接通过bus 传输数据包到output port,由于bus只有一条，因此不能同时传输数据，转发速度受制于bus的转发速度 switching via an interconnection network interconnection network 使用cross-bar 的方式，这就意味着N-N的转发方式 queue delay无论是input port 还是output port 都会发生queue delay ,也就是wait的意思 input port queue 当switch fabric 处理速度赶不上 input port 速度的时候 output port queue 多个数据包被转发到相同的output ports，当output ports buffer 满了的时候，就会发生packet drop 事件 outgoing link packet schedule FIFO 最先进入queue的数据包最新被转发出去 priority 根据优先级/权重对数据包进行分类[class i]，然后循环遍历classes,输出queue 中的数据包","categories":[{"name":"network","slug":"network","permalink":"http://yoursite.com/categories/network/"}],"tags":[{"name":"network","slug":"network","permalink":"http://yoursite.com/tags/network/"}]},{"title":"android NDK","slug":"android-NDK","date":"2018-12-05T08:59:50.000Z","updated":"2018-12-09T09:07:04.957Z","comments":true,"path":"2018/12/05/android-NDK/","link":"","permalink":"http://yoursite.com/2018/12/05/android-NDK/","excerpt":"","text":"最近维护了公司的一个JNI项目，面向java/android平台使用，有幸接触了Java/Android 平台与c/c++ 的交互使用。 Java 与 c/c++ 交互使用 dll 形式 Android 与c/C++ 交互使用.so文件格式 预备知识JNI 基础概念 JNI 编程基础 android.mk 编写 假使我认为您已经能够使用c/c++ 编程，基本能够使用android studio的使用，不使用亦可以 Java 使用dllc语言头文件生成 使用javac javaName.java 生成.class 文件 使用javah javaName 生成 .h 头文件 note: 倘如您的java中有包名，那么退回到包名的根目录，使用以下形式的命令 javac com\\application\\javaName.java 生成.class 文件 avah com.application.javaName 生成 .h 头文件 如下图 本实验的代码： jni_md.h /jni.h 文件在安装的JDK进行提供 MainJava.java 12345678910 public class MainJava &#123; static&#123; System.loadLibrary(\"MainJava\"); &#125; public native String printTest(); public static void main(String[] args) &#123; System.out.println(new MainJava().printTest()); &#125;&#125; MainJava.h 123456789101112131415161718192021/* DO NOT EDIT THIS FILE - it is machine generated */#include \"jni.h\"/* Header for class MainJava */#ifndef _Included_MainJava#define _Included_MainJava#ifdef __cplusplusextern \"C\" &#123;#endif/** Class: MainJava* Method: printTest* Signature: ()Ljava/lang/String;*/JNIEXPORT jstring JNICALL Java_MainJava_printTest(JNIEnv *, jobject);#ifdef __cplusplus&#125;#endif#endif MainJava.c 12345 #include\"MainJava.h\"JNIEXPORT jstring JNICALL Java_MainJava_printTest (JNIEnv *env, jobject thisobj)&#123; return (*env)-&gt;NewStringUTF(env,\"this is c level\"); &#125; makefile 12345678910CC=gccRESULT=MainJava.dllCFLAG= -Wall -sharedsource=*.c$(RESULT):$(source) $(CC) $(CFLAG) $^ -o $@clean: del $(RESULT) Android使用 .so 文件生成 .so文件可以使用android studio中的内置的NDK-build ，也可以选择手动生成，我这里使用手动生成。NDK-build下载 需要将javac/javah 生成的 .h /.c /android.mk application.mk 文件放入jni 文件夹中，然后在此目录中运行ndk-build 命令 如下图 将生成的libs 拷贝到android 项目中的app/libs下面 在app/build.gradle中加入 123456.....sourceSets&#123; main&#123; jniLibs.srcDirs=['libs'] &#125;&#125; 效果如下 后语对于一些使用底层代码使用c/c++的程序，常常使用这种方式，移植到其他平台上，android/java 作为业务层呈现","categories":[{"name":"android","slug":"android","permalink":"http://yoursite.com/categories/android/"}],"tags":[{"name":"NDK","slug":"NDK","permalink":"http://yoursite.com/tags/NDK/"}]},{"title":"TCP 传输机制","slug":"TCP-transport-institution","date":"2018-11-15T00:40:55.000Z","updated":"2018-12-09T09:10:41.007Z","comments":true,"path":"2018/11/15/TCP-transport-institution/","link":"","permalink":"http://yoursite.com/2018/11/15/TCP-transport-institution/","excerpt":"","text":"说起TCP，第一印象是什么，嗯，可靠，面向连接。面向连接是每一个连接都是独立的。而对于可靠性，我的理解逻辑则按照下面的流程 TCP 流控制流控制涉及到了TCP中windows size fidld,对于TCP而言，在每一个TCP成功建立的连接都会初始化两个缓冲区，发送缓冲区和接收缓冲区，window size 的字段就是为了防止缓冲区数据溢出从而做出了设置，对于接收者，我们假设有两个变量 LastByteRead：从缓冲区最后读取的位置 LastByteRcvd：从缓冲区最后接收数据的位置 RcvBuffer：缓冲区的大小LastByteRcvd-LastByteRead&lt;=RcvBuffer 因而，我们要将通常将window size 设置成 cwnd = RcvBuffer-LastByteRcvd-LastByteRead，从而保证接收缓冲区不被溢出。相应的发送缓冲区 LastByteSent−LastByteAcked≤ cwnd 运用这一规则，在网络攻击中将windows size的值设置为1，就构成了http slow 攻击。 TCP 拥塞控制首先大部分TCP拥塞控制时端对端的。相对应的有一个网络协助方式（network-assist） 如果说流控制是控制避免TCP 缓冲区溢出，那么congestion control 就是在网络状态不好时，对TCP 发送流量进行控制，从而避免大量数据包丢失。 拥塞控制在TCP数据段中没有相应字段表示，但是还有有一个字段与他相关，那是ACK这个字段，拥塞能控制会根据接收到的ACK情况从而调整他的发送速率。 在TCP 发送数据过程中有三个阶段：此图来自《computer networking top to down》 从上图的状态图可以看到： 在slow start:一旦正确接收到ack,那么cwnd增长时指数级别的，一旦发生数据超时，拥塞控制状态中，此时cwnd数值除以2。或者接收到3此重复的ACK（超时之前），进入快速重传阶段。 拥塞控制：在这个阶段，cwnd数据增长就比较慢了，由于各个平台实现TCP差异，但是总的原则不会变，他增长速率，同样的在这个状态下，一旦发送超时，或者ACK重复的情况，依旧会Cwnd 数值减半 快速恢复：这个状态不是必要存在的，进入此状态的条件时ACK 重复，此状态结束之后，一般会进入拥塞控制阶段 TCP 流量竞争 一般来说，理想情况下，TCP连接时会平分网络节点的吞吐量的，但是由于每个TCP通过的路径的可能会有所差异，导致的网络状态的波动之类的情况，导致拥塞控制，可能会造成TCP流量的不平均的情况，因而，每个应用程序中TCP的连接数量的不同也会竞争流量，从而导致应用程序得到节点吞吐量不一样。 当然UDP 可能就不会出现这种情况，因为不存在拥塞控制这一机制，收到就接收，收不到就收不到。 网络协助方式此种方式时应用网络数据包丢失之类从而造成的拥塞控制对发送者进行一种反馈情况。 简单来说，TCP end-to-end 拥塞控制的形式，是根据ACK的情况进行判断网络状态，没有任何网络层参与，但是现在网络协助这种方式，是网络层根据网络状态直接将状态信息发送给接收端或者发送端的一种行为。 网络层反馈给发送者：将网络状态直接发送给发送端 网络层发聩给接收者，由接收者发送给发送者： 接收端收到网络状态信息后，将此信息与ACK一起发送给发送端 总结总的来说，TCP一直在处于发展中，目前而言也有类似其他的协议如DCCP(datagram congestion control Protocol)、DCTCP(data center TCP)、QUIC(quick udp internet connection,google 使用)、TFRC(TCP-friendly rate control,传输速率更平稳)、STTP….无论哪一种使用，哪一种更好，不仅仅取决其技术性，也取决社会行，商业性。","categories":[{"name":"network","slug":"network","permalink":"http://yoursite.com/categories/network/"}],"tags":[{"name":"network","slug":"network","permalink":"http://yoursite.com/tags/network/"}]},{"title":"复路分解与多复路","slug":"TCP-IP-demultipexing-multiplexing","date":"2018-11-13T12:37:21.000Z","updated":"2018-12-09T09:08:16.856Z","comments":true,"path":"2018/11/13/TCP-IP-demultipexing-multiplexing/","link":"","permalink":"http://yoursite.com/2018/11/13/TCP-IP-demultipexing-multiplexing/","excerpt":"","text":"复路分离与多复路发生在传输层的一种行为。 demultiplexing: At the receiving end, the transport layer examines these fields to identify the receiving socket and then directs the segment to that socket. This job of delivering the data in a transport-layer segment to the correct socket is called demultiplexing multiplexing: The job of gathering data chunks at the source host from different sockets, encapsulating each data chunk with header information (that will later be used in demultiplexing) to create segments, and passing the segments to the network layer is called multiplexing 中文含义 复路分离 在接收端，传输层根据数据段中的头字段特定字段[UDP：源port/目的port、TCP：源IP/port,目的IP/port]对数据帧进行分类，派送到不同的socket通道中，这个过程就是复路分离 多复路 传输层从上层应用层中不同的应用（socket）接收数据，然后封装成一个数据帧，派送到网络层，这个过程是多复路 那么具体流程是什么样的，请见下图 怎么看待socket socket 是接口 开发人员如果进行网络编程，使用socket 是不少的，现在比较常见的传输层协议常见TCP,UDP,SCTP,DCCP。socket是传输层与应用层的抽象网络接口，因此网络数据不可能直接通过应用层直接送到网络层，反之亦然，开发人员在应用层对socket拥有一切控制权，但是在传输层只有少量的控制权。 用socket干什么 上述所讲，socket 是接口，是建立在应用层和传输层之间的抽象层，因此对于低层的协议/数据，我们丝毫不用关心。举个例子，我们现在使用ftp 协议，我们只需要关系ftp中的对话规则，我怎么知道对话规则，直接找到RFC 文档，找到协议规则。不需要关心这个数据怎么传输到对方的。我们只需要做到知道两件事：我发送了什么 我接收到了什么。这样看来，使用socket 就像是一个黑匣子，放进去什么东西，出来了什么东西。就是这么简单？ 对，就是这样 TCP 和 UDP 建立通信的区别 UDP if two UDP segments have different source IP addresses and/or source port numbers, but have the same destination IP address and destination port number, then the two segments will be directed to the same destination process via the same destination socket. TCP In particular, and in contrast with UDP, two arriving TCP segments with different source IP addresses or source port numbers will (with the exception of a TCP segment carrying the original connectionestablishment request) be directed to two different sockets socket 是跨进程的，是一个系统资源，通过上述两段文字，从字面上看，TCP 是每来一个客户端，便建立一个socket 资源，UDP 则始终是一条socket 接收使用。但是善于利用的人，可针对这些特点，进行恶意的消耗资源 结束语本文只是针对了TCP/UDP 在网络框架（TCP/IP 5层结构）中一个大概的位置和作用，需要更加进行了解的请移步computer_network_top_to_down","categories":[{"name":"network","slug":"network","permalink":"http://yoursite.com/categories/network/"}],"tags":[{"name":"network","slug":"network","permalink":"http://yoursite.com/tags/network/"}]}]}